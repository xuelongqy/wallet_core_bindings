// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
import 'dart:ffi' as ffi;

/// Auto-generated, internal bindings to TrustWalletCore
class TrustWalletCoreBindings {
  /// Holds the symbol lookup function.
  final ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
      _lookup;

  /// The symbols are looked up in [dynamicLibrary].
  TrustWalletCoreBindings(ffi.DynamicLibrary dynamicLibrary)
      : _lookup = dynamicLibrary.lookup;

  /// The symbols are looked up with [lookup].
  TrustWalletCoreBindings.fromLookup(
      ffi.Pointer<T> Function<T extends ffi.NativeType>(String symbolName)
          lookup)
      : _lookup = lookup;

  ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> signal(
    int arg0,
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> arg1,
  ) {
    return _signal(
      arg0,
      arg1,
    );
  }

  late final _signalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
              ffi.Int,
              ffi.Pointer<
                  ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>>('signal');
  late final _signal = _signalPtr.asFunction<
      ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>> Function(
          int, ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>)>();

  int getpriority(
    int arg0,
    int arg1,
  ) {
    return _getpriority(
      arg0,
      arg1,
    );
  }

  late final _getpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t)>>(
          'getpriority');
  late final _getpriority =
      _getpriorityPtr.asFunction<int Function(int, int)>();

  int getiopolicy_np(
    int arg0,
    int arg1,
  ) {
    return _getiopolicy_np(
      arg0,
      arg1,
    );
  }

  late final _getiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>(
          'getiopolicy_np');
  late final _getiopolicy_np =
      _getiopolicy_npPtr.asFunction<int Function(int, int)>();

  int getrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _getrlimit(
      arg0,
      arg1,
    );
  }

  late final _getrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'getrlimit');
  late final _getrlimit =
      _getrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int getrusage(
    int arg0,
    ffi.Pointer<rusage> arg1,
  ) {
    return _getrusage(
      arg0,
      arg1,
    );
  }

  late final _getrusagePtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rusage>)>>(
      'getrusage');
  late final _getrusage =
      _getrusagePtr.asFunction<int Function(int, ffi.Pointer<rusage>)>();

  int setpriority(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setpriority(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setpriorityPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, id_t, ffi.Int)>>(
          'setpriority');
  late final _setpriority =
      _setpriorityPtr.asFunction<int Function(int, int, int)>();

  int setiopolicy_np(
    int arg0,
    int arg1,
    int arg2,
  ) {
    return _setiopolicy_np(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _setiopolicy_npPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int, ffi.Int)>>(
          'setiopolicy_np');
  late final _setiopolicy_np =
      _setiopolicy_npPtr.asFunction<int Function(int, int, int)>();

  int setrlimit(
    int arg0,
    ffi.Pointer<rlimit> arg1,
  ) {
    return _setrlimit(
      arg0,
      arg1,
    );
  }

  late final _setrlimitPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Pointer<rlimit>)>>(
      'setrlimit');
  late final _setrlimit =
      _setrlimitPtr.asFunction<int Function(int, ffi.Pointer<rlimit>)>();

  int wait1(
    ffi.Pointer<ffi.Int> arg0,
  ) {
    return _wait1(
      arg0,
    );
  }

  late final _wait1Ptr =
      _lookup<ffi.NativeFunction<pid_t Function(ffi.Pointer<ffi.Int>)>>('wait');
  late final _wait1 =
      _wait1Ptr.asFunction<int Function(ffi.Pointer<ffi.Int>)>();

  int waitpid(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
  ) {
    return _waitpid(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _waitpidPtr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int)>>('waitpid');
  late final _waitpid =
      _waitpidPtr.asFunction<int Function(int, ffi.Pointer<ffi.Int>, int)>();

  int waitid(
    int arg0,
    int arg1,
    ffi.Pointer<siginfo_t> arg2,
    int arg3,
  ) {
    return _waitid(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _waitidPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int32, id_t, ffi.Pointer<siginfo_t>, ffi.Int)>>('waitid');
  late final _waitid = _waitidPtr
      .asFunction<int Function(int, int, ffi.Pointer<siginfo_t>, int)>();

  int wait3(
    ffi.Pointer<ffi.Int> arg0,
    int arg1,
    ffi.Pointer<rusage> arg2,
  ) {
    return _wait3(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _wait3Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(
              ffi.Pointer<ffi.Int>, ffi.Int, ffi.Pointer<rusage>)>>('wait3');
  late final _wait3 = _wait3Ptr.asFunction<
      int Function(ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  int wait4(
    int arg0,
    ffi.Pointer<ffi.Int> arg1,
    int arg2,
    ffi.Pointer<rusage> arg3,
  ) {
    return _wait4(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _wait4Ptr = _lookup<
      ffi.NativeFunction<
          pid_t Function(pid_t, ffi.Pointer<ffi.Int>, ffi.Int,
              ffi.Pointer<rusage>)>>('wait4');
  late final _wait4 = _wait4Ptr.asFunction<
      int Function(int, ffi.Pointer<ffi.Int>, int, ffi.Pointer<rusage>)>();

  ffi.Pointer<ffi.Void> alloca(
    int __size,
  ) {
    return _alloca(
      __size,
    );
  }

  late final _allocaPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'alloca');
  late final _alloca =
      _allocaPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  late final ffi.Pointer<ffi.Int> ___mb_cur_max =
      _lookup<ffi.Int>('__mb_cur_max');

  int get __mb_cur_max => ___mb_cur_max.value;

  set __mb_cur_max(int value) => ___mb_cur_max.value = value;

  ffi.Pointer<ffi.Void> malloc_type_malloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_malloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_malloc');
  late final _malloc_type_malloc = _malloc_type_mallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_calloc(
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_calloc(
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, ffi.Size, malloc_type_id_t)>>('malloc_type_calloc');
  late final _malloc_type_calloc = _malloc_type_callocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  void malloc_type_free(
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_free(
      ptr,
      type_id,
    );
  }

  late final _malloc_type_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>, malloc_type_id_t)>>('malloc_type_free');
  late final _malloc_type_free = _malloc_type_freePtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_realloc(
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_realloc(
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_realloc');
  late final _malloc_type_realloc = _malloc_type_reallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_valloc(
    int size,
    int type_id,
  ) {
    return _malloc_type_valloc(
      size,
      type_id,
    );
  }

  late final _malloc_type_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Size, malloc_type_id_t)>>('malloc_type_valloc');
  late final _malloc_type_valloc = _malloc_type_vallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_aligned_alloc(
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_aligned_alloc(
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size,
              malloc_type_id_t)>>('malloc_type_aligned_alloc');
  late final _malloc_type_aligned_alloc = _malloc_type_aligned_allocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(int, int, int)>();

  int malloc_type_posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> memptr,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_posix_memalign(
      memptr,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_posix_memalign');
  late final _malloc_type_posix_memalign =
      _malloc_type_posix_memalignPtr.asFunction<
          int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_malloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_malloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_mallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_malloc');
  late final _malloc_type_zone_malloc = _malloc_type_zone_mallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_calloc(
    ffi.Pointer<malloc_zone_t> zone,
    int count,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_calloc(
      zone,
      count,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_calloc');
  late final _malloc_type_zone_calloc = _malloc_type_zone_callocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<malloc_zone_t>, int, int, int)>();

  void malloc_type_zone_free(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int type_id,
  ) {
    return _malloc_type_zone_free(
      zone,
      ptr,
      type_id,
    );
  }

  late final _malloc_type_zone_freePtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>,
              malloc_type_id_t)>>('malloc_type_zone_free');
  late final _malloc_type_zone_free = _malloc_type_zone_freePtr.asFunction<
      void Function(ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_realloc(
    ffi.Pointer<malloc_zone_t> zone,
    ffi.Pointer<ffi.Void> ptr,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_realloc(
      zone,
      ptr,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_realloc');
  late final _malloc_type_zone_realloc =
      _malloc_type_zone_reallocPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, ffi.Pointer<ffi.Void>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_valloc(
    ffi.Pointer<malloc_zone_t> zone,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_valloc(
      zone,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_vallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              malloc_type_id_t)>>('malloc_type_zone_valloc');
  late final _malloc_type_zone_valloc = _malloc_type_zone_vallocPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, int, int)>();

  ffi.Pointer<ffi.Void> malloc_type_zone_memalign(
    ffi.Pointer<malloc_zone_t> zone,
    int alignment,
    int size,
    int type_id,
  ) {
    return _malloc_type_zone_memalign(
      zone,
      alignment,
      size,
      type_id,
    );
  }

  late final _malloc_type_zone_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Pointer<malloc_zone_t>, ffi.Size,
              ffi.Size, malloc_type_id_t)>>('malloc_type_zone_memalign');
  late final _malloc_type_zone_memalign =
      _malloc_type_zone_memalignPtr.asFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<malloc_zone_t>, int, int, int)>();

  ffi.Pointer<ffi.Void> malloc(
    int __size,
  ) {
    return _malloc(
      __size,
    );
  }

  late final _mallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'malloc');
  late final _malloc =
      _mallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> calloc(
    int __count,
    int __size,
  ) {
    return _calloc(
      __count,
      __size,
    );
  }

  late final _callocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('calloc');
  late final _calloc =
      _callocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  void free(
    ffi.Pointer<ffi.Void> arg0,
  ) {
    return _free(
      arg0,
    );
  }

  late final _freePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>(
          'free');
  late final _free =
      _freePtr.asFunction<void Function(ffi.Pointer<ffi.Void>)>();

  ffi.Pointer<ffi.Void> realloc(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _realloc(
      __ptr,
      __size,
    );
  }

  late final _reallocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('realloc');
  late final _realloc = _reallocPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> reallocf(
    ffi.Pointer<ffi.Void> __ptr,
    int __size,
  ) {
    return _reallocf(
      __ptr,
      __size,
    );
  }

  late final _reallocfPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>, ffi.Size)>>('reallocf');
  late final _reallocf = _reallocfPtr
      .asFunction<ffi.Pointer<ffi.Void> Function(ffi.Pointer<ffi.Void>, int)>();

  ffi.Pointer<ffi.Void> valloc(
    int __size,
  ) {
    return _valloc(
      __size,
    );
  }

  late final _vallocPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Void> Function(ffi.Size)>>(
          'valloc');
  late final _valloc =
      _vallocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int)>();

  ffi.Pointer<ffi.Void> aligned_alloc(
    int __alignment,
    int __size,
  ) {
    return _aligned_alloc(
      __alignment,
      __size,
    );
  }

  late final _aligned_allocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(ffi.Size, ffi.Size)>>('aligned_alloc');
  late final _aligned_alloc =
      _aligned_allocPtr.asFunction<ffi.Pointer<ffi.Void> Function(int, int)>();

  int posix_memalign(
    ffi.Pointer<ffi.Pointer<ffi.Void>> __memptr,
    int __alignment,
    int __size,
  ) {
    return _posix_memalign(
      __memptr,
      __alignment,
      __size,
    );
  }

  late final _posix_memalignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, ffi.Size,
              ffi.Size)>>('posix_memalign');
  late final _posix_memalign = _posix_memalignPtr
      .asFunction<int Function(ffi.Pointer<ffi.Pointer<ffi.Void>>, int, int)>();

  void abort() {
    return _abort();
  }

  late final _abortPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('abort');
  late final _abort = _abortPtr.asFunction<void Function()>();

  int abs(
    int arg0,
  ) {
    return _abs(
      arg0,
    );
  }

  late final _absPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('abs');
  late final _abs = _absPtr.asFunction<int Function(int)>();

  int atexit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _atexit(
      arg0,
    );
  }

  late final _atexitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>('atexit');
  late final _atexit = _atexitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  int at_quick_exit(
    ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>> arg0,
  ) {
    return _at_quick_exit(
      arg0,
    );
  }

  late final _at_quick_exitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(
                  ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>>(
      'at_quick_exit');
  late final _at_quick_exit = _at_quick_exitPtr.asFunction<
      int Function(ffi.Pointer<ffi.NativeFunction<ffi.Void Function()>>)>();

  double atof(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atof(
      arg0,
    );
  }

  late final _atofPtr =
      _lookup<ffi.NativeFunction<ffi.Double Function(ffi.Pointer<ffi.Char>)>>(
          'atof');
  late final _atof =
      _atofPtr.asFunction<double Function(ffi.Pointer<ffi.Char>)>();

  int atoi(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoi(
      arg0,
    );
  }

  late final _atoiPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'atoi');
  late final _atoi = _atoiPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atol(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atol(
      arg0,
    );
  }

  late final _atolPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'atol');
  late final _atol = _atolPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int atoll(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _atoll(
      arg0,
    );
  }

  late final _atollPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.Pointer<ffi.Char>)>>(
          'atoll');
  late final _atoll =
      _atollPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Void> bsearch(
    ffi.Pointer<ffi.Void> __key,
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _bsearch(
      __key,
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _bsearchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Void> Function(
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('bsearch');
  late final _bsearch = _bsearchPtr.asFunction<
      ffi.Pointer<ffi.Void> Function(
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  div_t div(
    int arg0,
    int arg1,
  ) {
    return _div(
      arg0,
      arg1,
    );
  }

  late final _divPtr =
      _lookup<ffi.NativeFunction<div_t Function(ffi.Int, ffi.Int)>>('div');
  late final _div = _divPtr.asFunction<div_t Function(int, int)>();

  void exit(
    int arg0,
  ) {
    return _exit(
      arg0,
    );
  }

  late final _exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('exit');
  late final _exit = _exitPtr.asFunction<void Function(int)>();

  ffi.Pointer<ffi.Char> getenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _getenv(
      arg0,
    );
  }

  late final _getenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('getenv');
  late final _getenv = _getenvPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int labs(
    int arg0,
  ) {
    return _labs(
      arg0,
    );
  }

  late final _labsPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Long)>>('labs');
  late final _labs = _labsPtr.asFunction<int Function(int)>();

  ldiv_t ldiv(
    int arg0,
    int arg1,
  ) {
    return _ldiv(
      arg0,
      arg1,
    );
  }

  late final _ldivPtr =
      _lookup<ffi.NativeFunction<ldiv_t Function(ffi.Long, ffi.Long)>>('ldiv');
  late final _ldiv = _ldivPtr.asFunction<ldiv_t Function(int, int)>();

  int llabs(
    int arg0,
  ) {
    return _llabs(
      arg0,
    );
  }

  late final _llabsPtr =
      _lookup<ffi.NativeFunction<ffi.LongLong Function(ffi.LongLong)>>('llabs');
  late final _llabs = _llabsPtr.asFunction<int Function(int)>();

  lldiv_t lldiv(
    int arg0,
    int arg1,
  ) {
    return _lldiv(
      arg0,
      arg1,
    );
  }

  late final _lldivPtr =
      _lookup<ffi.NativeFunction<lldiv_t Function(ffi.LongLong, ffi.LongLong)>>(
          'lldiv');
  late final _lldiv = _lldivPtr.asFunction<lldiv_t Function(int, int)>();

  int mblen(
    ffi.Pointer<ffi.Char> __s,
    int __n,
  ) {
    return _mblen(
      __s,
      __n,
    );
  }

  late final _mblenPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Size)>>('mblen');
  late final _mblen =
      _mblenPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  int mbstowcs(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbstowcs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbstowcsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbstowcs');
  late final _mbstowcs = _mbstowcsPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  int mbtowc(
    ffi.Pointer<ffi.WChar> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __n,
  ) {
    return _mbtowc(
      arg0,
      arg1,
      __n,
    );
  }

  late final _mbtowcPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>,
              ffi.Size)>>('mbtowc');
  late final _mbtowc = _mbtowcPtr.asFunction<
      int Function(ffi.Pointer<ffi.WChar>, ffi.Pointer<ffi.Char>, int)>();

  void qsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _qsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort');
  late final _qsort = _qsortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void quick_exit(
    int arg0,
  ) {
    return _quick_exit(
      arg0,
    );
  }

  late final _quick_exitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('quick_exit');
  late final _quick_exit = _quick_exitPtr.asFunction<void Function(int)>();

  int rand() {
    return _rand();
  }

  late final _randPtr = _lookup<ffi.NativeFunction<ffi.Int Function()>>('rand');
  late final _rand = _randPtr.asFunction<int Function()>();

  void srand(
    int arg0,
  ) {
    return _srand(
      arg0,
    );
  }

  late final _srandPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>('srand');
  late final _srand = _srandPtr.asFunction<void Function(int)>();

  double strtod(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtod(
      arg0,
      arg1,
    );
  }

  late final _strtodPtr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtod');
  late final _strtod = _strtodPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  double strtof(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _strtof(
      arg0,
      arg1,
    );
  }

  late final _strtofPtr = _lookup<
      ffi.NativeFunction<
          ffi.Float Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtof');
  late final _strtof = _strtofPtr.asFunction<
      double Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtol(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtol(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtol');
  late final _strtol = _strtolPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoll(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoll(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtollPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoll');
  late final _strtoll = _strtollPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoul(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoul(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoulPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoul');
  late final _strtoul = _strtoulPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtoull(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoull(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoullPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoull');
  late final _strtoull = _strtoullPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int system(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _system(
      arg0,
    );
  }

  late final _systemPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'system');
  late final _system =
      _systemPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int wcstombs(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.WChar> arg1,
    int __n,
  ) {
    return _wcstombs(
      arg0,
      arg1,
      __n,
    );
  }

  late final _wcstombsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Size Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>,
              ffi.Size)>>('wcstombs');
  late final _wcstombs = _wcstombsPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.WChar>, int)>();

  int wctomb(
    ffi.Pointer<ffi.Char> arg0,
    int arg1,
  ) {
    return _wctomb(
      arg0,
      arg1,
    );
  }

  late final _wctombPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.WChar)>>('wctomb');
  late final _wctomb =
      _wctombPtr.asFunction<int Function(ffi.Pointer<ffi.Char>, int)>();

  void _Exit(
    int arg0,
  ) {
    return __Exit(
      arg0,
    );
  }

  late final __ExitPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>('_Exit');
  late final __Exit = __ExitPtr.asFunction<void Function(int)>();

  int a64l(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _a64l(
      arg0,
    );
  }

  late final _a64lPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function(ffi.Pointer<ffi.Char>)>>(
          'a64l');
  late final _a64l = _a64lPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  double drand48() {
    return _drand48();
  }

  late final _drand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Double Function()>>('drand48');
  late final _drand48 = _drand48Ptr.asFunction<double Function()>();

  ffi.Pointer<ffi.Char> ecvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _ecvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _ecvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('ecvt');
  late final _ecvt = _ecvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  double erand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _erand48(
      arg0,
    );
  }

  late final _erand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Double Function(ffi.Pointer<ffi.UnsignedShort>)>>('erand48');
  late final _erand48 =
      _erand48Ptr.asFunction<double Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> fcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Int> arg2,
    ffi.Pointer<ffi.Int> arg3,
  ) {
    return _fcvt(
      arg0,
      arg1,
      arg2,
      arg3,
    );
  }

  late final _fcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Double, ffi.Int,
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>>('fcvt');
  late final _fcvt = _fcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          double, int, ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Int>)>();

  ffi.Pointer<ffi.Char> gcvt(
    double arg0,
    int arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _gcvt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _gcvtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Double, ffi.Int, ffi.Pointer<ffi.Char>)>>('gcvt');
  late final _gcvt = _gcvtPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(double, int, ffi.Pointer<ffi.Char>)>();

  int getsubopt(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _getsubopt(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _getsuboptPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('getsubopt');
  late final _getsubopt = _getsuboptPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int grantpt(
    int arg0,
  ) {
    return _grantpt(
      arg0,
    );
  }

  late final _grantptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('grantpt');
  late final _grantpt = _grantptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> initstate(
    int arg0,
    ffi.Pointer<ffi.Char> arg1,
    int __size,
  ) {
    return _initstate(
      arg0,
      arg1,
      __size,
    );
  }

  late final _initstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.UnsignedInt, ffi.Pointer<ffi.Char>, ffi.Size)>>('initstate');
  late final _initstate = _initstatePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, ffi.Pointer<ffi.Char>, int)>();

  int jrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _jrand48(
      arg0,
    );
  }

  late final _jrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('jrand48');
  late final _jrand48 =
      _jrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  ffi.Pointer<ffi.Char> l64a(
    int arg0,
  ) {
    return _l64a(
      arg0,
    );
  }

  late final _l64aPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Long)>>(
          'l64a');
  late final _l64a = _l64aPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  void lcong48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _lcong48(
      arg0,
    );
  }

  late final _lcong48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.UnsignedShort>)>>('lcong48');
  late final _lcong48 =
      _lcong48Ptr.asFunction<void Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int lrand48() {
    return _lrand48();
  }

  late final _lrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('lrand48');
  late final _lrand48 = _lrand48Ptr.asFunction<int Function()>();

  ffi.Pointer<ffi.Char> mktemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mktemp(
      arg0,
    );
  }

  late final _mktempPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('mktemp');
  late final _mktemp = _mktempPtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  int mkstemp(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _mkstemp(
      arg0,
    );
  }

  late final _mkstempPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'mkstemp');
  late final _mkstemp =
      _mkstempPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int mrand48() {
    return _mrand48();
  }

  late final _mrand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('mrand48');
  late final _mrand48 = _mrand48Ptr.asFunction<int Function()>();

  int nrand48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _nrand48(
      arg0,
    );
  }

  late final _nrand48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Long Function(ffi.Pointer<ffi.UnsignedShort>)>>('nrand48');
  late final _nrand48 =
      _nrand48Ptr.asFunction<int Function(ffi.Pointer<ffi.UnsignedShort>)>();

  int posix_openpt(
    int arg0,
  ) {
    return _posix_openpt(
      arg0,
    );
  }

  late final _posix_openptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('posix_openpt');
  late final _posix_openpt = _posix_openptPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> ptsname(
    int arg0,
  ) {
    return _ptsname(
      arg0,
    );
  }

  late final _ptsnamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int)>>(
          'ptsname');
  late final _ptsname =
      _ptsnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int ptsname_r(
    int fildes,
    ffi.Pointer<ffi.Char> buffer,
    int buflen,
  ) {
    return _ptsname_r(
      fildes,
      buffer,
      buflen,
    );
  }

  late final _ptsname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Int, ffi.Pointer<ffi.Char>, ffi.Size)>>('ptsname_r');
  late final _ptsname_r =
      _ptsname_rPtr.asFunction<int Function(int, ffi.Pointer<ffi.Char>, int)>();

  int putenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _putenv(
      arg0,
    );
  }

  late final _putenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'putenv');
  late final _putenv =
      _putenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int random() {
    return _random();
  }

  late final _randomPtr =
      _lookup<ffi.NativeFunction<ffi.Long Function()>>('random');
  late final _random = _randomPtr.asFunction<int Function()>();

  int rand_r(
    ffi.Pointer<ffi.UnsignedInt> arg0,
  ) {
    return _rand_r(
      arg0,
    );
  }

  late final _rand_rPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.UnsignedInt>)>>(
      'rand_r');
  late final _rand_r =
      _rand_rPtr.asFunction<int Function(ffi.Pointer<ffi.UnsignedInt>)>();

  ffi.Pointer<ffi.Char> realpath(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _realpath(
      arg0,
      arg1,
    );
  }

  late final _realpathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('realpath');
  late final _realpath = _realpathPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.UnsignedShort> seed48(
    ffi.Pointer<ffi.UnsignedShort> arg0,
  ) {
    return _seed48(
      arg0,
    );
  }

  late final _seed48Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.UnsignedShort> Function(
              ffi.Pointer<ffi.UnsignedShort>)>>('seed48');
  late final _seed48 = _seed48Ptr.asFunction<
      ffi.Pointer<ffi.UnsignedShort> Function(
          ffi.Pointer<ffi.UnsignedShort>)>();

  int setenv(
    ffi.Pointer<ffi.Char> __name,
    ffi.Pointer<ffi.Char> __value,
    int __overwrite,
  ) {
    return _setenv(
      __name,
      __value,
      __overwrite,
    );
  }

  late final _setenvPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Int)>>('setenv');
  late final _setenv = _setenvPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  void setkey(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setkey(
      arg0,
    );
  }

  late final _setkeyPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setkey');
  late final _setkey =
      _setkeyPtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  ffi.Pointer<ffi.Char> setstate(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setstate(
      arg0,
    );
  }

  late final _setstatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>>('setstate');
  late final _setstate = _setstatePtr
      .asFunction<ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>)>();

  void srand48(
    int arg0,
  ) {
    return _srand48(
      arg0,
    );
  }

  late final _srand48Ptr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Long)>>('srand48');
  late final _srand48 = _srand48Ptr.asFunction<void Function(int)>();

  void srandom(
    int arg0,
  ) {
    return _srandom(
      arg0,
    );
  }

  late final _srandomPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.UnsignedInt)>>(
          'srandom');
  late final _srandom = _srandomPtr.asFunction<void Function(int)>();

  int unlockpt(
    int arg0,
  ) {
    return _unlockpt(
      arg0,
    );
  }

  late final _unlockptPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int)>>('unlockpt');
  late final _unlockpt = _unlockptPtr.asFunction<int Function(int)>();

  int unsetenv(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _unsetenv(
      arg0,
    );
  }

  late final _unsetenvPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'unsetenv');
  late final _unsetenv =
      _unsetenvPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int arc4random() {
    return _arc4random();
  }

  late final _arc4randomPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function()>>('arc4random');
  late final _arc4random = _arc4randomPtr.asFunction<int Function()>();

  void arc4random_addrandom(
    ffi.Pointer<ffi.UnsignedChar> arg0,
    int __datlen,
  ) {
    return _arc4random_addrandom(
      arg0,
      __datlen,
    );
  }

  late final _arc4random_addrandomPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.UnsignedChar>, ffi.Int)>>('arc4random_addrandom');
  late final _arc4random_addrandom = _arc4random_addrandomPtr
      .asFunction<void Function(ffi.Pointer<ffi.UnsignedChar>, int)>();

  void arc4random_buf(
    ffi.Pointer<ffi.Void> __buf,
    int __nbytes,
  ) {
    return _arc4random_buf(
      __buf,
      __nbytes,
    );
  }

  late final _arc4random_bufPtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Size)>>(
      'arc4random_buf');
  late final _arc4random_buf = _arc4random_bufPtr
      .asFunction<void Function(ffi.Pointer<ffi.Void>, int)>();

  void arc4random_stir() {
    return _arc4random_stir();
  }

  late final _arc4random_stirPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('arc4random_stir');
  late final _arc4random_stir =
      _arc4random_stirPtr.asFunction<void Function()>();

  int arc4random_uniform(
    int __upper_bound,
  ) {
    return _arc4random_uniform(
      __upper_bound,
    );
  }

  late final _arc4random_uniformPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Uint32)>>(
          'arc4random_uniform');
  late final _arc4random_uniform =
      _arc4random_uniformPtr.asFunction<int Function(int)>();

  ffi.Pointer<ffi.Char> cgetcap(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    int arg2,
  ) {
    return _cgetcap(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetcapPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Char>, ffi.Int)>>('cgetcap');
  late final _cgetcap = _cgetcapPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>, int)>();

  int cgetclose() {
    return _cgetclose();
  }

  late final _cgetclosePtr =
      _lookup<ffi.NativeFunction<ffi.Int Function()>>('cgetclose');
  late final _cgetclose = _cgetclosePtr.asFunction<int Function()>();

  int cgetent(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
    ffi.Pointer<ffi.Char> arg2,
  ) {
    return _cgetent(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetentPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Char>)>>('cgetent');
  late final _cgetent = _cgetentPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Pointer<ffi.Char>)>();

  int cgetfirst(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetfirst(
      arg0,
      arg1,
    );
  }

  late final _cgetfirstPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetfirst');
  late final _cgetfirst = _cgetfirstPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetmatch(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
  ) {
    return _cgetmatch(
      arg0,
      arg1,
    );
  }

  late final _cgetmatchPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>>('cgetmatch');
  late final _cgetmatch = _cgetmatchPtr
      .asFunction<int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>)>();

  int cgetnext(
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg0,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg1,
  ) {
    return _cgetnext(
      arg0,
      arg1,
    );
  }

  late final _cgetnextPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetnext');
  late final _cgetnext = _cgetnextPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.Char>>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetnum(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Long> arg2,
  ) {
    return _cgetnum(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetnumPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Long>)>>('cgetnum');
  late final _cgetnum = _cgetnumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Long>)>();

  int cgetset(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _cgetset(
      arg0,
    );
  }

  late final _cgetsetPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'cgetset');
  late final _cgetset =
      _cgetsetPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int cgetstr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetstr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetstrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetstr');
  late final _cgetstr = _cgetstrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int cgetustr(
    ffi.Pointer<ffi.Char> arg0,
    ffi.Pointer<ffi.Char> arg1,
    ffi.Pointer<ffi.Pointer<ffi.Char>> arg2,
  ) {
    return _cgetustr(
      arg0,
      arg1,
      arg2,
    );
  }

  late final _cgetustrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('cgetustr');
  late final _cgetustr = _cgetustrPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Char>,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int daemon(
    int arg0,
    int arg1,
  ) {
    return _daemon(
      arg0,
      arg1,
    );
  }

  late final _daemonPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int, ffi.Int)>>('daemon');
  late final _daemon = _daemonPtr.asFunction<int Function(int, int)>();

  ffi.Pointer<ffi.Char> devname(
    int arg0,
    int arg1,
  ) {
    return _devname(
      arg0,
      arg1,
    );
  }

  late final _devnamePtr = _lookup<
          ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(dev_t, mode_t)>>(
      'devname');
  late final _devname =
      _devnamePtr.asFunction<ffi.Pointer<ffi.Char> Function(int, int)>();

  ffi.Pointer<ffi.Char> devname_r(
    int arg0,
    int arg1,
    ffi.Pointer<ffi.Char> buf,
    int len,
  ) {
    return _devname_r(
      arg0,
      arg1,
      buf,
      len,
    );
  }

  late final _devname_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              dev_t, mode_t, ffi.Pointer<ffi.Char>, ffi.Int)>>('devname_r');
  late final _devname_r = _devname_rPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(int, int, ffi.Pointer<ffi.Char>, int)>();

  ffi.Pointer<ffi.Char> getbsize(
    ffi.Pointer<ffi.Int> arg0,
    ffi.Pointer<ffi.Long> arg1,
  ) {
    return _getbsize(
      arg0,
      arg1,
    );
  }

  late final _getbsizePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>>('getbsize');
  late final _getbsize = _getbsizePtr.asFunction<
      ffi.Pointer<ffi.Char> Function(
          ffi.Pointer<ffi.Int>, ffi.Pointer<ffi.Long>)>();

  int getloadavg(
    ffi.Pointer<ffi.Double> arg0,
    int __nelem,
  ) {
    return _getloadavg(
      arg0,
      __nelem,
    );
  }

  late final _getloadavgPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Double>, ffi.Int)>>('getloadavg');
  late final _getloadavg =
      _getloadavgPtr.asFunction<int Function(ffi.Pointer<ffi.Double>, int)>();

  ffi.Pointer<ffi.Char> getprogname() {
    return _getprogname();
  }

  late final _getprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function()>>(
          'getprogname');
  late final _getprogname =
      _getprognamePtr.asFunction<ffi.Pointer<ffi.Char> Function()>();

  void setprogname(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _setprogname(
      arg0,
    );
  }

  late final _setprognamePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Char>)>>(
          'setprogname');
  late final _setprogname =
      _setprognamePtr.asFunction<void Function(ffi.Pointer<ffi.Char>)>();

  int heapsort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _heapsort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _heapsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('heapsort');
  late final _heapsort = _heapsortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  int mergesort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _mergesort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _mergesortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('mergesort');
  late final _mergesort = _mergesortPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort(
      __base,
      __nel,
      __width,
      __compar,
    );
  }

  late final _psortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort');
  late final _psort = _psortPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(
                      ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>)>>)>();

  void psort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _psort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _psort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('psort_r');
  late final _psort_r = _psort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  void qsort_r(
    ffi.Pointer<ffi.Void> __base,
    int __nel,
    int __width,
    ffi.Pointer<ffi.Void> arg3,
    ffi.Pointer<
            ffi.NativeFunction<
                ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                    ffi.Pointer<ffi.Void>)>>
        __compar,
  ) {
    return _qsort_r(
      __base,
      __nel,
      __width,
      arg3,
      __compar,
    );
  }

  late final _qsort_rPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<ffi.Void>,
              ffi.Size,
              ffi.Size,
              ffi.Pointer<ffi.Void>,
              ffi.Pointer<
                  ffi.NativeFunction<
                      ffi.Int Function(
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>,
                          ffi.Pointer<ffi.Void>)>>)>>('qsort_r');
  late final _qsort_r = _qsort_rPtr.asFunction<
      void Function(
          ffi.Pointer<ffi.Void>,
          int,
          int,
          ffi.Pointer<ffi.Void>,
          ffi.Pointer<
              ffi.NativeFunction<
                  ffi.Int Function(ffi.Pointer<ffi.Void>, ffi.Pointer<ffi.Void>,
                      ffi.Pointer<ffi.Void>)>>)>();

  int radixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _radixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _radixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('radixsort');
  late final _radixsort = _radixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  int rpmatch(
    ffi.Pointer<ffi.Char> arg0,
  ) {
    return _rpmatch(
      arg0,
    );
  }

  late final _rpmatchPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Pointer<ffi.Char>)>>(
          'rpmatch');
  late final _rpmatch =
      _rpmatchPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  int sradixsort(
    ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>> __base,
    int __nel,
    ffi.Pointer<ffi.UnsignedChar> __table,
    int __endbyte,
  ) {
    return _sradixsort(
      __base,
      __nel,
      __table,
      __endbyte,
    );
  }

  late final _sradixsortPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, ffi.Int,
              ffi.Pointer<ffi.UnsignedChar>, ffi.UnsignedInt)>>('sradixsort');
  late final _sradixsort = _sradixsortPtr.asFunction<
      int Function(ffi.Pointer<ffi.Pointer<ffi.UnsignedChar>>, int,
          ffi.Pointer<ffi.UnsignedChar>, int)>();

  void sranddev() {
    return _sranddev();
  }

  late final _sranddevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('sranddev');
  late final _sranddev = _sranddevPtr.asFunction<void Function()>();

  void srandomdev() {
    return _srandomdev();
  }

  late final _srandomdevPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function()>>('srandomdev');
  late final _srandomdev = _srandomdevPtr.asFunction<void Function()>();

  int strtonum(
    ffi.Pointer<ffi.Char> __numstr,
    int __minval,
    int __maxval,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __errstrp,
  ) {
    return _strtonum(
      __numstr,
      __minval,
      __maxval,
      __errstrp,
    );
  }

  late final _strtonumPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>, ffi.LongLong,
              ffi.LongLong, ffi.Pointer<ffi.Pointer<ffi.Char>>)>>('strtonum');
  late final _strtonum = _strtonumPtr.asFunction<
      int Function(ffi.Pointer<ffi.Char>, int, int,
          ffi.Pointer<ffi.Pointer<ffi.Char>>)>();

  int strtoq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtoq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtoqPtr = _lookup<
      ffi.NativeFunction<
          ffi.LongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtoq');
  late final _strtoq = _strtoqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  int strtouq(
    ffi.Pointer<ffi.Char> __str,
    ffi.Pointer<ffi.Pointer<ffi.Char>> __endptr,
    int __base,
  ) {
    return _strtouq(
      __str,
      __endptr,
      __base,
    );
  }

  late final _strtouqPtr = _lookup<
      ffi.NativeFunction<
          ffi.UnsignedLongLong Function(ffi.Pointer<ffi.Char>,
              ffi.Pointer<ffi.Pointer<ffi.Char>>, ffi.Int)>>('strtouq');
  late final _strtouq = _strtouqPtr.asFunction<
      int Function(
          ffi.Pointer<ffi.Char>, ffi.Pointer<ffi.Pointer<ffi.Char>>, int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _suboptarg =
      _lookup<ffi.Pointer<ffi.Char>>('suboptarg');

  ffi.Pointer<ffi.Char> get suboptarg => _suboptarg.value;

  set suboptarg(ffi.Pointer<ffi.Char> value) => _suboptarg.value = value;

  /// Determine if the HD Version is public
  ///
  /// \param version HD version
  /// \return true if the version is public, false otherwise
  bool TWHDVersionIsPublic(
    int version,
  ) {
    return _TWHDVersionIsPublic(
      version,
    );
  }

  late final _TWHDVersionIsPublicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'TWHDVersionIsPublic');
  late final _TWHDVersionIsPublic =
      _TWHDVersionIsPublicPtr.asFunction<bool Function(int)>();

  /// Determine if the HD Version is private
  ///
  /// \param version HD version
  /// \return true if the version is private, false otherwise
  bool TWHDVersionIsPrivate(
    int version,
  ) {
    return _TWHDVersionIsPrivate(
      version,
    );
  }

  late final _TWHDVersionIsPrivatePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'TWHDVersionIsPrivate');
  late final _TWHDVersionIsPrivate =
      _TWHDVersionIsPrivatePtr.asFunction<bool Function(int)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOIN');

  ffi.Pointer<ffi.Char> get HRP_BITCOIN => _HRP_BITCOIN.value;

  set HRP_BITCOIN(ffi.Pointer<ffi.Char> value) => _HRP_BITCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_LITECOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_LITECOIN');

  ffi.Pointer<ffi.Char> get HRP_LITECOIN => _HRP_LITECOIN.value;

  set HRP_LITECOIN(ffi.Pointer<ffi.Char> value) => _HRP_LITECOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_VIACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_VIACOIN');

  ffi.Pointer<ffi.Char> get HRP_VIACOIN => _HRP_VIACOIN.value;

  set HRP_VIACOIN(ffi.Pointer<ffi.Char> value) => _HRP_VIACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_GROESTLCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_GROESTLCOIN');

  ffi.Pointer<ffi.Char> get HRP_GROESTLCOIN => _HRP_GROESTLCOIN.value;

  set HRP_GROESTLCOIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_GROESTLCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_DIGIBYTE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_DIGIBYTE');

  ffi.Pointer<ffi.Char> get HRP_DIGIBYTE => _HRP_DIGIBYTE.value;

  set HRP_DIGIBYTE(ffi.Pointer<ffi.Char> value) => _HRP_DIGIBYTE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MONACOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MONACOIN');

  ffi.Pointer<ffi.Char> get HRP_MONACOIN => _HRP_MONACOIN.value;

  set HRP_MONACOIN(ffi.Pointer<ffi.Char> value) => _HRP_MONACOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SYSCOIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SYSCOIN');

  ffi.Pointer<ffi.Char> get HRP_SYSCOIN => _HRP_SYSCOIN.value;

  set HRP_SYSCOIN(ffi.Pointer<ffi.Char> value) => _HRP_SYSCOIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_VERGE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_VERGE');

  ffi.Pointer<ffi.Char> get HRP_VERGE => _HRP_VERGE.value;

  set HRP_VERGE(ffi.Pointer<ffi.Char> value) => _HRP_VERGE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COSMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COSMOS');

  ffi.Pointer<ffi.Char> get HRP_COSMOS => _HRP_COSMOS.value;

  set HRP_COSMOS(ffi.Pointer<ffi.Char> value) => _HRP_COSMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZCASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZCASH');

  ffi.Pointer<ffi.Char> get HRP_ZCASH => _HRP_ZCASH.value;

  set HRP_ZCASH(ffi.Pointer<ffi.Char> value) => _HRP_ZCASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINCASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINCASH');

  ffi.Pointer<ffi.Char> get HRP_BITCOINCASH => _HRP_BITCOINCASH.value;

  set HRP_BITCOINCASH(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINCASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINGOLD =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINGOLD');

  ffi.Pointer<ffi.Char> get HRP_BITCOINGOLD => _HRP_BITCOINGOLD.value;

  set HRP_BITCOINGOLD(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINGOLD.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_IOTEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_IOTEX');

  ffi.Pointer<ffi.Char> get HRP_IOTEX => _HRP_IOTEX.value;

  set HRP_IOTEX(ffi.Pointer<ffi.Char> value) => _HRP_IOTEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NERVOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NERVOS');

  ffi.Pointer<ffi.Char> get HRP_NERVOS => _HRP_NERVOS.value;

  set HRP_NERVOS(ffi.Pointer<ffi.Char> value) => _HRP_NERVOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZILLIQA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZILLIQA');

  ffi.Pointer<ffi.Char> get HRP_ZILLIQA => _HRP_ZILLIQA.value;

  set HRP_ZILLIQA(ffi.Pointer<ffi.Char> value) => _HRP_ZILLIQA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRA');

  ffi.Pointer<ffi.Char> get HRP_TERRA => _HRP_TERRA.value;

  set HRP_TERRA(ffi.Pointer<ffi.Char> value) => _HRP_TERRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRYPTOORG =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRYPTOORG');

  ffi.Pointer<ffi.Char> get HRP_CRYPTOORG => _HRP_CRYPTOORG.value;

  set HRP_CRYPTOORG(ffi.Pointer<ffi.Char> value) =>
      _HRP_CRYPTOORG.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KAVA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KAVA');

  ffi.Pointer<ffi.Char> get HRP_KAVA => _HRP_KAVA.value;

  set HRP_KAVA(ffi.Pointer<ffi.Char> value) => _HRP_KAVA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OASIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OASIS');

  ffi.Pointer<ffi.Char> get HRP_OASIS => _HRP_OASIS.value;

  set HRP_OASIS(ffi.Pointer<ffi.Char> value) => _HRP_OASIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BLUZELLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BLUZELLE');

  ffi.Pointer<ffi.Char> get HRP_BLUZELLE => _HRP_BLUZELLE.value;

  set HRP_BLUZELLE(ffi.Pointer<ffi.Char> value) => _HRP_BLUZELLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BAND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BAND');

  ffi.Pointer<ffi.Char> get HRP_BAND => _HRP_BAND.value;

  set HRP_BAND(ffi.Pointer<ffi.Char> value) => _HRP_BAND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ELROND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ELROND');

  ffi.Pointer<ffi.Char> get HRP_ELROND => _HRP_ELROND.value;

  set HRP_ELROND(ffi.Pointer<ffi.Char> value) => _HRP_ELROND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SECRET =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SECRET');

  ffi.Pointer<ffi.Char> get HRP_SECRET => _HRP_SECRET.value;

  set HRP_SECRET(ffi.Pointer<ffi.Char> value) => _HRP_SECRET.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AGORIC =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AGORIC');

  ffi.Pointer<ffi.Char> get HRP_AGORIC => _HRP_AGORIC.value;

  set HRP_AGORIC(ffi.Pointer<ffi.Char> value) => _HRP_AGORIC.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BINANCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BINANCE');

  ffi.Pointer<ffi.Char> get HRP_BINANCE => _HRP_BINANCE.value;

  set HRP_BINANCE(ffi.Pointer<ffi.Char> value) => _HRP_BINANCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ECASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ECASH');

  ffi.Pointer<ffi.Char> get HRP_ECASH => _HRP_ECASH.value;

  set HRP_ECASH(ffi.Pointer<ffi.Char> value) => _HRP_ECASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_THORCHAIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_THORCHAIN');

  ffi.Pointer<ffi.Char> get HRP_THORCHAIN => _HRP_THORCHAIN.value;

  set HRP_THORCHAIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_THORCHAIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_BITCOINDIAMOND =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_BITCOINDIAMOND');

  ffi.Pointer<ffi.Char> get HRP_BITCOINDIAMOND => _HRP_BITCOINDIAMOND.value;

  set HRP_BITCOINDIAMOND(ffi.Pointer<ffi.Char> value) =>
      _HRP_BITCOINDIAMOND.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_HARMONY =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_HARMONY');

  ffi.Pointer<ffi.Char> get HRP_HARMONY => _HRP_HARMONY.value;

  set HRP_HARMONY(ffi.Pointer<ffi.Char> value) => _HRP_HARMONY.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CARDANO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CARDANO');

  ffi.Pointer<ffi.Char> get HRP_CARDANO => _HRP_CARDANO.value;

  set HRP_CARDANO(ffi.Pointer<ffi.Char> value) => _HRP_CARDANO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QTUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QTUM');

  ffi.Pointer<ffi.Char> get HRP_QTUM => _HRP_QTUM.value;

  set HRP_QTUM(ffi.Pointer<ffi.Char> value) => _HRP_QTUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_PACTUS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_PACTUS');

  ffi.Pointer<ffi.Char> get HRP_PACTUS => _HRP_PACTUS.value;

  set HRP_PACTUS(ffi.Pointer<ffi.Char> value) => _HRP_PACTUS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STRATIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STRATIS');

  ffi.Pointer<ffi.Char> get HRP_STRATIS => _HRP_STRATIS.value;

  set HRP_STRATIS(ffi.Pointer<ffi.Char> value) => _HRP_STRATIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEINJECTIVE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEINJECTIVE');

  ffi.Pointer<ffi.Char> get HRP_NATIVEINJECTIVE => _HRP_NATIVEINJECTIVE.value;

  set HRP_NATIVEINJECTIVE(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEINJECTIVE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_OSMOSIS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_OSMOSIS');

  ffi.Pointer<ffi.Char> get HRP_OSMOSIS => _HRP_OSMOSIS.value;

  set HRP_OSMOSIS(ffi.Pointer<ffi.Char> value) => _HRP_OSMOSIS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TERRAV2 =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TERRAV2');

  ffi.Pointer<ffi.Char> get HRP_TERRAV2 => _HRP_TERRAV2.value;

  set HRP_TERRAV2(ffi.Pointer<ffi.Char> value) => _HRP_TERRAV2.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COREUM =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COREUM');

  ffi.Pointer<ffi.Char> get HRP_COREUM => _HRP_COREUM.value;

  set HRP_COREUM(ffi.Pointer<ffi.Char> value) => _HRP_COREUM.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_ZETACHAIN =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_ZETACHAIN');

  ffi.Pointer<ffi.Char> get HRP_ZETACHAIN => _HRP_ZETACHAIN.value;

  set HRP_ZETACHAIN(ffi.Pointer<ffi.Char> value) =>
      _HRP_ZETACHAIN.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVECANTO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVECANTO');

  ffi.Pointer<ffi.Char> get HRP_NATIVECANTO => _HRP_NATIVECANTO.value;

  set HRP_NATIVECANTO(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVECANTO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SOMMELIER =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SOMMELIER');

  ffi.Pointer<ffi.Char> get HRP_SOMMELIER => _HRP_SOMMELIER.value;

  set HRP_SOMMELIER(ffi.Pointer<ffi.Char> value) =>
      _HRP_SOMMELIER.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_FETCHAI =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_FETCHAI');

  ffi.Pointer<ffi.Char> get HRP_FETCHAI => _HRP_FETCHAI.value;

  set HRP_FETCHAI(ffi.Pointer<ffi.Char> value) => _HRP_FETCHAI.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_MARS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_MARS');

  ffi.Pointer<ffi.Char> get HRP_MARS => _HRP_MARS.value;

  set HRP_MARS(ffi.Pointer<ffi.Char> value) => _HRP_MARS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_UMEE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_UMEE');

  ffi.Pointer<ffi.Char> get HRP_UMEE => _HRP_UMEE.value;

  set HRP_UMEE(ffi.Pointer<ffi.Char> value) => _HRP_UMEE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_QUASAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_QUASAR');

  ffi.Pointer<ffi.Char> get HRP_QUASAR => _HRP_QUASAR.value;

  set HRP_QUASAR(ffi.Pointer<ffi.Char> value) => _HRP_QUASAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_PERSISTENCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_PERSISTENCE');

  ffi.Pointer<ffi.Char> get HRP_PERSISTENCE => _HRP_PERSISTENCE.value;

  set HRP_PERSISTENCE(ffi.Pointer<ffi.Char> value) =>
      _HRP_PERSISTENCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AKASH =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AKASH');

  ffi.Pointer<ffi.Char> get HRP_AKASH => _HRP_AKASH.value;

  set HRP_AKASH(ffi.Pointer<ffi.Char> value) => _HRP_AKASH.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NOBLE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NOBLE');

  ffi.Pointer<ffi.Char> get HRP_NOBLE => _HRP_NOBLE.value;

  set HRP_NOBLE(ffi.Pointer<ffi.Char> value) => _HRP_NOBLE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_SEI =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_SEI');

  ffi.Pointer<ffi.Char> get HRP_SEI => _HRP_SEI.value;

  set HRP_SEI(ffi.Pointer<ffi.Char> value) => _HRP_SEI.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STARGAZE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STARGAZE');

  ffi.Pointer<ffi.Char> get HRP_STARGAZE => _HRP_STARGAZE.value;

  set HRP_STARGAZE(ffi.Pointer<ffi.Char> value) => _HRP_STARGAZE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NATIVEEVMOS =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NATIVEEVMOS');

  ffi.Pointer<ffi.Char> get HRP_NATIVEEVMOS => _HRP_NATIVEEVMOS.value;

  set HRP_NATIVEEVMOS(ffi.Pointer<ffi.Char> value) =>
      _HRP_NATIVEEVMOS.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TIA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TIA');

  ffi.Pointer<ffi.Char> get HRP_TIA => _HRP_TIA.value;

  set HRP_TIA(ffi.Pointer<ffi.Char> value) => _HRP_TIA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_DYDX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_DYDX');

  ffi.Pointer<ffi.Char> get HRP_DYDX => _HRP_DYDX.value;

  set HRP_DYDX(ffi.Pointer<ffi.Char> value) => _HRP_DYDX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_JUNO =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_JUNO');

  ffi.Pointer<ffi.Char> get HRP_JUNO => _HRP_JUNO.value;

  set HRP_JUNO(ffi.Pointer<ffi.Char> value) => _HRP_JUNO.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_TBINANCE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_TBINANCE');

  ffi.Pointer<ffi.Char> get HRP_TBINANCE => _HRP_TBINANCE.value;

  set HRP_TBINANCE(ffi.Pointer<ffi.Char> value) => _HRP_TBINANCE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_STRIDE =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_STRIDE');

  ffi.Pointer<ffi.Char> get HRP_STRIDE => _HRP_STRIDE.value;

  set HRP_STRIDE(ffi.Pointer<ffi.Char> value) => _HRP_STRIDE.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_AXELAR =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_AXELAR');

  ffi.Pointer<ffi.Char> get HRP_AXELAR => _HRP_AXELAR.value;

  set HRP_AXELAR(ffi.Pointer<ffi.Char> value) => _HRP_AXELAR.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_CRESCENT =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_CRESCENT');

  ffi.Pointer<ffi.Char> get HRP_CRESCENT => _HRP_CRESCENT.value;

  set HRP_CRESCENT(ffi.Pointer<ffi.Char> value) => _HRP_CRESCENT.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_KUJIRA =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_KUJIRA');

  ffi.Pointer<ffi.Char> get HRP_KUJIRA => _HRP_KUJIRA.value;

  set HRP_KUJIRA(ffi.Pointer<ffi.Char> value) => _HRP_KUJIRA.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_COMDEX =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_COMDEX');

  ffi.Pointer<ffi.Char> get HRP_COMDEX => _HRP_COMDEX.value;

  set HRP_COMDEX(ffi.Pointer<ffi.Char> value) => _HRP_COMDEX.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _HRP_NEUTRON =
      _lookup<ffi.Pointer<ffi.Char>>('HRP_NEUTRON');

  ffi.Pointer<ffi.Char> get HRP_NEUTRON => _HRP_NEUTRON.value;

  set HRP_NEUTRON(ffi.Pointer<ffi.Char> value) => _HRP_NEUTRON.value = value;

  ffi.Pointer<ffi.Char> stringForHRP(
    int hrp,
  ) {
    return _stringForHRP(
      hrp,
    );
  }

  late final _stringForHRPPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<ffi.Char> Function(ffi.Int32)>>(
          'stringForHRP');
  late final _stringForHRP =
      _stringForHRPPtr.asFunction<ffi.Pointer<ffi.Char> Function(int)>();

  int hrpForString(
    ffi.Pointer<ffi.Char> string,
  ) {
    return _hrpForString(
      string,
    );
  }

  late final _hrpForStringPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>>(
          'hrpForString');
  late final _hrpForString =
      _hrpForStringPtr.asFunction<int Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a TWString from a null-terminated UTF8 byte array. It must be deleted at the end.
  ///
  /// \param bytes a null-terminated UTF8 byte array.
  ffi.Pointer<TWString> TWStringCreateWithUTF8Bytes(
    ffi.Pointer<ffi.Char> bytes,
  ) {
    return _TWStringCreateWithUTF8Bytes(
      bytes,
    );
  }

  late final _TWStringCreateWithUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<ffi.Char>)>>('TWStringCreateWithUTF8Bytes');
  late final _TWStringCreateWithUTF8Bytes = _TWStringCreateWithUTF8BytesPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<ffi.Char>)>();

  /// Creates a string from a raw byte array and size. It must be deleted at the end.
  ///
  /// \param bytes a raw byte array.
  /// \param size the size of the byte array.
  ffi.Pointer<TWString> TWStringCreateWithRawBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWStringCreateWithRawBytes(
      bytes,
      size,
    );
  }

  late final _TWStringCreateWithRawBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWStringCreateWithRawBytes');
  late final _TWStringCreateWithRawBytes =
      _TWStringCreateWithRawBytesPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates a hexadecimal string from a block of data. It must be deleted at the end.
  ///
  /// \param data a block of data.
  ffi.Pointer<TWString> TWStringCreateWithHexData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWStringCreateWithHexData(
      data,
    );
  }

  late final _TWStringCreateWithHexDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWStringCreateWithHexData');
  late final _TWStringCreateWithHexData = _TWStringCreateWithHexDataPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Returns the string size in bytes.
  ///
  /// \param string a TWString pointer.
  int TWStringSize(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringSize(
      string,
    );
  }

  late final _TWStringSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWString>)>>(
          'TWStringSize');
  late final _TWStringSize =
      _TWStringSizePtr.asFunction<int Function(ffi.Pointer<TWString>)>();

  /// Returns the byte at the provided index.
  ///
  /// \param string a TWString pointer.
  /// \param index the index of the byte.
  int TWStringGet(
    ffi.Pointer<TWString> string,
    int index,
  ) {
    return _TWStringGet(
      string,
      index,
    );
  }

  late final _TWStringGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Char Function(ffi.Pointer<TWString>, ffi.Size)>>('TWStringGet');
  late final _TWStringGet =
      _TWStringGetPtr.asFunction<int Function(ffi.Pointer<TWString>, int)>();

  /// Returns the raw pointer to the string's UTF8 bytes (null-terminated).
  ///
  /// \param string a TWString pointer.
  ffi.Pointer<ffi.Char> TWStringUTF8Bytes(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringUTF8Bytes(
      string,
    );
  }

  late final _TWStringUTF8BytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Char> Function(
              ffi.Pointer<TWString>)>>('TWStringUTF8Bytes');
  late final _TWStringUTF8Bytes = _TWStringUTF8BytesPtr.asFunction<
      ffi.Pointer<ffi.Char> Function(ffi.Pointer<TWString>)>();

  /// Deletes a string created with a `TWStringCreate*` method and frees the memory.
  ///
  /// \param string a TWString pointer.
  void TWStringDelete(
    ffi.Pointer<TWString> string,
  ) {
    return _TWStringDelete(
      string,
    );
  }

  late final _TWStringDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWString>)>>(
          'TWStringDelete');
  late final _TWStringDelete =
      _TWStringDeletePtr.asFunction<void Function(ffi.Pointer<TWString>)>();

  /// Determines whether two string blocks are equal.
  ///
  /// \param lhs a TWString pointer.
  /// \param rhs another TWString pointer.
  bool TWStringEqual(
    ffi.Pointer<TWString> lhs,
    ffi.Pointer<TWString> rhs,
  ) {
    return _TWStringEqual(
      lhs,
      rhs,
    );
  }

  late final _TWStringEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>>('TWStringEqual');
  late final _TWStringEqual = _TWStringEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Returns the blockchain for a coin type.
  ///
  /// \param coin A coin type
  /// \return blockchain associated to the given coin type
  int TWCoinTypeBlockchain(
    int coin,
  ) {
    return _TWCoinTypeBlockchain(
      coin,
    );
  }

  late final _TWCoinTypeBlockchainPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypeBlockchain');
  late final _TWCoinTypeBlockchain =
      _TWCoinTypeBlockchainPtr.asFunction<int Function(int)>();

  /// Returns the purpose for a coin type.
  ///
  /// \param coin A coin type
  /// \return purpose associated to the given coin type
  int TWCoinTypePurpose(
    int coin,
  ) {
    return _TWCoinTypePurpose(
      coin,
    );
  }

  late final _TWCoinTypePurposePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypePurpose');
  late final _TWCoinTypePurpose =
      _TWCoinTypePurposePtr.asFunction<int Function(int)>();

  /// Returns the curve that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return curve that should be used for the given coin type
  int TWCoinTypeCurve(
    int coin,
  ) {
    return _TWCoinTypeCurve(
      coin,
    );
  }

  late final _TWCoinTypeCurvePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypeCurve');
  late final _TWCoinTypeCurve =
      _TWCoinTypeCurvePtr.asFunction<int Function(int)>();

  /// Returns the xpub HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return xpub HD version that should be used for the given coin type
  int TWCoinTypeXpubVersion(
    int coin,
  ) {
    return _TWCoinTypeXpubVersion(
      coin,
    );
  }

  late final _TWCoinTypeXpubVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypeXpubVersion');
  late final _TWCoinTypeXpubVersion =
      _TWCoinTypeXpubVersionPtr.asFunction<int Function(int)>();

  /// Returns the xprv HD version that should be used for a coin type.
  ///
  /// \param coin A coin type
  /// \return the xprv HD version that should be used for the given coin type.
  int TWCoinTypeXprvVersion(
    int coin,
  ) {
    return _TWCoinTypeXprvVersion(
      coin,
    );
  }

  late final _TWCoinTypeXprvVersionPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypeXprvVersion');
  late final _TWCoinTypeXprvVersion =
      _TWCoinTypeXprvVersionPtr.asFunction<int Function(int)>();

  /// Validates an address string.
  ///
  /// \param coin A coin type
  /// \param address A public address
  /// \return true if the address is a valid public address of the given coin, false otherwise.
  bool TWCoinTypeValidate(
    int coin,
    ffi.Pointer<TWString> address,
  ) {
    return _TWCoinTypeValidate(
      coin,
      address,
    );
  }

  late final _TWCoinTypeValidatePtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Int32, ffi.Pointer<TWString>)>>(
      'TWCoinTypeValidate');
  late final _TWCoinTypeValidate = _TWCoinTypeValidatePtr.asFunction<
      bool Function(int, ffi.Pointer<TWString>)>();

  /// Returns the default derivation path for a particular coin.
  ///
  /// \param coin A coin type
  /// \return the default derivation path for the given coin type.
  ffi.Pointer<TWString> TWCoinTypeDerivationPath(
    int coin,
  ) {
    return _TWCoinTypeDerivationPath(
      coin,
    );
  }

  late final _TWCoinTypeDerivationPathPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.Int32)>>(
          'TWCoinTypeDerivationPath');
  late final _TWCoinTypeDerivationPath = _TWCoinTypeDerivationPathPtr
      .asFunction<ffi.Pointer<TWString> Function(int)>();

  /// Returns the derivation path for a particular coin with the explicit given derivation.
  ///
  /// \param coin A coin type
  /// \param derivation A derivation type
  /// \return the derivation path for the given coin with the explicit given derivation
  ffi.Pointer<TWString> TWCoinTypeDerivationPathWithDerivation(
    int coin,
    int derivation,
  ) {
    return _TWCoinTypeDerivationPathWithDerivation(
      coin,
      derivation,
    );
  }

  late final _TWCoinTypeDerivationPathWithDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Int32, ffi.Int32)>>('TWCoinTypeDerivationPathWithDerivation');
  late final _TWCoinTypeDerivationPathWithDerivation =
      _TWCoinTypeDerivationPathWithDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(int, int)>();

  /// Derives the address for a particular coin from the private key.
  ///
  /// \param coin A coin type
  /// \param privateKey A valid private key
  /// \return Derived address for the given coin from the private key.
  ffi.Pointer<TWString> TWCoinTypeDeriveAddress(
    int coin,
    ffi.Pointer<TWPrivateKey> privateKey,
  ) {
    return _TWCoinTypeDeriveAddress(
      coin,
      privateKey,
    );
  }

  late final _TWCoinTypeDeriveAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Int32,
              ffi.Pointer<TWPrivateKey>)>>('TWCoinTypeDeriveAddress');
  late final _TWCoinTypeDeriveAddress = _TWCoinTypeDeriveAddressPtr.asFunction<
      ffi.Pointer<TWString> Function(int, ffi.Pointer<TWPrivateKey>)>();

  /// Derives the address for a particular coin from the public key.
  ///
  /// \param coin A coin type
  /// \param publicKey A valid public key
  /// \return Derived address for the given coin from the public key.
  ffi.Pointer<TWString> TWCoinTypeDeriveAddressFromPublicKey(
    int coin,
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWCoinTypeDeriveAddressFromPublicKey(
      coin,
      publicKey,
    );
  }

  late final _TWCoinTypeDeriveAddressFromPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Int32, ffi.Pointer<TWPublicKey>)>>(
      'TWCoinTypeDeriveAddressFromPublicKey');
  late final _TWCoinTypeDeriveAddressFromPublicKey =
      _TWCoinTypeDeriveAddressFromPublicKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWPublicKey>)>();

  /// Derives the address for a particular coin from the public key with the derivation.
  ffi.Pointer<TWString> TWCoinTypeDeriveAddressFromPublicKeyAndDerivation(
    int coin,
    ffi.Pointer<TWPublicKey> publicKey,
    int derivation,
  ) {
    return _TWCoinTypeDeriveAddressFromPublicKeyAndDerivation(
      coin,
      publicKey,
      derivation,
    );
  }

  late final _TWCoinTypeDeriveAddressFromPublicKeyAndDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Int32, ffi.Pointer<TWPublicKey>,
              ffi.Int32)>>('TWCoinTypeDeriveAddressFromPublicKeyAndDerivation');
  late final _TWCoinTypeDeriveAddressFromPublicKeyAndDerivation =
      _TWCoinTypeDeriveAddressFromPublicKeyAndDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWPublicKey>, int)>();

  /// HRP for this coin type
  ///
  /// \param coin A coin type
  /// \return HRP of the given coin type.
  int TWCoinTypeHRP(
    int coin,
  ) {
    return _TWCoinTypeHRP(
      coin,
    );
  }

  late final _TWCoinTypeHRPPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypeHRP');
  late final _TWCoinTypeHRP = _TWCoinTypeHRPPtr.asFunction<int Function(int)>();

  /// P2PKH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2PKH prefix for the given coin type
  int TWCoinTypeP2pkhPrefix(
    int coin,
  ) {
    return _TWCoinTypeP2pkhPrefix(
      coin,
    );
  }

  late final _TWCoinTypeP2pkhPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int32)>>(
          'TWCoinTypeP2pkhPrefix');
  late final _TWCoinTypeP2pkhPrefix =
      _TWCoinTypeP2pkhPrefixPtr.asFunction<int Function(int)>();

  /// P2SH prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return P2SH prefix for the given coin type
  int TWCoinTypeP2shPrefix(
    int coin,
  ) {
    return _TWCoinTypeP2shPrefix(
      coin,
    );
  }

  late final _TWCoinTypeP2shPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int32)>>(
          'TWCoinTypeP2shPrefix');
  late final _TWCoinTypeP2shPrefix =
      _TWCoinTypeP2shPrefixPtr.asFunction<int Function(int)>();

  /// Static prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return Static prefix for the given coin type
  int TWCoinTypeStaticPrefix(
    int coin,
  ) {
    return _TWCoinTypeStaticPrefix(
      coin,
    );
  }

  late final _TWCoinTypeStaticPrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint8 Function(ffi.Int32)>>(
          'TWCoinTypeStaticPrefix');
  late final _TWCoinTypeStaticPrefix =
      _TWCoinTypeStaticPrefixPtr.asFunction<int Function(int)>();

  /// ChainID for this coin type.
  ///
  /// \param coin A coin type
  /// \return ChainID for the given coin type.
  /// \note Caller must free returned object.
  ffi.Pointer<TWString> TWCoinTypeChainId(
    int coin,
  ) {
    return _TWCoinTypeChainId(
      coin,
    );
  }

  late final _TWCoinTypeChainIdPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.Int32)>>(
          'TWCoinTypeChainId');
  late final _TWCoinTypeChainId =
      _TWCoinTypeChainIdPtr.asFunction<ffi.Pointer<TWString> Function(int)>();

  /// SLIP-0044 id for this coin type
  ///
  /// \param coin A coin type
  /// \return SLIP-0044 id for the given coin type
  int TWCoinTypeSlip44Id(
    int coin,
  ) {
    return _TWCoinTypeSlip44Id(
      coin,
    );
  }

  late final _TWCoinTypeSlip44IdPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Int32)>>(
          'TWCoinTypeSlip44Id');
  late final _TWCoinTypeSlip44Id =
      _TWCoinTypeSlip44IdPtr.asFunction<int Function(int)>();

  /// SS58Prefix for this coin type
  ///
  /// \param coin A coin type
  /// \return SS58Prefix for the given coin type
  int TWCoinTypeSS58Prefix(
    int coin,
  ) {
    return _TWCoinTypeSS58Prefix(
      coin,
    );
  }

  late final _TWCoinTypeSS58PrefixPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Int32)>>(
          'TWCoinTypeSS58Prefix');
  late final _TWCoinTypeSS58Prefix =
      _TWCoinTypeSS58PrefixPtr.asFunction<int Function(int)>();

  /// public key type for this coin type
  ///
  /// \param coin A coin type
  /// \return public key type for the given coin type
  int TWCoinTypePublicKeyType(
    int coin,
  ) {
    return _TWCoinTypePublicKeyType(
      coin,
    );
  }

  late final _TWCoinTypePublicKeyTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Int32)>>(
          'TWCoinTypePublicKeyType');
  late final _TWCoinTypePublicKeyType =
      _TWCoinTypePublicKeyTypePtr.asFunction<int Function(int)>();

  /// Returns stock symbol of coin
  ///
  /// \param type A coin type
  /// \return A non-null TWString stock symbol of coin
  /// \note Caller must free returned object
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetSymbol(
    int type,
  ) {
    return _TWCoinTypeConfigurationGetSymbol(
      type,
    );
  }

  late final _TWCoinTypeConfigurationGetSymbolPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.Int32)>>(
          'TWCoinTypeConfigurationGetSymbol');
  late final _TWCoinTypeConfigurationGetSymbol =
      _TWCoinTypeConfigurationGetSymbolPtr.asFunction<
          ffi.Pointer<TWString> Function(int)>();

  /// Returns max count decimal places for minimal coin unit
  ///
  /// \param type A coin type
  /// \return Returns max count decimal places for minimal coin unit
  int TWCoinTypeConfigurationGetDecimals(
    int type,
  ) {
    return _TWCoinTypeConfigurationGetDecimals(
      type,
    );
  }

  late final _TWCoinTypeConfigurationGetDecimalsPtr =
      _lookup<ffi.NativeFunction<ffi.Int Function(ffi.Int32)>>(
          'TWCoinTypeConfigurationGetDecimals');
  late final _TWCoinTypeConfigurationGetDecimals =
      _TWCoinTypeConfigurationGetDecimalsPtr.asFunction<int Function(int)>();

  /// Returns transaction url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param transactionID A transaction identifier
  /// \return Returns a non-null TWString transaction url in blockchain explorer
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetTransactionURL(
    int type,
    ffi.Pointer<TWString> transactionID,
  ) {
    return _TWCoinTypeConfigurationGetTransactionURL(
      type,
      transactionID,
    );
  }

  late final _TWCoinTypeConfigurationGetTransactionURLPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Int32, ffi.Pointer<TWString>)>>(
      'TWCoinTypeConfigurationGetTransactionURL');
  late final _TWCoinTypeConfigurationGetTransactionURL =
      _TWCoinTypeConfigurationGetTransactionURLPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWString>)>();

  /// Returns account url in blockchain explorer
  ///
  /// \param type A coin type
  /// \param accountID an Account identifier
  /// \return Returns a non-null TWString account url in blockchain explorer
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetAccountURL(
    int type,
    ffi.Pointer<TWString> accountID,
  ) {
    return _TWCoinTypeConfigurationGetAccountURL(
      type,
      accountID,
    );
  }

  late final _TWCoinTypeConfigurationGetAccountURLPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Int32,
              ffi.Pointer<TWString>)>>('TWCoinTypeConfigurationGetAccountURL');
  late final _TWCoinTypeConfigurationGetAccountURL =
      _TWCoinTypeConfigurationGetAccountURLPtr.asFunction<
          ffi.Pointer<TWString> Function(int, ffi.Pointer<TWString>)>();

  /// Returns full name of coin in lower case
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin in lower case
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetID(
    int type,
  ) {
    return _TWCoinTypeConfigurationGetID(
      type,
    );
  }

  late final _TWCoinTypeConfigurationGetIDPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.Int32)>>(
          'TWCoinTypeConfigurationGetID');
  late final _TWCoinTypeConfigurationGetID = _TWCoinTypeConfigurationGetIDPtr
      .asFunction<ffi.Pointer<TWString> Function(int)>();

  /// Returns full name of coin
  ///
  /// \param type A coin type
  /// \return Returns a non-null TWString, full name of coin
  ffi.Pointer<TWString> TWCoinTypeConfigurationGetName(
    int type,
  ) {
    return _TWCoinTypeConfigurationGetName(
      type,
    );
  }

  late final _TWCoinTypeConfigurationGetNamePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWString> Function(ffi.Int32)>>(
          'TWCoinTypeConfigurationGetName');
  late final _TWCoinTypeConfigurationGetName =
      _TWCoinTypeConfigurationGetNamePtr.asFunction<
          ffi.Pointer<TWString> Function(int)>();

  /// Creates a block of data from a byte array.
  ///
  /// \param bytes Non-null raw bytes buffer
  /// \param size size of the buffer
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataCreateWithBytes(
      bytes,
      size,
    );
  }

  late final _TWDataCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<ffi.Uint8>, ffi.Size)>>('TWDataCreateWithBytes');
  late final _TWDataCreateWithBytes = _TWDataCreateWithBytesPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates an uninitialized block of data with the provided size.
  ///
  /// \param size size for the block of data
  /// \return Non-null uninitialized block of data with the provided size
  ffi.Pointer<TWData> TWDataCreateWithSize(
    int size,
  ) {
    return _TWDataCreateWithSize(
      size,
    );
  }

  late final _TWDataCreateWithSizePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Size)>>(
          'TWDataCreateWithSize');
  late final _TWDataCreateWithSize =
      _TWDataCreateWithSizePtr.asFunction<ffi.Pointer<TWData> Function(int)>();

  /// Creates a block of data by copying another block of data.
  ///
  /// \param data buffer that need to be copied
  /// \return Non-null filled block of data.
  ffi.Pointer<TWData> TWDataCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataCreateWithData(
      data,
    );
  }

  late final _TWDataCreateWithDataPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWDataCreateWithData');
  late final _TWDataCreateWithData = _TWDataCreateWithDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Creates a block of data from a hexadecimal string.  Odd length is invalid (intended grouping to bytes is not obvious).
  ///
  /// \param hex input hex string
  /// \return Non-null filled block of data
  ffi.Pointer<TWData> TWDataCreateWithHexString(
    ffi.Pointer<TWString> hex,
  ) {
    return _TWDataCreateWithHexString(
      hex,
    );
  }

  late final _TWDataCreateWithHexStringPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWDataCreateWithHexString');
  late final _TWDataCreateWithHexString = _TWDataCreateWithHexStringPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Returns the size in bytes.
  ///
  /// \param data A non-null valid block of data
  /// \return the size of the given block of data
  int TWDataSize(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataSize(
      data,
    );
  }

  late final _TWDataSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWData>)>>(
          'TWDataSize');
  late final _TWDataSize =
      _TWDataSizePtr.asFunction<int Function(ffi.Pointer<TWData>)>();

  /// Returns the raw pointer to the contents of data.
  ///
  /// \param data A non-null valid block of data
  /// \return the raw pointer to the contents of data
  ffi.Pointer<ffi.Uint8> TWDataBytes(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataBytes(
      data,
    );
  }

  late final _TWDataBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>>('TWDataBytes');
  late final _TWDataBytes = _TWDataBytesPtr.asFunction<
      ffi.Pointer<ffi.Uint8> Function(ffi.Pointer<TWData>)>();

  /// Returns the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to fetch - index need to be < TWDataSize(data)
  /// \return the byte at the provided index
  int TWDataGet(
    ffi.Pointer<TWData> data,
    int index,
  ) {
    return _TWDataGet(
      data,
      index,
    );
  }

  late final _TWDataGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<TWData>, ffi.Size)>>('TWDataGet');
  late final _TWDataGet =
      _TWDataGetPtr.asFunction<int Function(ffi.Pointer<TWData>, int)>();

  /// Sets the byte at the provided index.
  ///
  /// \param data A non-null valid block of data
  /// \param index index of the byte that we want to set - index need to be < TWDataSize(data)
  /// \param byte Given byte to be written in data
  void TWDataSet(
    ffi.Pointer<TWData> data,
    int index,
    int byte,
  ) {
    return _TWDataSet(
      data,
      index,
      byte,
    );
  }

  late final _TWDataSetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Size, ffi.Uint8)>>('TWDataSet');
  late final _TWDataSet =
      _TWDataSetPtr.asFunction<void Function(ffi.Pointer<TWData>, int, int)>();

  /// Copies a range of bytes into the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to copy - size need to be < TWDataSize(data) - start
  /// \param output The output buffer where we want to copy the data.
  void TWDataCopyBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> output,
  ) {
    return _TWDataCopyBytes(
      data,
      start,
      size,
      output,
    );
  }

  late final _TWDataCopyBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataCopyBytes');
  late final _TWDataCopyBytes = _TWDataCopyBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Replaces a range of bytes with the contents of the provided buffer.
  ///
  /// \param data A non-null valid block of data
  /// \param start starting index of the range - index need to be < TWDataSize(data)
  /// \param size size of the range we want to replace - size need to be < TWDataSize(data) - start
  /// \param bytes The buffer that will replace the range of data
  void TWDataReplaceBytes(
    ffi.Pointer<TWData> data,
    int start,
    int size,
    ffi.Pointer<ffi.Uint8> bytes,
  ) {
    return _TWDataReplaceBytes(
      data,
      start,
      size,
      bytes,
    );
  }

  late final _TWDataReplaceBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Size, ffi.Size,
              ffi.Pointer<ffi.Uint8>)>>('TWDataReplaceBytes');
  late final _TWDataReplaceBytes = _TWDataReplaceBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, int, int, ffi.Pointer<ffi.Uint8>)>();

  /// Appends data from a byte array.
  ///
  /// \param data A non-null valid block of data
  /// \param bytes Non-null byte array
  /// \param size The size of the byte array
  void TWDataAppendBytes(
    ffi.Pointer<TWData> data,
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWDataAppendBytes(
      data,
      bytes,
      size,
    );
  }

  late final _TWDataAppendBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('TWDataAppendBytes');
  late final _TWDataAppendBytes = _TWDataAppendBytesPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<ffi.Uint8>, int)>();

  /// Appends a single byte.
  ///
  /// \param data A non-null valid block of data
  /// \param byte A single byte
  void TWDataAppendByte(
    ffi.Pointer<TWData> data,
    int byte,
  ) {
    return _TWDataAppendByte(
      data,
      byte,
    );
  }

  late final _TWDataAppendBytePtr = _lookup<
          ffi
          .NativeFunction<ffi.Void Function(ffi.Pointer<TWData>, ffi.Uint8)>>(
      'TWDataAppendByte');
  late final _TWDataAppendByte = _TWDataAppendBytePtr.asFunction<
      void Function(ffi.Pointer<TWData>, int)>();

  /// Appends a block of data.
  ///
  /// \param data A non-null valid block of data
  /// \param append A non-null valid block of data
  void TWDataAppendData(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWData> append,
  ) {
    return _TWDataAppendData(
      data,
      append,
    );
  }

  late final _TWDataAppendDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataAppendData');
  late final _TWDataAppendData = _TWDataAppendDataPtr.asFunction<
      void Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Reverse the bytes.
  ///
  /// \param data A non-null valid block of data
  void TWDataReverse(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReverse(
      data,
    );
  }

  late final _TWDataReversePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReverse');
  late final _TWDataReverse =
      _TWDataReversePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Sets all bytes to the given value.
  ///
  /// \param data A non-null valid block of data
  void TWDataReset(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataReset(
      data,
    );
  }

  late final _TWDataResetPtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataReset');
  late final _TWDataReset =
      _TWDataResetPtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Deletes a block of data created with a `TWDataCreate*` method.
  ///
  /// \param data A non-null valid block of data
  void TWDataDelete(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataDelete(
      data,
    );
  }

  late final _TWDataDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWData>)>>(
          'TWDataDelete');
  late final _TWDataDelete =
      _TWDataDeletePtr.asFunction<void Function(ffi.Pointer<TWData>)>();

  /// Determines whether two data blocks are equal.
  ///
  /// \param lhs left non null block of data to be compared
  /// \param rhs right non null block of data to be compared
  /// \return true if both block of data are equal, false otherwise
  bool TWDataEqual(
    ffi.Pointer<TWData> lhs,
    ffi.Pointer<TWData> rhs,
  ) {
    return _TWDataEqual(
      lhs,
      rhs,
    );
  }

  late final _TWDataEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWDataEqual');
  late final _TWDataEqual = _TWDataEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Creates a new DerivationPath with a purpose, coin, account, change and address.
  /// Must be deleted with TWDerivationPathDelete after use.
  ///
  /// \param purpose The purpose of the Path.
  /// \param coin The coin type of the Path.
  /// \param account The derivation of the Path.
  /// \param change The derivation path of the Path.
  /// \param address hex encoded public key.
  /// \return A new DerivationPath.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreate(
    int purpose,
    int coin,
    int account,
    int change,
    int address,
  ) {
    return _TWDerivationPathCreate(
      purpose,
      coin,
      account,
      change,
      address,
    );
  }

  late final _TWDerivationPathCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.Int32, ffi.Uint32,
              ffi.Uint32, ffi.Uint32, ffi.Uint32)>>('TWDerivationPathCreate');
  late final _TWDerivationPathCreate = _TWDerivationPathCreatePtr.asFunction<
      ffi.Pointer<TWDerivationPath> Function(int, int, int, int, int)>();

  /// Creates a new DerivationPath with a string
  ///
  /// \param string The string of the Path.
  /// \return A new DerivationPath or null if string is invalid.
  ffi.Pointer<TWDerivationPath> TWDerivationPathCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWDerivationPathCreateWithString(
      string,
    );
  }

  late final _TWDerivationPathCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPath> Function(
              ffi.Pointer<TWString>)>>('TWDerivationPathCreateWithString');
  late final _TWDerivationPathCreateWithString =
      _TWDerivationPathCreateWithStringPtr.asFunction<
          ffi.Pointer<TWDerivationPath> Function(ffi.Pointer<TWString>)>();

  /// Deletes a DerivationPath.
  ///
  /// \param path DerivationPath to delete.
  void TWDerivationPathDelete(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDelete(
      path,
    );
  }

  late final _TWDerivationPathDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathDelete');
  late final _TWDerivationPathDelete = _TWDerivationPathDeletePtr.asFunction<
      void Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the index component of a DerivationPath.
  ///
  /// \param path DerivationPath to get the index of.
  /// \param index The index component of the DerivationPath.
  /// \return DerivationPathIndex or null if index is invalid.
  ffi.Pointer<TWDerivationPathIndex> TWDerivationPathIndexAt(
    ffi.Pointer<TWDerivationPath> path,
    int index,
  ) {
    return _TWDerivationPathIndexAt(
      path,
      index,
    );
  }

  late final _TWDerivationPathIndexAtPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPathIndex> Function(
              ffi.Pointer<TWDerivationPath>,
              ffi.Uint32)>>('TWDerivationPathIndexAt');
  late final _TWDerivationPathIndexAt = _TWDerivationPathIndexAtPtr.asFunction<
      ffi.Pointer<TWDerivationPathIndex> Function(
          ffi.Pointer<TWDerivationPath>, int)>();

  /// Returns the indices count of a DerivationPath.
  ///
  /// \param path DerivationPath to get the indices count of.
  /// \return The indices count of the DerivationPath.
  int TWDerivationPathIndicesCount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathIndicesCount(
      path,
    );
  }

  late final _TWDerivationPathIndicesCountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathIndicesCount');
  late final _TWDerivationPathIndicesCount = _TWDerivationPathIndicesCountPtr
      .asFunction<int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the purpose enum of a DerivationPath.
  ///
  /// \param path DerivationPath to get the purpose of.
  /// \return DerivationPathPurpose.
  int TWDerivationPathPurpose(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathPurpose(
      path,
    );
  }

  late final _TWDerivationPathPurposePtr = _lookup<
          ffi
          .NativeFunction<ffi.Int32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathPurpose');
  late final _TWDerivationPathPurpose = _TWDerivationPathPurposePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the coin value of a derivation path.
  ///
  /// \param path DerivationPath to get the coin of.
  /// \return The coin part of the DerivationPath.
  int TWDerivationPathCoin(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathCoin(
      path,
    );
  }

  late final _TWDerivationPathCoinPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathCoin');
  late final _TWDerivationPathCoin = _TWDerivationPathCoinPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the account value of a derivation path.
  ///
  /// \param path DerivationPath to get the account of.
  /// \return the account part of a derivation path.
  int TWDerivationPathAccount(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAccount(
      path,
    );
  }

  late final _TWDerivationPathAccountPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAccount');
  late final _TWDerivationPathAccount = _TWDerivationPathAccountPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the change value of a derivation path.
  ///
  /// \param path DerivationPath to get the change of.
  /// \return The change part of a derivation path.
  int TWDerivationPathChange(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathChange(
      path,
    );
  }

  late final _TWDerivationPathChangePtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathChange');
  late final _TWDerivationPathChange = _TWDerivationPathChangePtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the address value of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The address part of the derivation path.
  int TWDerivationPathAddress(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathAddress(
      path,
    );
  }

  late final _TWDerivationPathAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint32 Function(ffi.Pointer<TWDerivationPath>)>>(
      'TWDerivationPathAddress');
  late final _TWDerivationPathAddress = _TWDerivationPathAddressPtr.asFunction<
      int Function(ffi.Pointer<TWDerivationPath>)>();

  /// Returns the string description of a derivation path.
  ///
  /// \param path DerivationPath to get the address of.
  /// \return The string description of the derivation path.
  ffi.Pointer<TWString> TWDerivationPathDescription(
    ffi.Pointer<TWDerivationPath> path,
  ) {
    return _TWDerivationPathDescription(
      path,
    );
  }

  late final _TWDerivationPathDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWDerivationPath>)>>('TWDerivationPathDescription');
  late final _TWDerivationPathDescription =
      _TWDerivationPathDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWDerivationPath>)>();

  late final ffi.Pointer<ffi.Size> _TWPublicKeyCompressedSize =
      _lookup<ffi.Size>('TWPublicKeyCompressedSize');

  int get TWPublicKeyCompressedSize => _TWPublicKeyCompressedSize.value;

  late final ffi.Pointer<ffi.Size> _TWPublicKeyUncompressedSize =
      _lookup<ffi.Size>('TWPublicKeyUncompressedSize');

  int get TWPublicKeyUncompressedSize => _TWPublicKeyUncompressedSize.value;

  /// Create a public key from a block of data
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \note Should be deleted with \TWPublicKeyDelete
  /// \return Nullable pointer to the public key
  ffi.Pointer<TWPublicKey> TWPublicKeyCreateWithData(
    ffi.Pointer<TWData> data,
    int type,
  ) {
    return _TWPublicKeyCreateWithData(
      data,
      type,
    );
  }

  late final _TWPublicKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWData>, ffi.Int32)>>('TWPublicKeyCreateWithData');
  late final _TWPublicKeyCreateWithData =
      _TWPublicKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData>, int)>();

  /// Delete the given public key
  ///
  /// \param pk Non-null pointer to a public key
  void TWPublicKeyDelete(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyDelete(
      pk,
    );
  }

  late final _TWPublicKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyDelete');
  late final _TWPublicKeyDelete = _TWPublicKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPublicKey>)>();

  /// Determines if the given public key is valid or not
  ///
  /// \param data Non-null block of data representing the public key
  /// \param type type of the public key
  /// \return true if the block of data is a valid public key, false otherwise
  bool TWPublicKeyIsValid(
    ffi.Pointer<TWData> data,
    int type,
  ) {
    return _TWPublicKeyIsValid(
      data,
      type,
    );
  }

  late final _TWPublicKeyIsValidPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<TWData>, ffi.Int32)>>(
      'TWPublicKeyIsValid');
  late final _TWPublicKeyIsValid = _TWPublicKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, int)>();

  /// Determines if the given public key is compressed or not
  ///
  /// \param pk Non-null pointer to a public key
  /// \return true if the public key is compressed, false otherwise
  bool TWPublicKeyIsCompressed(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyIsCompressed(
      pk,
    );
  }

  late final _TWPublicKeyIsCompressedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyIsCompressed');
  late final _TWPublicKeyIsCompressed = _TWPublicKeyIsCompressedPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the compressed public key of the given non-compressed public key
  ///
  /// \param from Non-null pointer to a non-compressed public key
  /// \return Non-null pointer to the corresponding compressed public-key
  ffi.Pointer<TWPublicKey> TWPublicKeyCompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyCompressed(
      from,
    );
  }

  late final _TWPublicKeyCompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyCompressed');
  late final _TWPublicKeyCompressed = _TWPublicKeyCompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Give the non-compressed public key of a corresponding compressed public key
  ///
  /// \param from Non-null pointer to the corresponding compressed public key
  /// \return Non-null pointer to the corresponding non-compressed public key
  ffi.Pointer<TWPublicKey> TWPublicKeyUncompressed(
    ffi.Pointer<TWPublicKey> from,
  ) {
    return _TWPublicKeyUncompressed(
      from,
    );
  }

  late final _TWPublicKeyUncompressedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyUncompressed');
  late final _TWPublicKeyUncompressed = _TWPublicKeyUncompressedPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPublicKey>)>();

  /// Gives the raw data of a given public-key
  ///
  /// \param pk Non-null pointer to a public key
  /// \return Non-null pointer to the raw block of data of the given public key
  ffi.Pointer<TWData> TWPublicKeyData(
    ffi.Pointer<TWPublicKey> pk,
  ) {
    return _TWPublicKeyData(
      pk,
    );
  }

  late final _TWPublicKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyData');
  late final _TWPublicKeyData = _TWPublicKeyDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWPublicKey>)>();

  /// Verify the validity of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerify(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData> signature,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPublicKeyVerify(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWPublicKeyVerify');
  late final _TWPublicKeyVerify = _TWPublicKeyVerifyPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
          ffi.Pointer<TWData>)>();

  /// Verify the validity as DER of a signature and a message using the given public key
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyAsDER(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData> signature,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPublicKeyVerifyAsDER(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWPublicKeyVerifyAsDER');
  late final _TWPublicKeyVerifyAsDER = _TWPublicKeyVerifyAsDERPtr.asFunction<
      bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
          ffi.Pointer<TWData>)>();

  /// Verify a Zilliqa schnorr signature with a signature and message.
  ///
  /// \param pk Non-null pointer to a public key
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return true if the signature and the message belongs to the given public key, false otherwise
  bool TWPublicKeyVerifyZilliqaSchnorr(
    ffi.Pointer<TWPublicKey> pk,
    ffi.Pointer<TWData> signature,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPublicKeyVerifyZilliqaSchnorr(
      pk,
      signature,
      message,
    );
  }

  late final _TWPublicKeyVerifyZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWPublicKeyVerifyZilliqaSchnorr');
  late final _TWPublicKeyVerifyZilliqaSchnorr =
      _TWPublicKeyVerifyZilliqaSchnorrPtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>();

  /// Give the public key type (eliptic) of a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return The public key type of the given public key (eliptic)
  int TWPublicKeyKeyType(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWPublicKeyKeyType(
      publicKey,
    );
  }

  late final _TWPublicKeyKeyTypePtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<TWPublicKey>)>>(
          'TWPublicKeyKeyType');
  late final _TWPublicKeyKeyType = _TWPublicKeyKeyTypePtr.asFunction<
      int Function(ffi.Pointer<TWPublicKey>)>();

  /// Get the public key description from a given public key
  ///
  /// \param publicKey Non-null pointer to a public key
  /// \return Non-null pointer to a string representing the description of the public key
  ffi.Pointer<TWString> TWPublicKeyDescription(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWPublicKeyDescription(
      publicKey,
    );
  }

  late final _TWPublicKeyDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWPublicKey>)>>('TWPublicKeyDescription');
  late final _TWPublicKeyDescription = _TWPublicKeyDescriptionPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWPublicKey>)>();

  /// Try to get a public key from a given signature and a message
  ///
  /// \param signature Non-null pointer to a block of data corresponding to the signature
  /// \param message Non-null pointer to a block of data corresponding to the message
  /// \return Null pointer if the public key can't be recover from the given signature and message,
  /// pointer to the public key otherwise
  ffi.Pointer<TWPublicKey> TWPublicKeyRecover(
    ffi.Pointer<TWData> signature,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPublicKeyRecover(
      signature,
      message,
    );
  }

  late final _TWPublicKeyRecoverPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>>('TWPublicKeyRecover');
  late final _TWPublicKeyRecover = _TWPublicKeyRecoverPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  late final ffi.Pointer<ffi.Size> _TWPrivateKeySize =
      _lookup<ffi.Size>('TWPrivateKeySize');

  int get TWPrivateKeySize => _TWPrivateKeySize.value;

  /// Create a random private key
  ///
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Non-null Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreate() {
    return _TWPrivateKeyCreate();
  }

  late final _TWPrivateKeyCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWPrivateKey> Function()>>(
          'TWPrivateKeyCreate');
  late final _TWPrivateKeyCreate =
      _TWPrivateKeyCreatePtr.asFunction<ffi.Pointer<TWPrivateKey> Function()>();

  /// Create a private key with the given block of data
  ///
  /// \param data a block of data
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Nullable pointer to Private Key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWPrivateKeyCreateWithData(
      data,
    );
  }

  late final _TWPrivateKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWData>)>>('TWPrivateKeyCreateWithData');
  late final _TWPrivateKeyCreateWithData = _TWPrivateKeyCreateWithDataPtr
      .asFunction<ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWData>)>();

  /// Deep copy a given private key
  ///
  /// \param key Non-null private key to be copied
  /// \note Should be deleted with \TWPrivateKeyDelete
  /// \return Deep copy, Nullable pointer to Private key
  ffi.Pointer<TWPrivateKey> TWPrivateKeyCreateCopy(
    ffi.Pointer<TWPrivateKey> key,
  ) {
    return _TWPrivateKeyCreateCopy(
      key,
    );
  }

  late final _TWPrivateKeyCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyCreateCopy');
  late final _TWPrivateKeyCreateCopy = _TWPrivateKeyCreateCopyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Delete the given private key
  ///
  /// \param pk Non-null pointer to private key
  void TWPrivateKeyDelete(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyDelete(
      pk,
    );
  }

  late final _TWPrivateKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWPrivateKey>)>>(
          'TWPrivateKeyDelete');
  late final _TWPrivateKeyDelete = _TWPrivateKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWPrivateKey>)>();

  /// Determines if the given private key is valid or not.
  ///
  /// \param data block of data (private key bytes)
  /// \param curve Eliptic curve of the private key
  /// \return true if the private key is valid, false otherwise
  bool TWPrivateKeyIsValid(
    ffi.Pointer<TWData> data,
    int curve,
  ) {
    return _TWPrivateKeyIsValid(
      data,
      curve,
    );
  }

  late final _TWPrivateKeyIsValidPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<TWData>, ffi.Int32)>>(
      'TWPrivateKeyIsValid');
  late final _TWPrivateKeyIsValid = _TWPrivateKeyIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData>, int)>();

  /// Convert the given private key to raw-bytes block of data
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null block of data (raw bytes) of the given private key
  ffi.Pointer<TWData> TWPrivateKeyData(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyData(
      pk,
    );
  }

  late final _TWPrivateKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyData');
  late final _TWPrivateKeyData = _TWPrivateKeyDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the public key associated with the given coinType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param coinType coinType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKey(
    ffi.Pointer<TWPrivateKey> pk,
    int coinType,
  ) {
    return _TWPrivateKeyGetPublicKey(
      pk,
      coinType,
    );
  }

  late final _TWPrivateKeyGetPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Int32)>>('TWPrivateKeyGetPublicKey');
  late final _TWPrivateKeyGetPublicKey =
      _TWPrivateKeyGetPublicKeyPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the public key associated with the given pubkeyType and privateKey
  ///
  /// \param pk Non-null pointer to the private key
  /// \param pubkeyType pubkeyType of the given private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyByType(
    ffi.Pointer<TWPrivateKey> pk,
    int pubkeyType,
  ) {
    return _TWPrivateKeyGetPublicKeyByType(
      pk,
      pubkeyType,
    );
  }

  late final _TWPrivateKeyGetPublicKeyByTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Int32)>>('TWPrivateKeyGetPublicKeyByType');
  late final _TWPrivateKeyGetPublicKeyByType =
      _TWPrivateKeyGetPublicKeyByTypePtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, int)>();

  /// Returns the Secp256k1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \param compressed if the given private key is compressed or not
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeySecp256k1(
    ffi.Pointer<TWPrivateKey> pk,
    bool compressed,
  ) {
    return _TWPrivateKeyGetPublicKeySecp256k1(
      pk,
      compressed,
    );
  }

  late final _TWPrivateKeyGetPublicKeySecp256k1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Bool)>>('TWPrivateKeyGetPublicKeySecp256k1');
  late final _TWPrivateKeyGetPublicKeySecp256k1 =
      _TWPrivateKeyGetPublicKeySecp256k1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>, bool)>();

  /// Returns the Nist256p1 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyNist256p1(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyNist256p1(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyNist256p1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyNist256p1');
  late final _TWPrivateKeyGetPublicKeyNist256p1 =
      _TWPrivateKeyGetPublicKeyNist256p1Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWPrivateKey>)>>('TWPrivateKeyGetPublicKeyEd25519');
  late final _TWPrivateKeyGetPublicKeyEd25519 =
      _TWPrivateKeyGetPublicKeyEd25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Blake2b public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Blake2b(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Blake2b(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Blake2b');
  late final _TWPrivateKeyGetPublicKeyEd25519Blake2b =
      _TWPrivateKeyGetPublicKeyEd25519Blake2bPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Ed25519Cardano public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyEd25519Cardano(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyEd25519Cardano(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyEd25519CardanoPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyEd25519Cardano');
  late final _TWPrivateKeyGetPublicKeyEd25519Cardano =
      _TWPrivateKeyGetPublicKeyEd25519CardanoPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Returns the Curve25519 public key associated with the given private key
  ///
  /// \param pk Non-null pointer to the private key
  /// \return Non-null pointer to the corresponding public key
  ffi.Pointer<TWPublicKey> TWPrivateKeyGetPublicKeyCurve25519(
    ffi.Pointer<TWPrivateKey> pk,
  ) {
    return _TWPrivateKeyGetPublicKeyCurve25519(
      pk,
    );
  }

  late final _TWPrivateKeyGetPublicKeyCurve25519Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>>(
      'TWPrivateKeyGetPublicKeyCurve25519');
  late final _TWPrivateKeyGetPublicKeyCurve25519 =
      _TWPrivateKeyGetPublicKeyCurve25519Ptr.asFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWPrivateKey>)>();

  /// Signs a digest using ECDSA and given curve.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \param curve Eliptic curve
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySign(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> digest,
    int curve,
  ) {
    return _TWPrivateKeySign(
      pk,
      digest,
      curve,
    );
  }

  late final _TWPrivateKeySignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>, ffi.Int32)>>('TWPrivateKeySign');
  late final _TWPrivateKeySign = _TWPrivateKeySignPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>, int)>();

  /// Signs a digest using ECDSA. The result is encoded with DER.
  ///
  /// \param pk  Non-null pointer to a Private key
  /// \param digest Non-null digest block of data
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySignAsDER(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> digest,
  ) {
    return _TWPrivateKeySignAsDER(
      pk,
      digest,
    );
  }

  late final _TWPrivateKeySignAsDERPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>)>>('TWPrivateKeySignAsDER');
  late final _TWPrivateKeySignAsDER = _TWPrivateKeySignAsDERPtr.asFunction<
      ffi.Pointer<TWData> Function(
          ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>)>();

  /// Signs a digest using ECDSA and Zilliqa schnorr signature scheme.
  ///
  /// \param pk Non-null pointer to a Private key
  /// \param message Non-null message
  /// \return Signature as a Non-null block of data
  ffi.Pointer<TWData> TWPrivateKeySignZilliqaSchnorr(
    ffi.Pointer<TWPrivateKey> pk,
    ffi.Pointer<TWData> message,
  ) {
    return _TWPrivateKeySignZilliqaSchnorr(
      pk,
      message,
    );
  }

  late final _TWPrivateKeySignZilliqaSchnorrPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWData>)>>('TWPrivateKeySignZilliqaSchnorr');
  late final _TWPrivateKeySignZilliqaSchnorr =
      _TWPrivateKeySignZilliqaSchnorrPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWData>)>();

  /// Creates a new HDWallet with a new random mnemonic with the provided strength in bits.
  ///
  /// \param strength strength in bits
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid strength
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreate(
    int strength,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreate(
      strength,
      passphrase,
    );
  }

  late final _TWHDWalletCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Int, ffi.Pointer<TWString>)>>('TWHDWalletCreate');
  late final _TWHDWalletCreate = _TWHDWalletCreatePtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(int, ffi.Pointer<TWString>)>();

  /// Creates an HDWallet from a valid BIP39 English mnemonic and a passphrase.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonic(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreateWithMnemonic(
      mnemonic,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWHDWalletCreateWithMnemonic');
  late final _TWHDWalletCreateWithMnemonic =
      _TWHDWalletCreateWithMnemonicPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Creates an HDWallet from a BIP39 mnemonic, a passphrase and validation flag.
  ///
  /// \param mnemonic non-null Valid BIP39 mnemonic
  /// \param passphrase  non-null passphrase
  /// \param check validation flag
  /// \note Null is returned on invalid mnemonic
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithMnemonicCheck(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> passphrase,
    bool check,
  ) {
    return _TWHDWalletCreateWithMnemonicCheck(
      mnemonic,
      passphrase,
      check,
    );
  }

  late final _TWHDWalletCreateWithMnemonicCheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Bool)>>('TWHDWalletCreateWithMnemonicCheck');
  late final _TWHDWalletCreateWithMnemonicCheck =
      _TWHDWalletCreateWithMnemonicCheckPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>, bool)>();

  /// Creates an HDWallet from entropy (corresponding to a mnemonic).
  ///
  /// \param entropy Non-null entropy data (corresponding to a mnemonic)
  /// \param passphrase non-null passphrase
  /// \note Null is returned on invalid input
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Nullable TWHDWallet
  ffi.Pointer<TWHDWallet> TWHDWalletCreateWithEntropy(
    ffi.Pointer<TWData> entropy,
    ffi.Pointer<TWString> passphrase,
  ) {
    return _TWHDWalletCreateWithEntropy(
      entropy,
      passphrase,
    );
  }

  late final _TWHDWalletCreateWithEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWHDWalletCreateWithEntropy');
  late final _TWHDWalletCreateWithEntropy =
      _TWHDWalletCreateWithEntropyPtr.asFunction<
          ffi.Pointer<TWHDWallet> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Deletes a wallet.
  ///
  /// \param wallet non-null TWHDWallet
  void TWHDWalletDelete(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletDelete(
      wallet,
    );
  }

  late final _TWHDWalletDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWHDWallet>)>>(
          'TWHDWalletDelete');
  late final _TWHDWalletDelete =
      _TWHDWalletDeletePtr.asFunction<void Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet seed.
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet seed as a Non-null block of data.
  ffi.Pointer<TWData> TWHDWalletSeed(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletSeed(
      wallet,
    );
  }

  late final _TWHDWalletSeedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletSeed');
  late final _TWHDWalletSeed = _TWHDWalletSeedPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet Mnemonic
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet mnemonic as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletMnemonic(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletMnemonic(
      wallet,
    );
  }

  late final _TWHDWalletMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletMnemonic');
  late final _TWHDWalletMnemonic = _TWHDWalletMnemonicPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>)>();

  /// Wallet entropy
  ///
  /// \param wallet non-null TWHDWallet
  /// \return The wallet entropy as a non-null block of data.
  ffi.Pointer<TWData> TWHDWalletEntropy(
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWHDWalletEntropy(
      wallet,
    );
  }

  late final _TWHDWalletEntropyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWHDWallet>)>>('TWHDWalletEntropy');
  late final _TWHDWalletEntropy = _TWHDWalletEntropyPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWHDWallet>)>();

  /// Returns master key.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve  a curve
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Non-null corresponding private key
  ffi.Pointer<TWPrivateKey> TWHDWalletGetMasterKey(
    ffi.Pointer<TWHDWallet> wallet,
    int curve,
  ) {
    return _TWHDWalletGetMasterKey(
      wallet,
      curve,
    );
  }

  late final _TWHDWalletGetMasterKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>, ffi.Int32)>>('TWHDWalletGetMasterKey');
  late final _TWHDWalletGetMasterKey = _TWHDWalletGetMasterKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default private key for the specified coin, using default derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return return the default private key for the specified coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
  ) {
    return _TWHDWalletGetKeyForCoin(
      wallet,
      coin,
    );
  }

  late final _TWHDWalletGetKeyForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>, ffi.Int32)>>('TWHDWalletGetKeyForCoin');
  late final _TWHDWalletGetKeyForCoin = _TWHDWalletGetKeyForCoinPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin (without exposing intermediary private key), default derivation.
  ///
  /// \see TWHDWalletGetAddressDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetAddressForCoin(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
  ) {
    return _TWHDWalletGetAddressForCoin(
      wallet,
      coin,
    );
  }

  late final _TWHDWalletGetAddressForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>,
              ffi.Int32)>>('TWHDWalletGetAddressForCoin');
  late final _TWHDWalletGetAddressForCoin =
      _TWHDWalletGetAddressForCoinPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, int)>();

  /// Generates the default address for the specified coin and derivation (without exposing intermediary private key).
  ///
  /// \see TWHDWalletGetAddressForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin  a coin type
  /// \param derivation  a (custom) derivation to use
  /// \return return the default address for the specified coin as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetAddressDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
    int derivation,
  ) {
    return _TWHDWalletGetAddressDerivation(
      wallet,
      coin,
      derivation,
    );
  }

  late final _TWHDWalletGetAddressDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Int32)>>('TWHDWalletGetAddressDerivation');
  late final _TWHDWalletGetAddressDerivation =
      _TWHDWalletGetAddressDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path.
  ///
  /// \see TWHDWalletGetKeyForCoin
  /// \see TWHDWalletGetKeyDerivation
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKey(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetKey(
      wallet,
      coin,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWHDWalletGetKey');
  late final _TWHDWalletGetKey = _TWHDWalletGetKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString>)>();

  /// Generates the private key for the specified derivation.
  ///
  /// \see TWHDWalletGetKey
  /// \see TWHDWalletGetKeyForCoin
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param derivation a (custom) derivation to use
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/coin
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
    int derivation,
  ) {
    return _TWHDWalletGetKeyDerivation(
      wallet,
      coin,
      derivation,
    );
  }

  late final _TWHDWalletGetKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Int32)>>('TWHDWalletGetKeyDerivation');
  late final _TWHDWalletGetKeyDerivation =
      _TWHDWalletGetKeyDerivationPtr.asFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWHDWallet>, int, int)>();

  /// Generates the private key for the specified derivation path and curve.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param curve a curve
  /// \param derivationPath  a non-null derivation path
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified derivation path/curve
  ffi.Pointer<TWPrivateKey> TWHDWalletGetKeyByCurve(
    ffi.Pointer<TWHDWallet> wallet,
    int curve,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetKeyByCurve(
      wallet,
      curve,
      derivationPath,
    );
  }

  late final _TWHDWalletGetKeyByCurvePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWHDWalletGetKeyByCurve');
  late final _TWHDWalletGetKeyByCurve = _TWHDWalletGetKeyByCurvePtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, ffi.Pointer<TWString>)>();

  /// Shortcut method to generate private key with the specified account/change/address (bip44 standard).
  ///
  /// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
  ///
  /// \param wallet non-null TWHDWallet
  /// \param coin a coin type
  /// \param account valid bip44 account
  /// \param change valid bip44 change
  /// \param address valid bip44 address
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return The private key for the specified bip44 parameters
  ffi.Pointer<TWPrivateKey> TWHDWalletGetDerivedKey(
    ffi.Pointer<TWHDWallet> wallet,
    int coin,
    int account,
    int change,
    int address,
  ) {
    return _TWHDWalletGetDerivedKey(
      wallet,
      coin,
      account,
      change,
      address,
    );
  }

  late final _TWHDWalletGetDerivedKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Uint32, ffi.Uint32, ffi.Uint32)>>('TWHDWalletGetDerivedKey');
  late final _TWHDWalletGetDerivedKey = _TWHDWalletGetDerivedKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKey(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int version,
  ) {
    return _TWHDWalletGetExtendedPrivateKey(
      wallet,
      purpose,
      coin,
      version,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('TWHDWalletGetExtendedPrivateKey');
  late final _TWHDWalletGetExtendedPrivateKey =
      _TWHDWalletGetExtendedPrivateKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended public key (for default 0 account).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param version hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKey(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int version,
  ) {
    return _TWHDWalletGetExtendedPublicKey(
      wallet,
      purpose,
      coin,
      version,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWHDWallet>, ffi.Int32,
              ffi.Int32, ffi.Int32)>>('TWHDWalletGetExtendedPublicKey');
  late final _TWHDWalletGetExtendedPublicKey =
      _TWHDWalletGetExtendedPublicKeyPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int)>();

  /// Returns the extended private key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int derivation,
    int version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyAccount(
      wallet,
      purpose,
      coin,
      derivation,
      version,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Uint32)>>('TWHDWalletGetExtendedPrivateKeyAccount');
  late final _TWHDWalletGetExtendedPrivateKeyAccount =
      _TWHDWalletGetExtendedPrivateKeyAccountPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended public key, for custom account.
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \param account valid bip44 account
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKeyAccount(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int derivation,
    int version,
    int account,
  ) {
    return _TWHDWalletGetExtendedPublicKeyAccount(
      wallet,
      purpose,
      coin,
      derivation,
      version,
      account,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Uint32)>>('TWHDWalletGetExtendedPublicKeyAccount');
  late final _TWHDWalletGetExtendedPublicKeyAccount =
      _TWHDWalletGetExtendedPublicKeyAccountPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int, int)>();

  /// Returns the extended private key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended private key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPrivateKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int derivation,
    int version,
  ) {
    return _TWHDWalletGetExtendedPrivateKeyDerivation(
      wallet,
      purpose,
      coin,
      derivation,
      version,
    );
  }

  late final _TWHDWalletGetExtendedPrivateKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('TWHDWalletGetExtendedPrivateKeyDerivation');
  late final _TWHDWalletGetExtendedPrivateKeyDerivation =
      _TWHDWalletGetExtendedPrivateKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Returns the extended public key (for default 0 account with derivation).
  ///
  /// \param wallet non-null TWHDWallet
  /// \param purpose a purpose
  /// \param coin a coin type
  /// \param derivation a derivation
  /// \param version an hd version
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return  Extended public key as a non-null TWString
  ffi.Pointer<TWString> TWHDWalletGetExtendedPublicKeyDerivation(
    ffi.Pointer<TWHDWallet> wallet,
    int purpose,
    int coin,
    int derivation,
    int version,
  ) {
    return _TWHDWalletGetExtendedPublicKeyDerivation(
      wallet,
      purpose,
      coin,
      derivation,
      version,
    );
  }

  late final _TWHDWalletGetExtendedPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32,
              ffi.Int32)>>('TWHDWalletGetExtendedPublicKeyDerivation');
  late final _TWHDWalletGetExtendedPublicKeyDerivation =
      _TWHDWalletGetExtendedPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWHDWallet>, int, int, int, int)>();

  /// Computes the public key from an extended public key representation.
  ///
  /// \param extended extended public key
  /// \param coin a coin type
  /// \param derivationPath a derivation path
  /// \note Returned object needs to be deleted with \TWPublicKeyDelete
  /// \return Nullable TWPublic key
  ffi.Pointer<TWPublicKey> TWHDWalletGetPublicKeyFromExtended(
    ffi.Pointer<TWString> extended,
    int coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWHDWalletGetPublicKeyFromExtended(
      extended,
      coin,
      derivationPath,
    );
  }

  late final _TWHDWalletGetPublicKeyFromExtendedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWHDWalletGetPublicKeyFromExtended');
  late final _TWHDWalletGetPublicKeyFromExtended =
      _TWHDWalletGetPublicKeyFromExtendedPtr.asFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Calculate the TX hash of a transaction.
  ///
  /// \param coin coin type.
  /// \param encodedTx encoded transaction data.
  /// \return The TX hash of a transaction, If the input is invalid or the chain is unsupported, null is returned.
  ffi.Pointer<TWString> TWTransactionUtilCalcTxHash(
    int coinType,
    ffi.Pointer<TWString> encodedTx,
  ) {
    return _TWTransactionUtilCalcTxHash(
      coinType,
      encodedTx,
    );
  }

  late final _TWTransactionUtilCalcTxHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Int32,
              ffi.Pointer<TWString>)>>('TWTransactionUtilCalcTxHash');
  late final _TWTransactionUtilCalcTxHash = _TWTransactionUtilCalcTxHashPtr
      .asFunction<ffi.Pointer<TWString> Function(int, ffi.Pointer<TWString>)>();

  /// Encode an item or a list of items as Eth RLP binary format.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input Non-null serialized `EthereumRlp::Proto::EncodingInput`.
  /// \return serialized `EthereumRlp::Proto::EncodingOutput`.
  ffi.Pointer<TWData> TWEthereumRlpEncode(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumRlpEncode(
      coin,
      input,
    );
  }

  late final _TWEthereumRlpEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWEthereumRlpEncode');
  late final _TWEthereumRlpEncode = _TWEthereumRlpEncodePtr.asFunction<
      ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Creates a Vector of Data.
  ///
  /// \note Must be deleted with \TWDataVectorDelete
  /// \return a non-null Vector of Data.
  ffi.Pointer<TWDataVector> TWDataVectorCreate() {
    return _TWDataVectorCreate();
  }

  late final _TWDataVectorCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWDataVector> Function()>>(
          'TWDataVectorCreate');
  late final _TWDataVectorCreate =
      _TWDataVectorCreatePtr.asFunction<ffi.Pointer<TWDataVector> Function()>();

  /// Creates a Vector of Data with the given element
  ///
  /// \param data A non-null valid block of data
  /// \return A Vector of data with a single given element
  ffi.Pointer<TWDataVector> TWDataVectorCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataVectorCreateWithData(
      data,
    );
  }

  late final _TWDataVectorCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDataVector> Function(
              ffi.Pointer<TWData>)>>('TWDataVectorCreateWithData');
  late final _TWDataVectorCreateWithData = _TWDataVectorCreateWithDataPtr
      .asFunction<ffi.Pointer<TWDataVector> Function(ffi.Pointer<TWData>)>();

  /// Delete/Deallocate a Vector of Data
  ///
  /// \param dataVector A non-null Vector of data
  void TWDataVectorDelete(
    ffi.Pointer<TWDataVector> dataVector,
  ) {
    return _TWDataVectorDelete(
      dataVector,
    );
  }

  late final _TWDataVectorDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWDataVector>)>>(
          'TWDataVectorDelete');
  late final _TWDataVectorDelete = _TWDataVectorDeletePtr.asFunction<
      void Function(ffi.Pointer<TWDataVector>)>();

  /// Add an element to a Vector of Data. Element is cloned
  ///
  /// \param dataVector A non-null Vector of data
  /// \param data A non-null valid block of data
  /// \note data input parameter must be deleted on its own
  void TWDataVectorAdd(
    ffi.Pointer<TWDataVector> dataVector,
    ffi.Pointer<TWData> data,
  ) {
    return _TWDataVectorAdd(
      dataVector,
      data,
    );
  }

  late final _TWDataVectorAddPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWDataVector>,
              ffi.Pointer<TWData>)>>('TWDataVectorAdd');
  late final _TWDataVectorAdd = _TWDataVectorAddPtr.asFunction<
      void Function(ffi.Pointer<TWDataVector>, ffi.Pointer<TWData>)>();

  /// Retrieve the number of elements
  ///
  /// \param dataVector A non-null Vector of data
  /// \return the size of the given vector.
  int TWDataVectorSize(
    ffi.Pointer<TWDataVector> dataVector,
  ) {
    return _TWDataVectorSize(
      dataVector,
    );
  }

  late final _TWDataVectorSizePtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWDataVector>)>>(
          'TWDataVectorSize');
  late final _TWDataVectorSize = _TWDataVectorSizePtr.asFunction<
      int Function(ffi.Pointer<TWDataVector>)>();

  /// Retrieve the n-th element.
  ///
  /// \param dataVector A non-null Vector of data
  /// \param index index element of the vector to be retrieved, need to be < TWDataVectorSize
  /// \note Returned element must be freed with \TWDataDelete
  /// \return A non-null block of data
  ffi.Pointer<TWData> TWDataVectorGet(
    ffi.Pointer<TWDataVector> dataVector,
    int index,
  ) {
    return _TWDataVectorGet(
      dataVector,
      index,
    );
  }

  late final _TWDataVectorGetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWDataVector>, ffi.Size)>>('TWDataVectorGet');
  late final _TWDataVectorGet = _TWDataVectorGetPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWDataVector>, int)>();

  /// Obtains pre-signing hashes of a transaction.
  ///
  /// We provide a default `PreSigningOutput` in TransactionCompiler.proto.
  /// For some special coins, such as bitcoin, we will create a custom `PreSigningOutput` object in its proto file.
  /// \param coin coin type.
  /// \param txInputData The serialized data of a signing input
  /// \return serialized data of a proto object `PreSigningOutput` includes hash.
  ffi.Pointer<TWData> TWTransactionCompilerPreImageHashes(
    int coinType,
    ffi.Pointer<TWData> txInputData,
  ) {
    return _TWTransactionCompilerPreImageHashes(
      coinType,
      txInputData,
    );
  }

  late final _TWTransactionCompilerPreImageHashesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Int32,
              ffi.Pointer<TWData>)>>('TWTransactionCompilerPreImageHashes');
  late final _TWTransactionCompilerPreImageHashes =
      _TWTransactionCompilerPreImageHashesPtr.asFunction<
          ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Compiles a complete transation with one or more external signatures.
  ///
  /// Puts together from transaction input and provided public keys and signatures. The signatures must match the hashes
  /// returned by TWTransactionCompilerPreImageHashes, in the same order. The publicKeyHash attached
  /// to the hashes enable identifying the private key needed for signing the hash.
  /// \param coin coin type.
  /// \param txInputData The serialized data of a signing input.
  /// \param signatures signatures to compile, using TWDataVector.
  /// \param publicKeys public keys for signers to match private keys, using TWDataVector.
  /// \return serialized data of a proto object `SigningOutput`.
  ffi.Pointer<TWData> TWTransactionCompilerCompileWithSignatures(
    int coinType,
    ffi.Pointer<TWData> txInputData,
    ffi.Pointer<TWDataVector> signatures,
    ffi.Pointer<TWDataVector> publicKeys,
  ) {
    return _TWTransactionCompilerCompileWithSignatures(
      coinType,
      txInputData,
      signatures,
      publicKeys,
    );
  }

  late final _TWTransactionCompilerCompileWithSignaturesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Int32, ffi.Pointer<TWData>,
                  ffi.Pointer<TWDataVector>, ffi.Pointer<TWDataVector>)>>(
      'TWTransactionCompilerCompileWithSignatures');
  late final _TWTransactionCompilerCompileWithSignatures =
      _TWTransactionCompilerCompileWithSignaturesPtr.asFunction<
          ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>,
              ffi.Pointer<TWDataVector>, ffi.Pointer<TWDataVector>)>();

  ffi.Pointer<TWData> TWTransactionCompilerCompileWithSignaturesAndPubKeyType(
    int coinType,
    ffi.Pointer<TWData> txInputData,
    ffi.Pointer<TWDataVector> signatures,
    ffi.Pointer<TWDataVector> publicKeys,
    int pubKeyType,
  ) {
    return _TWTransactionCompilerCompileWithSignaturesAndPubKeyType(
      coinType,
      txInputData,
      signatures,
      publicKeys,
      pubKeyType,
    );
  }

  late final _TWTransactionCompilerCompileWithSignaturesAndPubKeyTypePtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<TWData> Function(
                      ffi.Int32,
                      ffi.Pointer<TWData>,
                      ffi.Pointer<TWDataVector>,
                      ffi.Pointer<TWDataVector>,
                      ffi.Int32)>>(
          'TWTransactionCompilerCompileWithSignaturesAndPubKeyType');
  late final _TWTransactionCompilerCompileWithSignaturesAndPubKeyType =
      _TWTransactionCompilerCompileWithSignaturesAndPubKeyTypePtr.asFunction<
          ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>,
              ffi.Pointer<TWDataVector>, ffi.Pointer<TWDataVector>, int)>();

  /// Returns the encoded hash of the user operation
  ///
  /// \param chain_id The chain ID of the user.
  /// \param code_address The address of the smart contract wallet.
  /// \param code_name The name of the smart contract wallet.
  /// \param code_version The version of the smart contract wallet.
  /// \param type_hash The type hash of the smart contract wallet.
  /// \param domain_separator_hash The domain separator hash of the smart contract wallet.
  /// \param sender The sender of the smart contract wallet.
  /// \param user_op_hash The user operation hash of the smart contract wallet.
  /// \return The encoded hash.
  ffi.Pointer<TWData1> TWBizGetEncodedHash(
    ffi.Pointer<TWData1> chainId,
    ffi.Pointer<TWString1> codeAddress,
    ffi.Pointer<TWString1> codeName,
    ffi.Pointer<TWString1> codeVersion,
    ffi.Pointer<TWString1> typeHash,
    ffi.Pointer<TWString1> domainSeparatorHash,
    ffi.Pointer<TWString1> sender,
    ffi.Pointer<TWString1> userOpHash,
  ) {
    return _TWBizGetEncodedHash(
      chainId,
      codeAddress,
      codeName,
      codeVersion,
      typeHash,
      domainSeparatorHash,
      sender,
      userOpHash,
    );
  }

  late final _TWBizGetEncodedHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWBizGetEncodedHash');
  late final _TWBizGetEncodedHash = _TWBizGetEncodedHashPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>,
          ffi.Pointer<TWString1>)>();

  /// Signs a message using the private key
  ///
  /// \param hash The hash of the user.
  /// \param private_key The private key of the user.
  /// \return The signed hash.
  ffi.Pointer<TWData1> TWBizGetSignedHash(
    ffi.Pointer<TWString1> hash,
    ffi.Pointer<TWString1> privateKey,
  ) {
    return _TWBizGetSignedHash(
      hash,
      privateKey,
    );
  }

  late final _TWBizGetSignedHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWBizGetSignedHash');
  late final _TWBizGetSignedHash = _TWBizGetSignedHashPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Encodes `Biz.registerSession` function call to register a session passkey public key.
  ///
  /// \param session_passkey_public_key The nist256p1 (aka secp256p1) public key of the session passkey.
  /// \param valid_until_timestamp The timestamp until which the session is valid. Big endian uint64.
  /// \return ABI-encoded function call.
  ffi.Pointer<TWData1> TWBizEncodeRegisterSessionCall(
    ffi.Pointer<TWPublicKey> sessionPasskeyPublicKey,
    ffi.Pointer<TWData1> validUntilTimestamp,
  ) {
    return _TWBizEncodeRegisterSessionCall(
      sessionPasskeyPublicKey,
      validUntilTimestamp,
    );
  }

  late final _TWBizEncodeRegisterSessionCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWPublicKey>,
              ffi.Pointer<TWData1>)>>('TWBizEncodeRegisterSessionCall');
  late final _TWBizEncodeRegisterSessionCall =
      _TWBizEncodeRegisterSessionCallPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPublicKey>, ffi.Pointer<TWData1>)>();

  /// Encodes `Biz.removeSession` function call to deregister a session passkey public key.
  ///
  /// \param session_passkey_public_key The nist256p1 (aka secp256p1) public key of the session passkey.
  /// \return ABI-encoded function call.
  ffi.Pointer<TWData1> TWBizEncodeRemoveSessionCall(
    ffi.Pointer<TWPublicKey> sessionPasskeyPublicKey,
  ) {
    return _TWBizEncodeRemoveSessionCall(
      sessionPasskeyPublicKey,
    );
  }

  late final _TWBizEncodeRemoveSessionCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWBizEncodeRemoveSessionCall');
  late final _TWBizEncodeRemoveSessionCall = _TWBizEncodeRemoveSessionCallPtr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Encodes Biz Passkey Session nonce.
  ///
  /// \param nonce The nonce of the Biz Passkey Session account.
  /// \return uint256 represented as [passkey_nonce_key_192, nonce_64].
  ffi.Pointer<TWData1> TWBizEncodePasskeySessionNonce(
    ffi.Pointer<TWData1> nonce,
  ) {
    return _TWBizEncodePasskeySessionNonce(
      nonce,
    );
  }

  late final _TWBizEncodePasskeySessionNoncePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWBizEncodePasskeySessionNonce');
  late final _TWBizEncodePasskeySessionNonce =
      _TWBizEncodePasskeySessionNoncePtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encodes `Biz.executeWithPasskeySession` function call to execute a batch of transactions.
  ///
  /// \param input The serialized data of `Biz.ExecuteWithPasskeySessionInput` protobuf message.
  /// \return ABI-encoded function call.
  ffi.Pointer<TWData1> TWBizEncodeExecuteWithPasskeySessionCall(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWBizEncodeExecuteWithPasskeySessionCall(
      input,
    );
  }

  late final _TWBizEncodeExecuteWithPasskeySessionCallPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWBizEncodeExecuteWithPasskeySessionCall');
  late final _TWBizEncodeExecuteWithPasskeySessionCall =
      _TWBizEncodeExecuteWithPasskeySessionCallPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Generates the private stark key at the given derivation path from a valid eth signature
  ///
  /// \param derivationPath non-null StarkEx Derivation path
  /// \param signature valid eth signature
  /// \return  The private key for the specified derivation path/signature
  ffi.Pointer<TWPrivateKey> TWStarkWareGetStarkKeyFromSignature(
    ffi.Pointer<TWDerivationPath> derivationPath,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWStarkWareGetStarkKeyFromSignature(
      derivationPath,
      signature,
    );
  }

  late final _TWStarkWareGetStarkKeyFromSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWDerivationPath>,
              ffi.Pointer<TWString1>)>>('TWStarkWareGetStarkKeyFromSignature');
  late final _TWStarkWareGetStarkKeyFromSignature =
      _TWStarkWareGetStarkKeyFromSignaturePtr.asFunction<
          ffi.Pointer<TWPrivateKey> Function(
              ffi.Pointer<TWDerivationPath>, ffi.Pointer<TWString1>)>();

  /// Determines if the given sig hash is single
  ///
  /// \param type sig hash type
  /// \return true if the sigh hash type is single, false otherwise
  bool TWBitcoinSigHashTypeIsSingle(
    int type,
  ) {
    return _TWBitcoinSigHashTypeIsSingle(
      type,
    );
  }

  late final _TWBitcoinSigHashTypeIsSinglePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'TWBitcoinSigHashTypeIsSingle');
  late final _TWBitcoinSigHashTypeIsSingle =
      _TWBitcoinSigHashTypeIsSinglePtr.asFunction<bool Function(int)>();

  /// Determines if the given sig hash is none
  ///
  /// \param type sig hash type
  /// \return true if the sigh hash type is none, false otherwise
  bool TWBitcoinSigHashTypeIsNone(
    int type,
  ) {
    return _TWBitcoinSigHashTypeIsNone(
      type,
    );
  }

  late final _TWBitcoinSigHashTypeIsNonePtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'TWBitcoinSigHashTypeIsNone');
  late final _TWBitcoinSigHashTypeIsNone =
      _TWBitcoinSigHashTypeIsNonePtr.asFunction<bool Function(int)>();

  /// Encode a bool according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a boolean value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeBool(
    bool value,
  ) {
    return _TWEthereumAbiValueEncodeBool(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBoolPtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Bool)>>(
          'TWEthereumAbiValueEncodeBool');
  late final _TWEthereumAbiValueEncodeBool = _TWEthereumAbiValueEncodeBoolPtr
      .asFunction<ffi.Pointer<TWData> Function(bool)>();

  /// Encode a int32 according to Ethereum ABI, into 32 bytes. Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int32 value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeInt32(
    int value,
  ) {
    return _TWEthereumAbiValueEncodeInt32(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeInt32Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Int32)>>(
          'TWEthereumAbiValueEncodeInt32');
  late final _TWEthereumAbiValueEncodeInt32 = _TWEthereumAbiValueEncodeInt32Ptr
      .asFunction<ffi.Pointer<TWData> Function(int)>();

  /// Encode a uint32 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a uint32 value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeUInt32(
    int value,
  ) {
    return _TWEthereumAbiValueEncodeUInt32(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeUInt32Ptr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWData> Function(ffi.Uint32)>>(
          'TWEthereumAbiValueEncodeUInt32');
  late final _TWEthereumAbiValueEncodeUInt32 =
      _TWEthereumAbiValueEncodeUInt32Ptr.asFunction<
          ffi.Pointer<TWData> Function(int)>();

  /// Encode a int256 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int256 value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeInt256(
    ffi.Pointer<TWData> value,
  ) {
    return _TWEthereumAbiValueEncodeInt256(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeInt256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueEncodeInt256');
  late final _TWEthereumAbiValueEncodeInt256 =
      _TWEthereumAbiValueEncodeInt256Ptr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Encode an int256 according to Ethereum ABI, into 32 bytes.  Values are padded by 0 on the left, unless specified otherwise
  ///
  /// \param value a int256 value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeUInt256(
    ffi.Pointer<TWData> value,
  ) {
    return _TWEthereumAbiValueEncodeUInt256(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeUInt256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueEncodeUInt256');
  late final _TWEthereumAbiValueEncodeUInt256 =
      _TWEthereumAbiValueEncodeUInt256Ptr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Encode an address according to Ethereum ABI, 20 bytes of the address.
  ///
  /// \param value an address value stored in a block of data
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeAddress(
    ffi.Pointer<TWData> value,
  ) {
    return _TWEthereumAbiValueEncodeAddress(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeAddressPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueEncodeAddress');
  late final _TWEthereumAbiValueEncodeAddress =
      _TWEthereumAbiValueEncodeAddressPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Encode a string according to Ethereum ABI by encoding its hash.
  ///
  /// \param value a string value
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeString(
    ffi.Pointer<TWString> value,
  ) {
    return _TWEthereumAbiValueEncodeString(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeStringPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWEthereumAbiValueEncodeString');
  late final _TWEthereumAbiValueEncodeString =
      _TWEthereumAbiValueEncodeStringPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Encode a number of bytes, up to 32 bytes, padded on the right.  Longer arrays are truncated.
  ///
  /// \param value bunch of bytes
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeBytes(
    ffi.Pointer<TWData> value,
  ) {
    return _TWEthereumAbiValueEncodeBytes(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBytesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueEncodeBytes');
  late final _TWEthereumAbiValueEncodeBytes = _TWEthereumAbiValueEncodeBytesPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Encode a dynamic number of bytes by encoding its hash
  ///
  /// \param value bunch of bytes
  /// \return Encoded value stored in a block of data
  ffi.Pointer<TWData> TWEthereumAbiValueEncodeBytesDyn(
    ffi.Pointer<TWData> value,
  ) {
    return _TWEthereumAbiValueEncodeBytesDyn(
      value,
    );
  }

  late final _TWEthereumAbiValueEncodeBytesDynPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueEncodeBytesDyn');
  late final _TWEthereumAbiValueEncodeBytesDyn =
      _TWEthereumAbiValueEncodeBytesDynPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWData>)>();

  /// Decodes input data (bytes longer than 32 will be truncated) as uint256
  ///
  /// \param input Data to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString> TWEthereumAbiValueDecodeUInt256(
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumAbiValueDecodeUInt256(
      input,
    );
  }

  late final _TWEthereumAbiValueDecodeUInt256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>>(
      'TWEthereumAbiValueDecodeUInt256');
  late final _TWEthereumAbiValueDecodeUInt256 =
      _TWEthereumAbiValueDecodeUInt256Ptr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>)>();

  /// Decode an arbitrary type, return value as string
  ///
  /// \param input Data to be decoded
  /// \param type the underlying type that need to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString> TWEthereumAbiValueDecodeValue(
    ffi.Pointer<TWData> input,
    ffi.Pointer<TWString> type,
  ) {
    return _TWEthereumAbiValueDecodeValue(
      input,
      type,
    );
  }

  late final _TWEthereumAbiValueDecodeValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWEthereumAbiValueDecodeValue');
  late final _TWEthereumAbiValueDecodeValue =
      _TWEthereumAbiValueDecodeValuePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Decode an array of given simple types.  Return a '\n'-separated string of elements
  ///
  /// \param input Data to be decoded
  /// \param type the underlying type that need to be decoded
  /// \return Non-null decoded string value
  ffi.Pointer<TWString> TWEthereumAbiValueDecodeArray(
    ffi.Pointer<TWData> input,
    ffi.Pointer<TWString> type,
  ) {
    return _TWEthereumAbiValueDecodeArray(
      input,
      type,
    );
  }

  late final _TWEthereumAbiValueDecodeArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWEthereumAbiValueDecodeArray');
  late final _TWEthereumAbiValueDecodeArray =
      _TWEthereumAbiValueDecodeArrayPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Signs a transaction specified by the signing input and coin type.
  ///
  /// \param input The serialized data of a signing input (e.g. TW.Bitcoin.Proto.SigningInput).
  /// \param coin The given coin type to sign the transaction for.
  /// \return The serialized data of a `SigningOutput` proto object. (e.g. TW.Bitcoin.Proto.SigningOutput).
  ffi.Pointer<TWData> TWAnySignerSign(
    ffi.Pointer<TWData> input,
    int coin,
  ) {
    return _TWAnySignerSign(
      input,
      coin,
    );
  }

  late final _TWAnySignerSignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>, ffi.Int32)>>('TWAnySignerSign');
  late final _TWAnySignerSign = _TWAnySignerSignPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, int)>();

  /// Signs a transaction specified by the JSON representation of signing input, coin type and a private key, returning the JSON representation of the signing output.
  ///
  /// \param json JSON representation of a signing input
  /// \param key The private key to sign with.
  /// \param coin The given coin type to sign the transaction for.
  /// \return The JSON representation of a `SigningOutput` proto object.
  ffi.Pointer<TWString> TWAnySignerSignJSON(
    ffi.Pointer<TWString> json,
    ffi.Pointer<TWData> key,
    int coin,
  ) {
    return _TWAnySignerSignJSON(
      json,
      key,
      coin,
    );
  }

  late final _TWAnySignerSignJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.Int32)>>('TWAnySignerSignJSON');
  late final _TWAnySignerSignJSON = _TWAnySignerSignJSONPtr.asFunction<
      ffi.Pointer<TWString> Function(
          ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Check if AnySigner supports signing JSON representation of signing input.
  ///
  /// \param coin The given coin type to sign the transaction for.
  /// \return true if AnySigner supports signing JSON representation of signing input for a given coin.
  bool TWAnySignerSupportsJSON(
    int coin,
  ) {
    return _TWAnySignerSupportsJSON(
      coin,
    );
  }

  late final _TWAnySignerSupportsJSONPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Int32)>>(
          'TWAnySignerSupportsJSON');
  late final _TWAnySignerSupportsJSON =
      _TWAnySignerSupportsJSONPtr.asFunction<bool Function(int)>();

  /// Plans a transaction (for UTXO chains only).
  ///
  /// \param input The serialized data of a signing input
  /// \param coin The given coin type to plan the transaction for.
  /// \return The serialized data of a `TransactionPlan` proto object.
  ffi.Pointer<TWData> TWAnySignerPlan(
    ffi.Pointer<TWData> input,
    int coin,
  ) {
    return _TWAnySignerPlan(
      input,
      coin,
    );
  }

  late final _TWAnySignerPlanPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWData>, ffi.Int32)>>('TWAnySignerPlan');
  late final _TWAnySignerPlan = _TWAnySignerPlanPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWData>, int)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWNervosAddressEqual(
    ffi.Pointer<TWNervosAddress> lhs,
    ffi.Pointer<TWNervosAddress> rhs,
  ) {
    return _TWNervosAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWNervosAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWNervosAddress>,
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressEqual');
  late final _TWNervosAddressEqual = _TWNervosAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWNervosAddress>, ffi.Pointer<TWNervosAddress>)>();

  /// Determines if the string is a valid Nervos address.
  ///
  /// \param string string to validate.
  /// \return bool indicating if the address is valid.
  bool TWNervosAddressIsValidString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWNervosAddressIsValidString(
      string,
    );
  }

  late final _TWNervosAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWNervosAddressIsValidString');
  late final _TWNervosAddressIsValidString = _TWNervosAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString1>)>();

  /// Initializes an address from a sring representaion.
  ///
  /// \param string Bech32 string to initialize the address from.
  /// \return TWNervosAddress pointer or nullptr if string is invalid.
  ffi.Pointer<TWNervosAddress> TWNervosAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWNervosAddressCreateWithString(
      string,
    );
  }

  late final _TWNervosAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWNervosAddress> Function(
              ffi.Pointer<TWString1>)>>('TWNervosAddressCreateWithString');
  late final _TWNervosAddressCreateWithString =
      _TWNervosAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWNervosAddress> Function(ffi.Pointer<TWString1>)>();

  /// Deletes a Nervos address.
  ///
  /// \param address Address to delete.
  void TWNervosAddressDelete(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressDelete(
      address,
    );
  }

  late final _TWNervosAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWNervosAddress>)>>(
      'TWNervosAddressDelete');
  late final _TWNervosAddressDelete = _TWNervosAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address Address to get the string representation of.
  ffi.Pointer<TWString1> TWNervosAddressDescription(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressDescription(
      address,
    );
  }

  late final _TWNervosAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressDescription');
  late final _TWNervosAddressDescription =
      _TWNervosAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the Code hash
  ///
  /// \param address Address to get the keyhash data of.
  ffi.Pointer<TWData1> TWNervosAddressCodeHash(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressCodeHash(
      address,
    );
  }

  late final _TWNervosAddressCodeHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressCodeHash');
  late final _TWNervosAddressCodeHash = _TWNervosAddressCodeHashPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address hash type
  ///
  /// \param address Address to get the hash type of.
  ffi.Pointer<TWString1> TWNervosAddressHashType(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressHashType(
      address,
    );
  }

  late final _TWNervosAddressHashTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressHashType');
  late final _TWNervosAddressHashType = _TWNervosAddressHashTypePtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Returns the address args data.
  ///
  /// \param address Address to get the args data of.
  ffi.Pointer<TWData1> TWNervosAddressArgs(
    ffi.Pointer<TWNervosAddress> address,
  ) {
    return _TWNervosAddressArgs(
      address,
    );
  }

  late final _TWNervosAddressArgsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWNervosAddress>)>>('TWNervosAddressArgs');
  late final _TWNervosAddressArgs = _TWNervosAddressArgsPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWNervosAddress>)>();

  /// Decode a Base64 input with the default alphabet (RFC4648 with '+', '/')
  ///
  /// \param string Encoded input to be decoded
  /// \return The decoded data, empty if decoding failed.
  ffi.Pointer<TWData1> TWBase64Decode(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBase64Decode(
      string,
    );
  }

  late final _TWBase64DecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBase64Decode');
  late final _TWBase64Decode = _TWBase64DecodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Decode a Base64 input with the alphabet safe for URL-s and filenames (RFC4648 with '-', '_')
  ///
  /// \param string Encoded base64 input to be decoded
  /// \return The decoded data, empty if decoding failed.
  ffi.Pointer<TWData1> TWBase64DecodeUrl(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBase64DecodeUrl(
      string,
    );
  }

  late final _TWBase64DecodeUrlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBase64DecodeUrl');
  late final _TWBase64DecodeUrl = _TWBase64DecodeUrlPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Encode an input to Base64 with the default alphabet (RFC4648 with '+', '/')
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  ffi.Pointer<TWString1> TWBase64Encode(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBase64Encode(
      data,
    );
  }

  late final _TWBase64EncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBase64Encode');
  late final _TWBase64Encode = _TWBase64EncodePtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Encode an input to Base64 with the alphabet safe for URL-s and filenames (RFC4648 with '-', '_')
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  ffi.Pointer<TWString1> TWBase64EncodeUrl(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBase64EncodeUrl(
      data,
    );
  }

  late final _TWBase64EncodeUrlPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBase64EncodeUrl');
  late final _TWBase64EncodeUrl = _TWBase64EncodeUrlPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs left non-null pointer to a Bech32 Address
  /// \param rhs right non-null pointer to a Bech32 Address
  /// \return true if both address are equal, false otherwise
  bool TWSegwitAddressEqual(
    ffi.Pointer<TWSegwitAddress> lhs,
    ffi.Pointer<TWSegwitAddress> rhs,
  ) {
    return _TWSegwitAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWSegwitAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWSegwitAddress>,
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressEqual');
  late final _TWSegwitAddressEqual = _TWSegwitAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWSegwitAddress>, ffi.Pointer<TWSegwitAddress>)>();

  /// Determines if the string is a valid Bech32 address.
  ///
  /// \param string Non-null pointer to a Bech32 address as a string
  /// \return true if the string is a valid Bech32 address, false otherwise.
  bool TWSegwitAddressIsValidString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWSegwitAddressIsValidString(
      string,
    );
  }

  late final _TWSegwitAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWSegwitAddressIsValidString');
  late final _TWSegwitAddressIsValidString = _TWSegwitAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString>)>();

  /// Creates an address from a string representation.
  ///
  /// \param string Non-null pointer to a Bech32 address as a string
  /// \note should be deleted with \TWSegwitAddressDelete
  /// \return Pointer to a Bech32 address if the string is a valid Bech32 address, null pointer otherwise
  ffi.Pointer<TWSegwitAddress> TWSegwitAddressCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWSegwitAddressCreateWithString(
      string,
    );
  }

  late final _TWSegwitAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSegwitAddress> Function(
              ffi.Pointer<TWString>)>>('TWSegwitAddressCreateWithString');
  late final _TWSegwitAddressCreateWithString =
      _TWSegwitAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWSegwitAddress> Function(ffi.Pointer<TWString>)>();

  /// Creates a segwit-version-0 address from a public key and HRP prefix.
  /// Taproot (v>=1) is not supported by this method.
  ///
  /// \param hrp HRP of the utxo coin targeted
  /// \param publicKey Non-null pointer to the public key of the targeted coin
  /// \note should be deleted with \TWSegwitAddressDelete
  /// \return Non-null pointer to the corresponding Segwit address
  ffi.Pointer<TWSegwitAddress> TWSegwitAddressCreateWithPublicKey(
    int hrp,
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWSegwitAddressCreateWithPublicKey(
      hrp,
      publicKey,
    );
  }

  late final _TWSegwitAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSegwitAddress> Function(ffi.Int32,
              ffi.Pointer<TWPublicKey>)>>('TWSegwitAddressCreateWithPublicKey');
  late final _TWSegwitAddressCreateWithPublicKey =
      _TWSegwitAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWSegwitAddress> Function(
              int, ffi.Pointer<TWPublicKey>)>();

  /// Delete the given Segwit address
  ///
  /// \param address Non-null pointer to a Segwit address
  void TWSegwitAddressDelete(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressDelete(
      address,
    );
  }

  late final _TWSegwitAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWSegwitAddress>)>>(
      'TWSegwitAddressDelete');
  late final _TWSegwitAddressDelete = _TWSegwitAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return Non-null pointer to the segwit address string representation
  ffi.Pointer<TWString> TWSegwitAddressDescription(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressDescription(
      address,
    );
  }

  late final _TWSegwitAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressDescription');
  late final _TWSegwitAddressDescription =
      _TWSegwitAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the human-readable part.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return the HRP part of the given address
  int TWSegwitAddressHRP(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressHRP(
      address,
    );
  }

  late final _TWSegwitAddressHRPPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<TWSegwitAddress>)>>(
      'TWSegwitAddressHRP');
  late final _TWSegwitAddressHRP = _TWSegwitAddressHRPPtr.asFunction<
      int Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the human-readable part.
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return returns the witness version of the given segwit address
  int TWSegwitAddressWitnessVersion(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressWitnessVersion(
      address,
    );
  }

  late final _TWSegwitAddressWitnessVersionPtr = _lookup<
          ffi.NativeFunction<ffi.Int Function(ffi.Pointer<TWSegwitAddress>)>>(
      'TWSegwitAddressWitnessVersion');
  late final _TWSegwitAddressWitnessVersion = _TWSegwitAddressWitnessVersionPtr
      .asFunction<int Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Returns the witness program
  ///
  /// \param address Non-null pointer to a Segwit Address
  /// \return returns the witness data of the given segwit address as a non-null pointer block of data
  ffi.Pointer<TWData> TWSegwitAddressWitnessProgram(
    ffi.Pointer<TWSegwitAddress> address,
  ) {
    return _TWSegwitAddressWitnessProgram(
      address,
    );
  }

  late final _TWSegwitAddressWitnessProgramPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWSegwitAddress>)>>('TWSegwitAddressWitnessProgram');
  late final _TWSegwitAddressWitnessProgram = _TWSegwitAddressWitnessProgramPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWSegwitAddress>)>();

  /// Constructs a TON Wallet V4R2 stateInit encoded as BoC (BagOfCells) for the given `public_key`.
  ///
  /// \param public_key wallet's public key.
  /// \param workchain TON workchain to which the wallet belongs. Usually, base chain is used (0).
  /// \param wallet_id wallet's ID allows to create multiple wallets for the same private key.
  /// \return Pointer to a base64 encoded Bag Of Cells (BoC) StateInit. Null if invalid public key provided.
  ffi.Pointer<TWString1> TWTONWalletBuildV4R2StateInit(
    ffi.Pointer<TWPublicKey> publicKey,
    int workchain,
    int walletId,
  ) {
    return _TWTONWalletBuildV4R2StateInit(
      publicKey,
      workchain,
      walletId,
    );
  }

  late final _TWTONWalletBuildV4R2StateInitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPublicKey>, ffi.Int32,
              ffi.Int32)>>('TWTONWalletBuildV4R2StateInit');
  late final _TWTONWalletBuildV4R2StateInit =
      _TWTONWalletBuildV4R2StateInitPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// \param public_key wallet's public key.
  /// \param workchain TON workchain to which the wallet belongs. Usually, base chain is used (0).
  /// \param wallet_id wallet's ID allows to create multiple wallets for the same private key.
  /// \return Pointer to a base64 encoded Bag Of Cells (BoC) StateInit. Null if invalid public key provided.
  ffi.Pointer<TWString1> TWTONWalletBuildV5R1StateInit(
    ffi.Pointer<TWPublicKey> publicKey,
    int workchain,
    int walletId,
  ) {
    return _TWTONWalletBuildV5R1StateInit(
      publicKey,
      workchain,
      walletId,
    );
  }

  late final _TWTONWalletBuildV5R1StateInitPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPublicKey>, ffi.Int32,
              ffi.Int32)>>('TWTONWalletBuildV5R1StateInit');
  late final _TWTONWalletBuildV5R1StateInit =
      _TWTONWalletBuildV5R1StateInitPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Sign a typed message EIP-712 V4.
  ///
  /// \param privateKey: the private key used for signing
  /// \param messageJson: A custom typed data message in json
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWEthereumMessageSignerSignTypedMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> messageJson,
  ) {
    return _TWEthereumMessageSignerSignTypedMessage(
      privateKey,
      messageJson,
    );
  }

  late final _TWEthereumMessageSignerSignTypedMessagePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>>(
      'TWEthereumMessageSignerSignTypedMessage');
  late final _TWEthereumMessageSignerSignTypedMessage =
      _TWEthereumMessageSignerSignTypedMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Sign a typed message EIP-712 V4 with EIP-155 replay attack protection.
  ///
  /// \param privateKey: the private key used for signing
  /// \param messageJson: A custom typed data message in json
  /// \param chainId: chainId for eip-155 protection
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned or invalid chainId error message. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWEthereumMessageSignerSignTypedMessageEip155(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> messageJson,
    int chainId,
  ) {
    return _TWEthereumMessageSignerSignTypedMessageEip155(
      privateKey,
      messageJson,
      chainId,
    );
  }

  late final _TWEthereumMessageSignerSignTypedMessageEip155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>,
              ffi.Int)>>('TWEthereumMessageSignerSignTypedMessageEip155');
  late final _TWEthereumMessageSignerSignTypedMessageEip155 =
      _TWEthereumMessageSignerSignTypedMessageEip155Ptr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>, int)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWEthereumMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWEthereumMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWEthereumMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>)>>('TWEthereumMessageSignerSignMessage');
  late final _TWEthereumMessageSignerSignMessage =
      _TWEthereumMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Sign a message with Immutable X msg type.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWEthereumMessageSignerSignMessageImmutableX(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWEthereumMessageSignerSignMessageImmutableX(
      privateKey,
      message,
    );
  }

  late final _TWEthereumMessageSignerSignMessageImmutableXPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>>(
      'TWEthereumMessageSignerSignMessageImmutableX');
  late final _TWEthereumMessageSignerSignMessageImmutableX =
      _TWEthereumMessageSignerSignMessageImmutableXPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Sign a message with Eip-155 msg type.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \param chainId: chainId for eip-155 protection
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWEthereumMessageSignerSignMessageEip155(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
    int chainId,
  ) {
    return _TWEthereumMessageSignerSignMessageEip155(
      privateKey,
      message,
      chainId,
    );
  }

  late final _TWEthereumMessageSignerSignMessageEip155Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>,
              ffi.Int)>>('TWEthereumMessageSignerSignMessageEip155');
  late final _TWEthereumMessageSignerSignMessageEip155 =
      _TWEthereumMessageSignerSignMessageEip155Ptr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>, int)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix)
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWEthereumMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWEthereumMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWEthereumMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWEthereumMessageSignerVerifyMessage');
  late final _TWEthereumMessageSignerVerifyMessage =
      _TWEthereumMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Decodes a transaction from a binary representation.
  ///
  /// \param coin coin type.
  /// \param encodedTx encoded transaction data.
  /// \return serialized protobuf message specific for the given coin.
  ffi.Pointer<TWData> TWTransactionDecoderDecode(
    int coinType,
    ffi.Pointer<TWData> encodedTx,
  ) {
    return _TWTransactionDecoderDecode(
      coinType,
      encodedTx,
    );
  }

  late final _TWTransactionDecoderDecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWTransactionDecoderDecode');
  late final _TWTransactionDecoderDecode = _TWTransactionDecoderDecodePtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWBitcoinAddressEqual(
    ffi.Pointer<TWBitcoinAddress> lhs,
    ffi.Pointer<TWBitcoinAddress> rhs,
  ) {
    return _TWBitcoinAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWBitcoinAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWBitcoinAddress>,
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressEqual');
  late final _TWBitcoinAddressEqual = _TWBitcoinAddressEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWBitcoinAddress>, ffi.Pointer<TWBitcoinAddress>)>();

  /// Determines if the data is a valid Bitcoin address.
  ///
  /// \param data data to validate.
  /// \return bool indicating if the address data is valid.
  bool TWBitcoinAddressIsValid(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBitcoinAddressIsValid(
      data,
    );
  }

  late final _TWBitcoinAddressIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWData1>)>>(
          'TWBitcoinAddressIsValid');
  late final _TWBitcoinAddressIsValid = _TWBitcoinAddressIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWData1>)>();

  /// Determines if the string is a valid Bitcoin address.
  ///
  /// \param string string to validate.
  /// \return bool indicating if the address string is valid.
  bool TWBitcoinAddressIsValidString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBitcoinAddressIsValidString(
      string,
    );
  }

  late final _TWBitcoinAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString1>)>>(
          'TWBitcoinAddressIsValidString');
  late final _TWBitcoinAddressIsValidString = _TWBitcoinAddressIsValidStringPtr
      .asFunction<bool Function(ffi.Pointer<TWString1>)>();

  /// Initializes an address from a Base58 sring. Must be deleted with TWBitcoinAddressDelete after use.
  ///
  /// \param string Base58 string to initialize the address from.
  /// \return TWBitcoinAddress pointer or nullptr if string is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithString(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBitcoinAddressCreateWithString(
      string,
    );
  }

  late final _TWBitcoinAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWString1>)>>('TWBitcoinAddressCreateWithString');
  late final _TWBitcoinAddressCreateWithString =
      _TWBitcoinAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWString1>)>();

  /// Initializes an address from raw data.
  ///
  /// \param data Raw data to initialize the address from. Must be deleted with TWBitcoinAddressDelete after use.
  /// \return TWBitcoinAddress pointer or nullptr if data is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBitcoinAddressCreateWithData(
      data,
    );
  }

  late final _TWBitcoinAddressCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWData1>)>>('TWBitcoinAddressCreateWithData');
  late final _TWBitcoinAddressCreateWithData =
      _TWBitcoinAddressCreateWithDataPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWData1>)>();

  /// Initializes an address from a public key and a prefix byte.
  ///
  /// \param publicKey Public key to initialize the address from.
  /// \param prefix Prefix byte (p2pkh, p2sh, etc).
  /// \return TWBitcoinAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWBitcoinAddress> TWBitcoinAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int prefix,
  ) {
    return _TWBitcoinAddressCreateWithPublicKey(
      publicKey,
      prefix,
    );
  }

  late final _TWBitcoinAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Uint8)>>('TWBitcoinAddressCreateWithPublicKey');
  late final _TWBitcoinAddressCreateWithPublicKey =
      _TWBitcoinAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWBitcoinAddress> Function(
              ffi.Pointer<TWPublicKey>, int)>();

  /// Deletes a legacy Bitcoin address.
  ///
  /// \param address Address to delete.
  void TWBitcoinAddressDelete(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressDelete(
      address,
    );
  }

  late final _TWBitcoinAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWBitcoinAddress>)>>(
      'TWBitcoinAddressDelete');
  late final _TWBitcoinAddressDelete = _TWBitcoinAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the address in Base58 string representation.
  ///
  /// \param address Address to get the string representation of.
  ffi.Pointer<TWString1> TWBitcoinAddressDescription(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressDescription(
      address,
    );
  }

  late final _TWBitcoinAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressDescription');
  late final _TWBitcoinAddressDescription =
      _TWBitcoinAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the address prefix.
  ///
  /// \param address Address to get the prefix of.
  int TWBitcoinAddressPrefix(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressPrefix(
      address,
    );
  }

  late final _TWBitcoinAddressPrefixPtr = _lookup<
          ffi
          .NativeFunction<ffi.Uint8 Function(ffi.Pointer<TWBitcoinAddress>)>>(
      'TWBitcoinAddressPrefix');
  late final _TWBitcoinAddressPrefix = _TWBitcoinAddressPrefixPtr.asFunction<
      int Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Returns the key hash data.
  ///
  /// \param address Address to get the keyhash data of.
  ffi.Pointer<TWData1> TWBitcoinAddressKeyhash(
    ffi.Pointer<TWBitcoinAddress> address,
  ) {
    return _TWBitcoinAddressKeyhash(
      address,
    );
  }

  late final _TWBitcoinAddressKeyhashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWBitcoinAddress>)>>('TWBitcoinAddressKeyhash');
  late final _TWBitcoinAddressKeyhash = _TWBitcoinAddressKeyhashPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWBitcoinAddress>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs The first address to compare.
  /// \param rhs The second address to compare.
  /// \return bool indicating the addresses are equal.
  bool TWAnyAddressEqual(
    ffi.Pointer<TWAnyAddress> lhs,
    ffi.Pointer<TWAnyAddress> rhs,
  ) {
    return _TWAnyAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWAnyAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWAnyAddress>,
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressEqual');
  late final _TWAnyAddressEqual = _TWAnyAddressEqualPtr.asFunction<
      bool Function(ffi.Pointer<TWAnyAddress>, ffi.Pointer<TWAnyAddress>)>();

  /// Determines if the string is a valid Any address.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValid(
    ffi.Pointer<TWString> string,
    int coin,
  ) {
    return _TWAnyAddressIsValid(
      string,
      coin,
    );
  }

  late final _TWAnyAddressIsValidPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>, ffi.Int32)>>(
      'TWAnyAddressIsValid');
  late final _TWAnyAddressIsValid = _TWAnyAddressIsValidPtr.asFunction<
      bool Function(ffi.Pointer<TWString>, int)>();

  /// Determines if the string is a valid Any address with the given hrp.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param hrp explicit given hrp of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidBech32(
    ffi.Pointer<TWString> string,
    int coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressIsValidBech32(
      string,
      coin,
      hrp,
    );
  }

  late final _TWAnyAddressIsValidBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWAnyAddressIsValidBech32');
  late final _TWAnyAddressIsValidBech32 =
      _TWAnyAddressIsValidBech32Ptr.asFunction<
          bool Function(ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Determines if the string is a valid Any address with the given SS58 network prefix.
  ///
  /// \param string address to validate.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the given address.
  /// \return bool indicating if the address is valid.
  bool TWAnyAddressIsValidSS58(
    ffi.Pointer<TWString> string,
    int coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressIsValidSS58(
      string,
      coin,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressIsValidSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Uint32)>>('TWAnyAddressIsValidSS58');
  late final _TWAnyAddressIsValidSS58 = _TWAnyAddressIsValidSS58Ptr.asFunction<
      bool Function(ffi.Pointer<TWString>, int, int)>();

  /// Creates an address from a string representation and a coin type. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithString(
    ffi.Pointer<TWString> string,
    int coin,
  ) {
    return _TWAnyAddressCreateWithString(
      string,
      coin,
    );
  }

  late final _TWAnyAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>,
              ffi.Int32)>>('TWAnyAddressCreateWithString');
  late final _TWAnyAddressCreateWithString =
      _TWAnyAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, int)>();

  /// Creates an bech32 address from a string representation, a coin type and the given hrp. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32(
    ffi.Pointer<TWString> string,
    int coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressCreateBech32(
      string,
      coin,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWAnyAddressCreateBech32');
  late final _TWAnyAddressCreateBech32 =
      _TWAnyAddressCreateBech32Ptr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Creates an SS58 address from a string representation, a coin type and the given ss58Prefix. Must be deleted with TWAnyAddressDelete after use.
  ///
  /// \param string address to create.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if address and coin are invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58(
    ffi.Pointer<TWString> string,
    int coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58(
      string,
      coin,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Uint32)>>('TWAnyAddressCreateSS58');
  late final _TWAnyAddressCreateSS58 = _TWAnyAddressCreateSS58Ptr.asFunction<
      ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWString>, int, int)>();

  /// Creates an address from a public key.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int coin,
  ) {
    return _TWAnyAddressCreateWithPublicKey(
      publicKey,
      coin,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Int32)>>('TWAnyAddressCreateWithPublicKey');
  late final _TWAnyAddressCreateWithPublicKey =
      _TWAnyAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Creates an address from a public key and derivation option.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param derivation the custom derivation to use.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyDerivation(
    ffi.Pointer<TWPublicKey> publicKey,
    int coin,
    int derivation,
  ) {
    return _TWAnyAddressCreateWithPublicKeyDerivation(
      publicKey,
      coin,
      derivation,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.Int32,
              ffi.Int32)>>('TWAnyAddressCreateWithPublicKeyDerivation');
  late final _TWAnyAddressCreateWithPublicKeyDerivation =
      _TWAnyAddressCreateWithPublicKeyDerivationPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates an bech32 address from a public key and a given hrp.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param hrp hrp of the address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateBech32WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int coin,
    ffi.Pointer<TWString> hrp,
  ) {
    return _TWAnyAddressCreateBech32WithPublicKey(
      publicKey,
      coin,
      hrp,
    );
  }

  late final _TWAnyAddressCreateBech32WithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>,
              ffi.Int32,
              ffi.Pointer<TWString>)>>('TWAnyAddressCreateBech32WithPublicKey');
  late final _TWAnyAddressCreateBech32WithPublicKey =
      _TWAnyAddressCreateBech32WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, ffi.Pointer<TWString>)>();

  /// Creates an SS58 address from a public key and a given ss58Prefix.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param coin coin type of the address.
  /// \param ss58Prefix ss58Prefix of the SS58 address.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateSS58WithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int coin,
    int ss58Prefix,
  ) {
    return _TWAnyAddressCreateSS58WithPublicKey(
      publicKey,
      coin,
      ss58Prefix,
    );
  }

  late final _TWAnyAddressCreateSS58WithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Int32, ffi.Uint32)>>('TWAnyAddressCreateSS58WithPublicKey');
  late final _TWAnyAddressCreateSS58WithPublicKey =
      _TWAnyAddressCreateSS58WithPublicKeyPtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(
              ffi.Pointer<TWPublicKey>, int, int)>();

  /// Creates a Filecoin address from a public key and a given address type.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param filecoinAddressType Filecoin address type.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
    ffi.Pointer<TWPublicKey> publicKey,
    int filecoinAddressType,
  ) {
    return _TWAnyAddressCreateWithPublicKeyFilecoinAddressType(
      publicKey,
      filecoinAddressType,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWAnyAddress> Function(
                  ffi.Pointer<TWPublicKey>, ffi.Int32)>>(
      'TWAnyAddressCreateWithPublicKeyFilecoinAddressType');
  late final _TWAnyAddressCreateWithPublicKeyFilecoinAddressType =
      _TWAnyAddressCreateWithPublicKeyFilecoinAddressTypePtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Creates a Firo address from a public key and a given address type.
  ///
  /// \param publicKey derivates the address from the public key.
  /// \param firoAddressType Firo address type.
  /// \return TWAnyAddress pointer or nullptr if public key is invalid.
  ffi.Pointer<TWAnyAddress> TWAnyAddressCreateWithPublicKeyFiroAddressType(
    ffi.Pointer<TWPublicKey> publicKey,
    int firoAddressType,
  ) {
    return _TWAnyAddressCreateWithPublicKeyFiroAddressType(
      publicKey,
      firoAddressType,
    );
  }

  late final _TWAnyAddressCreateWithPublicKeyFiroAddressTypePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Int32)>>('TWAnyAddressCreateWithPublicKeyFiroAddressType');
  late final _TWAnyAddressCreateWithPublicKeyFiroAddressType =
      _TWAnyAddressCreateWithPublicKeyFiroAddressTypePtr.asFunction<
          ffi.Pointer<TWAnyAddress> Function(ffi.Pointer<TWPublicKey>, int)>();

  /// Deletes an address.
  ///
  /// \param address address to delete.
  void TWAnyAddressDelete(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDelete(
      address,
    );
  }

  late final _TWAnyAddressDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAnyAddress>)>>(
          'TWAnyAddressDelete');
  late final _TWAnyAddressDelete = _TWAnyAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns the address string representation.
  ///
  /// \param address address to get the string representation of.
  ffi.Pointer<TWString> TWAnyAddressDescription(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressDescription(
      address,
    );
  }

  late final _TWAnyAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressDescription');
  late final _TWAnyAddressDescription = _TWAnyAddressDescriptionPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns coin type of address.
  ///
  /// \param address address to get the coin type of.
  int TWAnyAddressCoin(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressCoin(
      address,
    );
  }

  late final _TWAnyAddressCoinPtr = _lookup<
          ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<TWAnyAddress>)>>(
      'TWAnyAddressCoin');
  late final _TWAnyAddressCoin = _TWAnyAddressCoinPtr.asFunction<
      int Function(ffi.Pointer<TWAnyAddress>)>();

  /// Returns underlaying data (public key or key hash)
  ///
  /// \param address address to get the data of.
  ffi.Pointer<TWData> TWAnyAddressData(
    ffi.Pointer<TWAnyAddress> address,
  ) {
    return _TWAnyAddressData(
      address,
    );
  }

  late final _TWAnyAddressDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWAnyAddress>)>>('TWAnyAddressData');
  late final _TWAnyAddressData = _TWAnyAddressDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWAnyAddress>)>();

  /// Parses the given ECDSA signature from ASN.1 DER encoded bytes.
  ///
  /// \param encoded The ASN.1 DER encoded signature.
  /// \return The ECDSA signature standard binary representation: RS, where R - 32 byte array, S - 32 byte array.
  ffi.Pointer<TWData1> TWAsnParserEcdsaSignatureFromDer(
    ffi.Pointer<TWData1> encoded,
  ) {
    return _TWAsnParserEcdsaSignatureFromDer(
      encoded,
    );
  }

  late final _TWAsnParserEcdsaSignatureFromDerPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWAsnParserEcdsaSignatureFromDer');
  late final _TWAsnParserEcdsaSignatureFromDer =
      _TWAsnParserEcdsaSignatureFromDerPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Builds a THORChainSwap transaction input.
  ///
  /// \param input The serialized data of SwapInput.
  /// \return The serialized data of SwapOutput.
  ffi.Pointer<TWData1> TWTHORChainSwapBuildSwap(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWTHORChainSwapBuildSwap(
      input,
    );
  }

  late final _TWTHORChainSwapBuildSwapPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWTHORChainSwapBuildSwap');
  late final _TWTHORChainSwapBuildSwap = _TWTHORChainSwapBuildSwapPtr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Encodes data as a Base58 string, including the checksum.
  ///
  /// \param data The data to encode.
  /// \return the encoded Base58 string with checksum.
  ffi.Pointer<TWString1> TWBase58Encode(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBase58Encode(
      data,
    );
  }

  late final _TWBase58EncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBase58Encode');
  late final _TWBase58Encode = _TWBase58EncodePtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Encodes data as a Base58 string, not including the checksum.
  ///
  /// \param data The data to encode.
  /// \return then encoded Base58 string without checksum.
  ffi.Pointer<TWString1> TWBase58EncodeNoCheck(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBase58EncodeNoCheck(
      data,
    );
  }

  late final _TWBase58EncodeNoCheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBase58EncodeNoCheck');
  late final _TWBase58EncodeNoCheck = _TWBase58EncodeNoCheckPtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Decodes a Base58 string, checking the checksum. Returns null if the string is not a valid Base58 string.
  ///
  /// \param string The Base58 string to decode.
  /// \return the decoded data, null if the string is not a valid Base58 string with checksum.
  ffi.Pointer<TWData1> TWBase58Decode(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBase58Decode(
      string,
    );
  }

  late final _TWBase58DecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBase58Decode');
  late final _TWBase58Decode = _TWBase58DecodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Decodes a Base58 string, w/o checking the checksum. Returns null if the string is not a valid Base58 string.
  ///
  /// \param string The Base58 string to decode.
  /// \return the decoded data, null if the string is not a valid Base58 string without checksum.
  ffi.Pointer<TWData1> TWBase58DecodeNoCheck(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBase58DecodeNoCheck(
      string,
    );
  }

  late final _TWBase58DecodeNoCheckPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBase58DecodeNoCheck');
  late final _TWBase58DecodeNoCheck = _TWBase58DecodeNoCheckPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Signs an arbitrary message to prove ownership of an address for off-chain services.
  /// https://github.com/ton-foundation/specs/blob/main/specs/wtf-0002.md
  ///
  /// \param private_key: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input null is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWTONMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWTONMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWTONMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>)>>('TWTONMessageSignerSignMessage');
  late final _TWTONMessageSignerSignMessage =
      _TWTONMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Calculates the minimum ADA amount needed for a UTXO.
  ///
  /// \deprecated consider using `TWCardanoOutputMinAdaAmount` instead.
  /// \see reference https://docs.cardano.org/native-tokens/minimum-ada-value-requirement
  /// \param tokenBundle serialized data of TW.Cardano.Proto.TokenBundle.
  /// \return the minimum ADA amount.
  int TWCardanoMinAdaAmount(
    ffi.Pointer<TWData1> tokenBundle,
  ) {
    return _TWCardanoMinAdaAmount(
      tokenBundle,
    );
  }

  late final _TWCardanoMinAdaAmountPtr =
      _lookup<ffi.NativeFunction<ffi.Uint64 Function(ffi.Pointer<TWData1>)>>(
          'TWCardanoMinAdaAmount');
  late final _TWCardanoMinAdaAmount = _TWCardanoMinAdaAmountPtr.asFunction<
      int Function(ffi.Pointer<TWData1>)>();

  /// Calculates the minimum ADA amount needed for an output.
  ///
  /// \see reference https://docs.cardano.org/native-tokens/minimum-ada-value-requirement
  /// \param toAddress valid destination address, as string.
  /// \param tokenBundle serialized data of TW.Cardano.Proto.TokenBundle.
  /// \param coinsPerUtxoByte cost per one byte of a serialized UTXO (Base-10 decimal string).
  /// \return the minimum ADA amount (Base-10 decimal string).
  ffi.Pointer<TWString1> TWCardanoOutputMinAdaAmount(
    ffi.Pointer<TWString1> toAddress,
    ffi.Pointer<TWData1> tokenBundle,
    ffi.Pointer<TWString1> coinsPerUtxoByte,
  ) {
    return _TWCardanoOutputMinAdaAmount(
      toAddress,
      tokenBundle,
      coinsPerUtxoByte,
    );
  }

  late final _TWCardanoOutputMinAdaAmountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWCardanoOutputMinAdaAmount');
  late final _TWCardanoOutputMinAdaAmount =
      _TWCardanoOutputMinAdaAmountPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Return the staking address associated to (contained in) this address. Must be a Base address.
  /// Empty string is returned on error. Result must be freed.
  /// \param baseAddress A valid base address, as string.
  /// \return the associated staking (reward) address, as string, or empty string on error.
  ffi.Pointer<TWString1> TWCardanoGetStakingAddress(
    ffi.Pointer<TWString1> baseAddress,
  ) {
    return _TWCardanoGetStakingAddress(
      baseAddress,
    );
  }

  late final _TWCardanoGetStakingAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>)>>('TWCardanoGetStakingAddress');
  late final _TWCardanoGetStakingAddress = _TWCardanoGetStakingAddressPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Return the legacy(byron) address.
  /// \param publicKey A valid public key with TWPublicKeyTypeED25519Cardano type.
  /// \return the legacy(byron) address, as string, or empty string on error.
  ffi.Pointer<TWString1> TWCardanoGetByronAddress(
    ffi.Pointer<TWPublicKey> publicKey,
  ) {
    return _TWCardanoGetByronAddress(
      publicKey,
    );
  }

  late final _TWCardanoGetByronAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPublicKey>)>>('TWCardanoGetByronAddress');
  late final _TWCardanoGetByronAddress = _TWCardanoGetByronAddressPtr
      .asFunction<ffi.Pointer<TWString1> Function(ffi.Pointer<TWPublicKey>)>();

  /// Creates a new Index with a value and hardened flag.
  /// Must be deleted with TWDerivationPathIndexDelete after use.
  ///
  /// \param value Index value
  /// \param hardened Indicates if the Index is hardened.
  /// \return A new Index.
  ffi.Pointer<TWDerivationPathIndex> TWDerivationPathIndexCreate(
    int value,
    bool hardened,
  ) {
    return _TWDerivationPathIndexCreate(
      value,
      hardened,
    );
  }

  late final _TWDerivationPathIndexCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWDerivationPathIndex> Function(
              ffi.Uint32, ffi.Bool)>>('TWDerivationPathIndexCreate');
  late final _TWDerivationPathIndexCreate = _TWDerivationPathIndexCreatePtr
      .asFunction<ffi.Pointer<TWDerivationPathIndex> Function(int, bool)>();

  /// Deletes an Index.
  ///
  /// \param index Index to delete.
  void TWDerivationPathIndexDelete(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexDelete(
      index,
    );
  }

  late final _TWDerivationPathIndexDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexDelete');
  late final _TWDerivationPathIndexDelete = _TWDerivationPathIndexDeletePtr
      .asFunction<void Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns numeric value of an Index.
  ///
  /// \param index Index to get the numeric value of.
  int TWDerivationPathIndexValue(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexValue(
      index,
    );
  }

  late final _TWDerivationPathIndexValuePtr = _lookup<
          ffi.NativeFunction<
              ffi.Uint32 Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexValue');
  late final _TWDerivationPathIndexValue = _TWDerivationPathIndexValuePtr
      .asFunction<int Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns hardened flag of an Index.
  ///
  /// \param index Index to get hardened flag.
  /// \return true if hardened, false otherwise.
  bool TWDerivationPathIndexHardened(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexHardened(
      index,
    );
  }

  late final _TWDerivationPathIndexHardenedPtr = _lookup<
          ffi.NativeFunction<
              ffi.Bool Function(ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexHardened');
  late final _TWDerivationPathIndexHardened = _TWDerivationPathIndexHardenedPtr
      .asFunction<bool Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Returns the string description of a derivation path index.
  ///
  /// \param path Index to get the address of.
  /// \return The string description of the derivation path index.
  ffi.Pointer<TWString> TWDerivationPathIndexDescription(
    ffi.Pointer<TWDerivationPathIndex> index,
  ) {
    return _TWDerivationPathIndexDescription(
      index,
    );
  }

  late final _TWDerivationPathIndexDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWDerivationPathIndex>)>>(
      'TWDerivationPathIndexDescription');
  late final _TWDerivationPathIndexDescription =
      _TWDerivationPathIndexDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWDerivationPathIndex>)>();

  /// Computes WebAuthn message hash to be signed with secp256p1 private key.
  ///
  /// \param authenticator_data The authenticator data in hex format.
  /// \param client_data_json The client data JSON string with a challenge.
  /// \return WebAuthn message hash.
  ffi.Pointer<TWData> TWWebAuthnSolidityGetMessageHash(
    ffi.Pointer<TWString> authenticatorData,
    ffi.Pointer<TWString> clientDataJson,
  ) {
    return _TWWebAuthnSolidityGetMessageHash(
      authenticatorData,
      clientDataJson,
    );
  }

  late final _TWWebAuthnSolidityGetMessageHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWWebAuthnSolidityGetMessageHash');
  late final _TWWebAuthnSolidityGetMessageHash =
      _TWWebAuthnSolidityGetMessageHashPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Converts the original ASN-encoded signature from webauthn to the format accepted by Barz
  ///
  /// \param authenticator_data The authenticator data in hex format.
  /// \param client_data_json The client data JSON string with a challenge.
  /// \param der_signature original ASN-encoded signature from webauthn.
  /// \return WebAuthn ABI-encoded data.
  ffi.Pointer<TWData> TWWebAuthnSolidityGetFormattedSignature(
    ffi.Pointer<TWString> authenticatorData,
    ffi.Pointer<TWString> clientDataJson,
    ffi.Pointer<TWData> derSignature,
  ) {
    return _TWWebAuthnSolidityGetFormattedSignature(
      authenticatorData,
      clientDataJson,
      derSignature,
    );
  }

  late final _TWWebAuthnSolidityGetFormattedSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>)>>('TWWebAuthnSolidityGetFormattedSignature');
  late final _TWWebAuthnSolidityGetFormattedSignature =
      _TWWebAuthnSolidityGetFormattedSignaturePtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>)>();

  /// Builds a LiquidStaking transaction input.
  ///
  /// \param input The serialized data of LiquidStakingInput.
  /// \return The serialized data of LiquidStakingOutput.
  ffi.Pointer<TWData1> TWLiquidStakingBuildRequest(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWLiquidStakingBuildRequest(
      input,
    );
  }

  late final _TWLiquidStakingBuildRequestPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWLiquidStakingBuildRequest');
  late final _TWLiquidStakingBuildRequest = _TWLiquidStakingBuildRequestPtr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Converts a TON user address into a Bag of Cells (BoC) with a single root Cell.
  /// The function is mostly used to request a Jetton user address via `get_wallet_address` RPC.
  /// https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user
  ///
  /// \param address Address to be converted into a Bag Of Cells (BoC).
  /// \return Pointer to a base64 encoded Bag Of Cells (BoC). Null if invalid address provided.
  ffi.Pointer<TWString> TWTONAddressConverterToBoc(
    ffi.Pointer<TWString> address,
  ) {
    return _TWTONAddressConverterToBoc(
      address,
    );
  }

  late final _TWTONAddressConverterToBocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWTONAddressConverterToBoc');
  late final _TWTONAddressConverterToBoc = _TWTONAddressConverterToBocPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Parses a TON address from a Bag of Cells (BoC) with a single root Cell.
  /// The function is mostly used to parse a Jetton user address received on `get_wallet_address` RPC.
  /// https://docs.ton.org/develop/dapps/asset-processing/jettons#retrieving-jetton-wallet-addresses-for-a-given-user
  ///
  /// \param boc Base64 encoded Bag Of Cells (BoC).
  /// \return Pointer to a Jetton address.
  ffi.Pointer<TWString> TWTONAddressConverterFromBoc(
    ffi.Pointer<TWString> boc,
  ) {
    return _TWTONAddressConverterFromBoc(
      boc,
    );
  }

  late final _TWTONAddressConverterFromBocPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWTONAddressConverterFromBoc');
  late final _TWTONAddressConverterFromBoc = _TWTONAddressConverterFromBocPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Converts any TON address format to user friendly with the given parameters.
  ///
  /// \param address raw or user-friendly address to be converted.
  /// \param bounceable whether the result address should be bounceable.
  /// \param testnet whether the result address should be testnet.
  /// \return user-friendly address str.
  ffi.Pointer<TWString> TWTONAddressConverterToUserFriendly(
    ffi.Pointer<TWString> address,
    bool bounceable,
    bool testnet,
  ) {
    return _TWTONAddressConverterToUserFriendly(
      address,
      bounceable,
      testnet,
    );
  }

  late final _TWTONAddressConverterToUserFriendlyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>, ffi.Bool,
              ffi.Bool)>>('TWTONAddressConverterToUserFriendly');
  late final _TWTONAddressConverterToUserFriendly =
      _TWTONAddressConverterToUserFriendlyPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>, bool, bool)>();

  /// Parses the WalletConnect signing request as a `SigningInput`.
  ///
  /// \param coin The given coin type to plan the transaction for.
  /// \param input The serialized data of a `WalletConnect::Proto::ParseRequestInput` proto object.
  /// \return The serialized data of `WalletConnect::Proto::ParseRequestOutput` proto object.
  ffi.Pointer<TWData> TWWalletConnectRequestParse(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWWalletConnectRequestParse(
      coin,
      input,
    );
  }

  late final _TWWalletConnectRequestParsePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWWalletConnectRequestParse');
  late final _TWWalletConnectRequestParse = _TWWalletConnectRequestParsePtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWTronMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWTronMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWTronMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>)>>('TWTronMessageSignerSignMessage');
  late final _TWTronMessageSignerSignMessage =
      _TWTronMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix)
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWTronMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWTronMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWTronMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWTronMessageSignerVerifyMessage');
  late final _TWTronMessageSignerVerifyMessage =
      _TWTronMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Converts attestation object to the public key on P256 curve
  ///
  /// \param attestationObject Attestation object retrieved from webuthn.get method
  /// \return Public key.
  ffi.Pointer<TWPublicKey> TWWebAuthnGetPublicKey(
    ffi.Pointer<TWData1> attestationObject,
  ) {
    return _TWWebAuthnGetPublicKey(
      attestationObject,
    );
  }

  late final _TWWebAuthnGetPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPublicKey> Function(
              ffi.Pointer<TWData1>)>>('TWWebAuthnGetPublicKey');
  late final _TWWebAuthnGetPublicKey = _TWWebAuthnGetPublicKeyPtr.asFunction<
      ffi.Pointer<TWPublicKey> Function(ffi.Pointer<TWData1>)>();

  /// Uses ASN parser to extract r and s values from a webauthn signature
  ///
  /// \param signature ASN encoded webauthn signature: https://www.w3.org/TR/webauthn-2/#sctn-signature-attestation-types
  /// \return Concatenated r and s values.
  ffi.Pointer<TWData1> TWWebAuthnGetRSValues(
    ffi.Pointer<TWData1> signature,
  ) {
    return _TWWebAuthnGetRSValues(
      signature,
    );
  }

  late final _TWWebAuthnGetRSValuesPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWWebAuthnGetRSValues');
  late final _TWWebAuthnGetRSValues = _TWWebAuthnGetRSValuesPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Reconstructs the original message that was signed via P256 curve. Can be used for signature validation.
  ///
  /// \param authenticatorData Authenticator Data: https://www.w3.org/TR/webauthn-2/#authenticator-data
  /// \param clientDataJSON clientDataJSON: https://www.w3.org/TR/webauthn-2/#dom-authenticatorresponse-clientdatajson
  /// \return original messages.
  ffi.Pointer<TWData1> TWWebAuthnReconstructOriginalMessage(
    ffi.Pointer<TWData1> authenticatorData,
    ffi.Pointer<TWData1> clientDataJSON,
  ) {
    return _TWWebAuthnReconstructOriginalMessage(
      authenticatorData,
      clientDataJSON,
    );
  }

  late final _TWWebAuthnReconstructOriginalMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>)>>('TWWebAuthnReconstructOriginalMessage');
  late final _TWWebAuthnReconstructOriginalMessage =
      _TWWebAuthnReconstructOriginalMessagePtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>();

  /// Derives a key from a password and a salt using PBKDF2 + Sha256.
  ///
  /// \param password is the master password from which a derived key is generated
  /// \param salt is a sequence of bits, known as a cryptographic salt
  /// \param iterations is the number of iterations desired
  /// \param dkLen is the desired bit-length of the derived key
  /// \return the derived key data.
  ffi.Pointer<TWData1> TWPBKDF2HmacSha256(
    ffi.Pointer<TWData1> password,
    ffi.Pointer<TWData1> salt,
    int iterations,
    int dkLen,
  ) {
    return _TWPBKDF2HmacSha256(
      password,
      salt,
      iterations,
      dkLen,
    );
  }

  late final _TWPBKDF2HmacSha256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Uint32,
              ffi.Uint32)>>('TWPBKDF2HmacSha256');
  late final _TWPBKDF2HmacSha256 = _TWPBKDF2HmacSha256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>, int, int)>();

  /// Derives a key from a password and a salt using PBKDF2 + Sha512.
  ///
  /// \param password is the master password from which a derived key is generated
  /// \param salt is a sequence of bits, known as a cryptographic salt
  /// \param iterations is the number of iterations desired
  /// \param dkLen is the desired bit-length of the derived key
  /// \return the derived key data.
  ffi.Pointer<TWData1> TWPBKDF2HmacSha512(
    ffi.Pointer<TWData1> password,
    ffi.Pointer<TWData1> salt,
    int iterations,
    int dkLen,
  ) {
    return _TWPBKDF2HmacSha512(
      password,
      salt,
      iterations,
      dkLen,
    );
  }

  late final _TWPBKDF2HmacSha512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Uint32,
              ffi.Uint32)>>('TWPBKDF2HmacSha512');
  late final _TWPBKDF2HmacSha512 = _TWPBKDF2HmacSha512Ptr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>, int, int)>();

  /// Converts a Filecoin address to Ethereum.
  ///
  /// \param filecoinAddress: a Filecoin address.
  /// \returns the Ethereum address. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWFilecoinAddressConverterConvertToEthereum(
    ffi.Pointer<TWString1> filecoinAddress,
  ) {
    return _TWFilecoinAddressConverterConvertToEthereum(
      filecoinAddress,
    );
  }

  late final _TWFilecoinAddressConverterConvertToEthereumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>>(
      'TWFilecoinAddressConverterConvertToEthereum');
  late final _TWFilecoinAddressConverterConvertToEthereum =
      _TWFilecoinAddressConverterConvertToEthereumPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Converts an Ethereum address to Filecoin.
  ///
  /// \param ethAddress: an Ethereum address.
  /// \returns the Filecoin address. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWFilecoinAddressConverterConvertFromEthereum(
    ffi.Pointer<TWString1> ethAddress,
  ) {
    return _TWFilecoinAddressConverterConvertFromEthereum(
      ethAddress,
    );
  }

  late final _TWFilecoinAddressConverterConvertFromEthereumPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>>(
      'TWFilecoinAddressConverterConvertFromEthereum');
  late final _TWFilecoinAddressConverterConvertFromEthereum =
      _TWFilecoinAddressConverterConvertFromEthereumPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Determines if the given public key is valid or not.
  ///
  /// \param data *non-null* byte array.
  /// \return true if the public key is valid, false otherwise.
  bool TWCryptoBoxPublicKeyIsValid(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWCryptoBoxPublicKeyIsValid(
      data,
    );
  }

  late final _TWCryptoBoxPublicKeyIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWData1>)>>(
          'TWCryptoBoxPublicKeyIsValid');
  late final _TWCryptoBoxPublicKeyIsValid = _TWCryptoBoxPublicKeyIsValidPtr
      .asFunction<bool Function(ffi.Pointer<TWData1>)>();

  /// Create a `crypto_box` public key with the given block of data.
  ///
  /// \param data *non-null* byte array. Expected to have 32 bytes.
  /// \note Should be deleted with \tw_crypto_box_public_key_delete.
  /// \return Nullable pointer to Public Key.
  ffi.Pointer<TWCryptoBoxPublicKey> TWCryptoBoxPublicKeyCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWCryptoBoxPublicKeyCreateWithData(
      data,
    );
  }

  late final _TWCryptoBoxPublicKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(
              ffi.Pointer<TWData1>)>>('TWCryptoBoxPublicKeyCreateWithData');
  late final _TWCryptoBoxPublicKeyCreateWithData =
      _TWCryptoBoxPublicKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(ffi.Pointer<TWData1>)>();

  /// Returns the raw data of a given public-key.
  ///
  /// \param public_key *non-null* pointer to a public key.
  /// \return C-compatible result with a C-compatible byte array.
  ffi.Pointer<TWData1> TWCryptoBoxPublicKeyData(
    ffi.Pointer<TWCryptoBoxPublicKey> publicKey,
  ) {
    return _TWCryptoBoxPublicKeyData(
      publicKey,
    );
  }

  late final _TWCryptoBoxPublicKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWCryptoBoxPublicKey>)>>('TWCryptoBoxPublicKeyData');
  late final _TWCryptoBoxPublicKeyData =
      _TWCryptoBoxPublicKeyDataPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWCryptoBoxPublicKey>)>();

  /// Delete the given public key.
  ///
  /// \param public_key *non-null* pointer to public key.
  void TWCryptoBoxPublicKeyDelete(
    ffi.Pointer<TWCryptoBoxPublicKey> publicKey,
  ) {
    return _TWCryptoBoxPublicKeyDelete(
      publicKey,
    );
  }

  late final _TWCryptoBoxPublicKeyDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWCryptoBoxPublicKey>)>>(
      'TWCryptoBoxPublicKeyDelete');
  late final _TWCryptoBoxPublicKeyDelete = _TWCryptoBoxPublicKeyDeletePtr
      .asFunction<void Function(ffi.Pointer<TWCryptoBoxPublicKey>)>();

  /// Determines if the given secret key is valid or not.
  ///
  /// \param data *non-null* byte array.
  /// \return true if the secret key is valid, false otherwise.
  bool TWCryptoBoxSecretKeyIsValid(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWCryptoBoxSecretKeyIsValid(
      data,
    );
  }

  late final _TWCryptoBoxSecretKeyIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWData1>)>>(
          'TWCryptoBoxSecretKeyIsValid');
  late final _TWCryptoBoxSecretKeyIsValid = _TWCryptoBoxSecretKeyIsValidPtr
      .asFunction<bool Function(ffi.Pointer<TWData1>)>();

  /// Create a random secret key.
  ///
  /// \note Should be deleted with \tw_crypto_box_secret_key_delete.
  /// \return Nullable pointer to Private Key.
  ffi.Pointer<TWCryptoBoxSecretKey> TWCryptoBoxSecretKeyCreate() {
    return _TWCryptoBoxSecretKeyCreate();
  }

  late final _TWCryptoBoxSecretKeyCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWCryptoBoxSecretKey> Function()>>(
          'TWCryptoBoxSecretKeyCreate');
  late final _TWCryptoBoxSecretKeyCreate = _TWCryptoBoxSecretKeyCreatePtr
      .asFunction<ffi.Pointer<TWCryptoBoxSecretKey> Function()>();

  /// Create a `crypto_box` secret key with the given block of data.
  ///
  /// \param data *non-null* byte array. Expected to have 32 bytes.
  /// \note Should be deleted with \tw_crypto_box_secret_key_delete.
  /// \return Nullable pointer to Secret Key.
  ffi.Pointer<TWCryptoBoxSecretKey> TWCryptoBoxSecretKeyCreateWithData(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWCryptoBoxSecretKeyCreateWithData(
      data,
    );
  }

  late final _TWCryptoBoxSecretKeyCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWCryptoBoxSecretKey> Function(
              ffi.Pointer<TWData1>)>>('TWCryptoBoxSecretKeyCreateWithData');
  late final _TWCryptoBoxSecretKeyCreateWithData =
      _TWCryptoBoxSecretKeyCreateWithDataPtr.asFunction<
          ffi.Pointer<TWCryptoBoxSecretKey> Function(ffi.Pointer<TWData1>)>();

  /// Returns the public key associated with the given `key`.
  ///
  /// \param key *non-null* pointer to the private key.
  /// \return *non-null* pointer to the corresponding public key.
  ffi.Pointer<TWCryptoBoxPublicKey> TWCryptoBoxSecretKeyGetPublicKey(
    ffi.Pointer<TWCryptoBoxSecretKey> key,
  ) {
    return _TWCryptoBoxSecretKeyGetPublicKey(
      key,
    );
  }

  late final _TWCryptoBoxSecretKeyGetPublicKeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWCryptoBoxPublicKey> Function(
                  ffi.Pointer<TWCryptoBoxSecretKey>)>>(
      'TWCryptoBoxSecretKeyGetPublicKey');
  late final _TWCryptoBoxSecretKeyGetPublicKey =
      _TWCryptoBoxSecretKeyGetPublicKeyPtr.asFunction<
          ffi.Pointer<TWCryptoBoxPublicKey> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>)>();

  /// Returns the raw data of a given secret-key.
  ///
  /// \param secret_key *non-null* pointer to a secret key.
  /// \return C-compatible result with a C-compatible byte array.
  ffi.Pointer<TWData1> TWCryptoBoxSecretKeyData(
    ffi.Pointer<TWCryptoBoxSecretKey> secretKey,
  ) {
    return _TWCryptoBoxSecretKeyData(
      secretKey,
    );
  }

  late final _TWCryptoBoxSecretKeyDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>)>>('TWCryptoBoxSecretKeyData');
  late final _TWCryptoBoxSecretKeyData =
      _TWCryptoBoxSecretKeyDataPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWCryptoBoxSecretKey>)>();

  /// Delete the given secret `key`.
  ///
  /// \param key *non-null* pointer to secret key.
  void TWCryptoBoxSecretKeyDelete(
    ffi.Pointer<TWCryptoBoxSecretKey> key,
  ) {
    return _TWCryptoBoxSecretKeyDelete(
      key,
    );
  }

  late final _TWCryptoBoxSecretKeyDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWCryptoBoxSecretKey>)>>(
      'TWCryptoBoxSecretKeyDelete');
  late final _TWCryptoBoxSecretKeyDelete = _TWCryptoBoxSecretKeyDeletePtr
      .asFunction<void Function(ffi.Pointer<TWCryptoBoxSecretKey>)>();

  /// Decode a Base32 input with the given alphabet
  ///
  /// \param string Encoded base32 input to be decoded
  /// \param alphabet Decode with the given alphabet, if nullptr ALPHABET_RFC4648 is used by default
  /// \return The decoded data, can be null.
  /// \note ALPHABET_RFC4648 doesn't support padding in the default alphabet
  ffi.Pointer<TWData1> TWBase32DecodeWithAlphabet(
    ffi.Pointer<TWString1> string,
    ffi.Pointer<TWString1> alphabet,
  ) {
    return _TWBase32DecodeWithAlphabet(
      string,
      alphabet,
    );
  }

  late final _TWBase32DecodeWithAlphabetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWBase32DecodeWithAlphabet');
  late final _TWBase32DecodeWithAlphabet =
      _TWBase32DecodeWithAlphabetPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Decode a Base32 input with the default alphabet (ALPHABET_RFC4648)
  ///
  /// \param string Encoded input to be decoded
  /// \return The decoded data
  /// \note Call TWBase32DecodeWithAlphabet with nullptr.
  ffi.Pointer<TWData1> TWBase32Decode(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBase32Decode(
      string,
    );
  }

  late final _TWBase32DecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBase32Decode');
  late final _TWBase32Decode = _TWBase32DecodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Encode an input to Base32 with the given alphabet
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \param alphabet Encode with the given alphabet, if nullptr ALPHABET_RFC4648 is used by default
  /// \return The encoded data
  /// \note ALPHABET_RFC4648 doesn't support padding in the default alphabet
  ffi.Pointer<TWString1> TWBase32EncodeWithAlphabet(
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWString1> alphabet,
  ) {
    return _TWBase32EncodeWithAlphabet(
      data,
      alphabet,
    );
  }

  late final _TWBase32EncodeWithAlphabetPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWBase32EncodeWithAlphabet');
  late final _TWBase32EncodeWithAlphabet =
      _TWBase32EncodeWithAlphabetPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>)>();

  /// Encode an input to Base32 with the default alphabet (ALPHABET_RFC4648)
  ///
  /// \param data Data to be encoded (raw bytes)
  /// \return The encoded data
  /// \note Call TWBase32EncodeWithAlphabet with nullptr.
  ffi.Pointer<TWString1> TWBase32Encode(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBase32Encode(
      data,
    );
  }

  late final _TWBase32EncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBase32Encode');
  late final _TWBase32Encode = _TWBase32EncodePtr.asFunction<
      ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Decode a contract call (function input) according to an ABI json.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ContractCallDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ContractCallDecodingOutput` proto object.
  ffi.Pointer<TWData> TWEthereumAbiDecodeContractCall(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumAbiDecodeContractCall(
      coin,
      input,
    );
  }

  late final _TWEthereumAbiDecodeContractCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Int32,
              ffi.Pointer<TWData>)>>('TWEthereumAbiDecodeContractCall');
  late final _TWEthereumAbiDecodeContractCall =
      _TWEthereumAbiDecodeContractCallPtr.asFunction<
          ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Decode a function input or output data according to a given ABI.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ParamsDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ParamsDecodingOutput` proto object.
  ffi.Pointer<TWData> TWEthereumAbiDecodeParams(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumAbiDecodeParams(
      coin,
      input,
    );
  }

  late final _TWEthereumAbiDecodeParamsPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWEthereumAbiDecodeParams');
  late final _TWEthereumAbiDecodeParams = _TWEthereumAbiDecodeParamsPtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// /// Decodes an Eth ABI value according to a given type.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.ValueDecodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.ValueDecodingOutput` proto object.
  ffi.Pointer<TWData> TWEthereumAbiDecodeValue(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumAbiDecodeValue(
      coin,
      input,
    );
  }

  late final _TWEthereumAbiDecodeValuePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWEthereumAbiDecodeValue');
  late final _TWEthereumAbiDecodeValue = _TWEthereumAbiDecodeValuePtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Encode function to Eth ABI binary.
  ///
  /// \param coin EVM-compatible coin type.
  /// \param input The serialized data of `TW.EthereumAbi.Proto.FunctionEncodingInput`.
  /// \return The serialized data of a `TW.EthereumAbi.Proto.FunctionEncodingOutput` proto object.
  ffi.Pointer<TWData> TWEthereumAbiEncodeFunction(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWEthereumAbiEncodeFunction(
      coin,
      input,
    );
  }

  late final _TWEthereumAbiEncodeFunctionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWEthereumAbiEncodeFunction');
  late final _TWEthereumAbiEncodeFunction = _TWEthereumAbiEncodeFunctionPtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Encode function to Eth ABI binary
  ///
  /// \param fn Non-null Eth abi function
  /// \return Non-null encoded block of data
  ffi.Pointer<TWData> TWEthereumAbiEncode(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiEncode(
      fn,
    );
  }

  late final _TWEthereumAbiEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWEthereumAbiFunction>)>>('TWEthereumAbiEncode');
  late final _TWEthereumAbiEncode = _TWEthereumAbiEncodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Decode function output from Eth ABI binary, fill output parameters
  ///
  /// \param[in] fn Non-null Eth abi function
  /// \param[out] encoded Non-null block of data
  /// \return true if encoded have been filled correctly, false otherwise
  bool TWEthereumAbiDecodeOutput(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData> encoded,
  ) {
    return _TWEthereumAbiDecodeOutput(
      fn,
      encoded,
    );
  }

  late final _TWEthereumAbiDecodeOutputPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData>)>>('TWEthereumAbiDecodeOutput');
  late final _TWEthereumAbiDecodeOutput =
      _TWEthereumAbiDecodeOutputPtr.asFunction<
          bool Function(
              ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData>)>();

  /// Decode function call data to human readable json format, according to input abi json
  ///
  /// \param data Non-null block of data
  /// \param abi Non-null string
  /// \return Non-null json string function call data
  ffi.Pointer<TWString> TWEthereumAbiDecodeCall(
    ffi.Pointer<TWData> data,
    ffi.Pointer<TWString> abi,
  ) {
    return _TWEthereumAbiDecodeCall(
      data,
      abi,
    );
  }

  late final _TWEthereumAbiDecodeCallPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>)>>('TWEthereumAbiDecodeCall');
  late final _TWEthereumAbiDecodeCall = _TWEthereumAbiDecodeCallPtr.asFunction<
      ffi.Pointer<TWString> Function(
          ffi.Pointer<TWData>, ffi.Pointer<TWString>)>();

  /// Compute the hash of a struct, used for signing, according to EIP712 ("v4").
  /// Input is a Json object (as string), with following fields:
  /// - types: map of used struct types (see makeTypes())
  /// - primaryType: the type of the message (string)
  /// - domain: EIP712 domain specifier values
  /// - message: the message (object).
  /// Throws on error.
  /// Example input:
  /// R"({
  /// "types": {
  /// "EIP712Domain": [
  /// {"name": "name", "type": "string"},
  /// {"name": "version", "type": "string"},
  /// {"name": "chainId", "type": "uint256"},
  /// {"name": "verifyingContract", "type": "address"}
  /// ],
  /// "Person": [
  /// {"name": "name", "type": "string"},
  /// {"name": "wallet", "type": "address"}
  /// ]
  /// },
  /// "primaryType": "Person",
  /// "domain": {
  /// "name": "Ether Person",
  /// "version": "1",
  /// "chainId": 1,
  /// "verifyingContract": "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC"
  /// },
  /// "message": {
  /// "name": "Cow",
  /// "wallet": "CD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826"
  /// }
  /// })");
  /// On error, empty Data is returned.
  /// Returned data must be deleted (hint: use WRAPD() macro).
  ///
  /// \param messageJson Non-null json abi input
  /// \return Non-null block of data, encoded abi input
  ffi.Pointer<TWData> TWEthereumAbiEncodeTyped(
    ffi.Pointer<TWString> messageJson,
  ) {
    return _TWEthereumAbiEncodeTyped(
      messageJson,
    );
  }

  late final _TWEthereumAbiEncodeTypedPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>>(
      'TWEthereumAbiEncodeTyped');
  late final _TWEthereumAbiEncodeTyped = _TWEthereumAbiEncodeTypedPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWString>)>();

  /// Get function signature from Ethereum ABI json
  ///
  /// \param abi The function ABI json string, for example: {"inputs":[{"internalType":"bool","name":"arg1","type":"bool"}],"name":"fun1","outputs":[],"stateMutability":"nonpayable","type":"function"}
  /// \return the function type signature, of the form "baz(int32,uint256)", null if the abi is invalid.
  ffi.Pointer<TWString> TWEthereumAbiGetFunctionSignature(
    ffi.Pointer<TWString> abi,
  ) {
    return _TWEthereumAbiGetFunctionSignature(
      abi,
    );
  }

  late final _TWEthereumAbiGetFunctionSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWEthereumAbiGetFunctionSignature');
  late final _TWEthereumAbiGetFunctionSignature =
      _TWEthereumAbiGetFunctionSignaturePtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Implement format input as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param message message to format e.g: Hello, World
  /// \param dAppUrl the app url, e.g: testUrl
  /// \returns the formatted message as a string
  ffi.Pointer<TWString1> TWTezosMessageSignerFormatMessage(
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> url,
  ) {
    return _TWTezosMessageSignerFormatMessage(
      message,
      url,
    );
  }

  late final _TWTezosMessageSignerFormatMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWTezosMessageSignerFormatMessage');
  late final _TWTezosMessageSignerFormatMessage =
      _TWTezosMessageSignerFormatMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Implement input to payload as described in: https://tezostaquito.io/docs/signing/
  ///
  /// \param message formatted message to be turned into an hex payload
  /// \return the hexpayload of the formated message as a hex string
  ffi.Pointer<TWString1> TWTezosMessageSignerInputToPayload(
    ffi.Pointer<TWString1> message,
  ) {
    return _TWTezosMessageSignerInputToPayload(
      message,
    );
  }

  late final _TWTezosMessageSignerInputToPayloadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>)>>('TWTezosMessageSignerInputToPayload');
  late final _TWTezosMessageSignerInputToPayload =
      _TWTezosMessageSignerInputToPayloadPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>)>();

  /// Sign a message as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom message payload (hex) which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWTezosMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWTezosMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWTezosMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>)>>('TWTezosMessageSignerSignMessage');
  late final _TWTezosMessageSignerSignMessage =
      _TWTezosMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Verify signature for a message as described in https://tezostaquito.io/docs/signing/
  ///
  /// \param pubKey: pubKey that will verify the message from the signature
  /// \param message: the message signed as a payload (hex)
  /// \param signature: in Base58-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be verified from the signature
  bool TWTezosMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWTezosMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWTezosMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWTezosMessageSignerVerifyMessage');
  late final _TWTezosMessageSignerVerifyMessage =
      _TWTezosMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _TWStellarPassphrase_Stellar =
      _lookup<ffi.Pointer<ffi.Char>>('TWStellarPassphrase_Stellar');

  ffi.Pointer<ffi.Char> get TWStellarPassphrase_Stellar =>
      _TWStellarPassphrase_Stellar.value;

  set TWStellarPassphrase_Stellar(ffi.Pointer<ffi.Char> value) =>
      _TWStellarPassphrase_Stellar.value = value;

  late final ffi.Pointer<ffi.Pointer<ffi.Char>> _TWStellarPassphrase_Kin =
      _lookup<ffi.Pointer<ffi.Char>>('TWStellarPassphrase_Kin');

  ffi.Pointer<ffi.Char> get TWStellarPassphrase_Kin =>
      _TWStellarPassphrase_Kin.value;

  set TWStellarPassphrase_Kin(ffi.Pointer<ffi.Char> value) =>
      _TWStellarPassphrase_Kin.value = value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA1Length =
      _lookup<ffi.Size>('TWHashSHA1Length');

  int get TWHashSHA1Length => _TWHashSHA1Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA256Length =
      _lookup<ffi.Size>('TWHashSHA256Length');

  int get TWHashSHA256Length => _TWHashSHA256Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashSHA512Length =
      _lookup<ffi.Size>('TWHashSHA512Length');

  int get TWHashSHA512Length => _TWHashSHA512Length.value;

  late final ffi.Pointer<ffi.Size> _TWHashRipemdLength =
      _lookup<ffi.Size>('TWHashRipemdLength');

  int get TWHashRipemdLength => _TWHashRipemdLength.value;

  /// Computes the SHA1 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA1 block of data
  ffi.Pointer<TWData1> TWHashSHA1(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA1(
      data,
    );
  }

  late final _TWHashSHA1Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>('TWHashSHA1');
  late final _TWHashSHA1 = _TWHashSHA1Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256 block of data
  ffi.Pointer<TWData1> TWHashSHA256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA256(
      data,
    );
  }

  late final _TWHashSHA256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>('TWHashSHA256');
  late final _TWHashSHA256 = _TWHashSHA256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA512 block of data
  ffi.Pointer<TWData1> TWHashSHA512(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA512(
      data,
    );
  }

  late final _TWHashSHA512Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>('TWHashSHA512');
  late final _TWHashSHA512 = _TWHashSHA512Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA512_256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA512_256 block of data
  ffi.Pointer<TWData1> TWHashSHA512_256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA512_256(
      data,
    );
  }

  late final _TWHashSHA512_256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA512_256');
  late final _TWHashSHA512_256 = _TWHashSHA512_256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Keccak256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Keccak256 block of data
  ffi.Pointer<TWData1> TWHashKeccak256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashKeccak256(
      data,
    );
  }

  late final _TWHashKeccak256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashKeccak256');
  late final _TWHashKeccak256 = _TWHashKeccak256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Keccak512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Keccak512 block of data
  ffi.Pointer<TWData1> TWHashKeccak512(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashKeccak512(
      data,
    );
  }

  late final _TWHashKeccak512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashKeccak512');
  late final _TWHashKeccak512 = _TWHashKeccak512Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA3_256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_256 block of data
  ffi.Pointer<TWData1> TWHashSHA3_256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA3_256(
      data,
    );
  }

  late final _TWHashSHA3_256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA3_256');
  late final _TWHashSHA3_256 = _TWHashSHA3_256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA3_512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_512 block of data
  ffi.Pointer<TWData1> TWHashSHA3_512(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA3_512(
      data,
    );
  }

  late final _TWHashSHA3_512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA3_512');
  late final _TWHashSHA3_512 = _TWHashSHA3_512Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed RIPEMD block of data
  ffi.Pointer<TWData1> TWHashRIPEMD(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashRIPEMD(
      data,
    );
  }

  late final _TWHashRIPEMDPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>('TWHashRIPEMD');
  late final _TWHashRIPEMD = _TWHashRIPEMDPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Blake256 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256 block of data
  ffi.Pointer<TWData1> TWHashBlake256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashBlake256(
      data,
    );
  }

  late final _TWHashBlake256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashBlake256');
  late final _TWHashBlake256 = _TWHashBlake256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Blake2b of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake2b block of data
  ffi.Pointer<TWData1> TWHashBlake2b(
    ffi.Pointer<TWData1> data,
    int size,
  ) {
    return _TWHashBlake2b(
      data,
      size,
    );
  }

  late final _TWHashBlake2bPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>, ffi.Size)>>('TWHashBlake2b');
  late final _TWHashBlake2b = _TWHashBlake2bPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>, int)>();

  /// Computes the Groestl512 of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Groestl512 block of data
  ffi.Pointer<TWData1> TWHashBlake2bPersonal(
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWData1> personal,
    int outlen,
  ) {
    return _TWHashBlake2bPersonal(
      data,
      personal,
      outlen,
    );
  }

  late final _TWHashBlake2bPersonalPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>, ffi.Size)>>('TWHashBlake2bPersonal');
  late final _TWHashBlake2bPersonal = _TWHashBlake2bPersonalPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>, int)>();

  ffi.Pointer<TWData1> TWHashGroestl512(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashGroestl512(
      data,
    );
  }

  late final _TWHashGroestl512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashGroestl512');
  late final _TWHashGroestl512 = _TWHashGroestl512Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA256D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256D block of data
  ffi.Pointer<TWData1> TWHashSHA256SHA256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA256SHA256(
      data,
    );
  }

  late final _TWHashSHA256SHA256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA256SHA256');
  late final _TWHashSHA256SHA256 = _TWHashSHA256SHA256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA256RIPEMD block of data
  ffi.Pointer<TWData1> TWHashSHA256RIPEMD(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA256RIPEMD(
      data,
    );
  }

  late final _TWHashSHA256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA256RIPEMD');
  late final _TWHashSHA256RIPEMD = _TWHashSHA256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the SHA3_256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed SHA3_256RIPEMD block of data
  ffi.Pointer<TWData1> TWHashSHA3_256RIPEMD(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashSHA3_256RIPEMD(
      data,
    );
  }

  late final _TWHashSHA3_256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashSHA3_256RIPEMD');
  late final _TWHashSHA3_256RIPEMD = _TWHashSHA3_256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Blake256D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256D block of data
  ffi.Pointer<TWData1> TWHashBlake256Blake256(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashBlake256Blake256(
      data,
    );
  }

  late final _TWHashBlake256Blake256Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashBlake256Blake256');
  late final _TWHashBlake256Blake256 = _TWHashBlake256Blake256Ptr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Blake256RIPEMD of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Blake256RIPEMD block of data
  ffi.Pointer<TWData1> TWHashBlake256RIPEMD(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashBlake256RIPEMD(
      data,
    );
  }

  late final _TWHashBlake256RIPEMDPtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashBlake256RIPEMD');
  late final _TWHashBlake256RIPEMD = _TWHashBlake256RIPEMDPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Computes the Groestl512D of a block of data.
  ///
  /// \param data Non-null block of data
  /// \return Non-null computed Groestl512D block of data
  ffi.Pointer<TWData1> TWHashGroestl512Groestl512(
    ffi.Pointer<TWData1> data,
  ) {
    return _TWHashGroestl512Groestl512(
      data,
    );
  }

  late final _TWHashGroestl512Groestl512Ptr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWHashGroestl512Groestl512');
  late final _TWHashGroestl512Groestl512 = _TWHashGroestl512Groestl512Ptr
      .asFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();

  /// Loads a key from a file.
  ///
  /// \param path filepath to the key as a non-null string
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be load, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyLoad(
    ffi.Pointer<TWString> path,
  ) {
    return _TWStoredKeyLoad(
      path,
    );
  }

  late final _TWStoredKeyLoadPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>)>>('TWStoredKeyLoad');
  late final _TWStoredKeyLoad = _TWStoredKeyLoadPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKey(
    ffi.Pointer<TWData> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
  ) {
    return _TWStoredKeyImportPrivateKey(
      privateKey,
      name,
      password,
      coin,
    );
  }

  late final _TWStoredKeyImportPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32)>>('TWStoredKeyImportPrivateKey');
  late final _TWStoredKeyImportPrivateKey =
      _TWStoredKeyImportPrivateKeyPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKeyWithEncryption(
    ffi.Pointer<TWData> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
    int encryption,
  ) {
    return _TWStoredKeyImportPrivateKeyWithEncryption(
      privateKey,
      name,
      password,
      coin,
      encryption,
    );
  }

  late final _TWStoredKeyImportPrivateKeyWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32,
              ffi.Int32)>>('TWStoredKeyImportPrivateKeyWithEncryption');
  late final _TWStoredKeyImportPrivateKeyWithEncryption =
      _TWStoredKeyImportPrivateKeyWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Imports a private key.
  ///
  /// \param privateKey Non-null Block of data private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \param derivation derivation of the given coin type
  ffi.Pointer<TWStoredKey>
      TWStoredKeyImportPrivateKeyWithEncryptionAndDerivation(
    ffi.Pointer<TWData> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
    int encryption,
    int derivation,
  ) {
    return _TWStoredKeyImportPrivateKeyWithEncryptionAndDerivation(
      privateKey,
      name,
      password,
      coin,
      encryption,
      derivation,
    );
  }

  late final _TWStoredKeyImportPrivateKeyWithEncryptionAndDerivationPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<TWStoredKey> Function(
                      ffi.Pointer<TWData>,
                      ffi.Pointer<TWString>,
                      ffi.Pointer<TWData>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          'TWStoredKeyImportPrivateKeyWithEncryptionAndDerivation');
  late final _TWStoredKeyImportPrivateKeyWithEncryptionAndDerivation =
      _TWStoredKeyImportPrivateKeyWithEncryptionAndDerivationPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int, int)>();

  /// Imports an encoded private key.
  ///
  /// \param privateKey Non-null encoded private key
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKeyEncoded(
    ffi.Pointer<TWString> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
  ) {
    return _TWStoredKeyImportPrivateKeyEncoded(
      privateKey,
      name,
      password,
      coin,
    );
  }

  late final _TWStoredKeyImportPrivateKeyEncodedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32)>>('TWStoredKeyImportPrivateKeyEncoded');
  late final _TWStoredKeyImportPrivateKeyEncoded =
      _TWStoredKeyImportPrivateKeyEncodedPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Imports an encoded private key.
  ///
  /// \param privateKey Non-null encoded private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportPrivateKeyEncodedWithEncryption(
    ffi.Pointer<TWString> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
    int encryption,
  ) {
    return _TWStoredKeyImportPrivateKeyEncodedWithEncryption(
      privateKey,
      name,
      password,
      coin,
      encryption,
    );
  }

  late final _TWStoredKeyImportPrivateKeyEncodedWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32,
              ffi.Int32)>>('TWStoredKeyImportPrivateKeyEncodedWithEncryption');
  late final _TWStoredKeyImportPrivateKeyEncodedWithEncryption =
      _TWStoredKeyImportPrivateKeyEncodedWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Imports an encoded private key.
  ///
  /// \param privateKey Non-null encoded private key
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \param derivation derivation of the given coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey>
      TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivation(
    ffi.Pointer<TWString> privateKey,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
    int encryption,
    int derivation,
  ) {
    return _TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivation(
      privateKey,
      name,
      password,
      coin,
      encryption,
      derivation,
    );
  }

  late final _TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivationPtr =
      _lookup<
              ffi.NativeFunction<
                  ffi.Pointer<TWStoredKey> Function(
                      ffi.Pointer<TWString>,
                      ffi.Pointer<TWString>,
                      ffi.Pointer<TWData>,
                      ffi.Int32,
                      ffi.Int32,
                      ffi.Int32)>>(
          'TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivation');
  late final _TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivation =
      _TWStoredKeyImportPrivateKeyEncodedWithEncryptionAndDerivationPtr
          .asFunction<
              ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
                  ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWallet(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
  ) {
    return _TWStoredKeyImportHDWallet(
      mnemonic,
      name,
      password,
      coin,
    );
  }

  late final _TWStoredKeyImportHDWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32)>>('TWStoredKeyImportHDWallet');
  late final _TWStoredKeyImportHDWallet =
      _TWStoredKeyImportHDWalletPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Imports an HD wallet.
  ///
  /// \param mnemonic Non-null bip39 mnemonic
  /// \param name The name of the stored key to import as a non-null string
  /// \param password Non-null block of data, password of the stored key
  /// \param coin the coin type
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportHDWalletWithEncryption(
    ffi.Pointer<TWString> mnemonic,
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int coin,
    int encryption,
  ) {
    return _TWStoredKeyImportHDWalletWithEncryption(
      mnemonic,
      name,
      password,
      coin,
      encryption,
    );
  }

  late final _TWStoredKeyImportHDWalletWithEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32,
              ffi.Int32)>>('TWStoredKeyImportHDWalletWithEncryption');
  late final _TWStoredKeyImportHDWalletWithEncryption =
      _TWStoredKeyImportHDWalletWithEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Imports a key from JSON.
  ///
  /// \param json Json stored key import format as a non-null block of data
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return Nullptr if the key can't be imported, the stored key otherwise
  ffi.Pointer<TWStoredKey> TWStoredKeyImportJSON(
    ffi.Pointer<TWData> json,
  ) {
    return _TWStoredKeyImportJSON(
      json,
    );
  }

  late final _TWStoredKeyImportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWData>)>>('TWStoredKeyImportJSON');
  late final _TWStoredKeyImportJSON = _TWStoredKeyImportJSONPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWData>)>();

  /// Creates a new key, with given encryption strength level. Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevel(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int encryptionLevel,
  ) {
    return _TWStoredKeyCreateLevel(
      name,
      password,
      encryptionLevel,
    );
  }

  late final _TWStoredKeyCreateLevelPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.Int32)>>('TWStoredKeyCreateLevel');
  late final _TWStoredKeyCreateLevel = _TWStoredKeyCreateLevelPtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Creates a new key, with given encryption strength level.  Returned object needs to be deleted.
  ///
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryptionLevel The level of encryption, see \TWStoredKeyEncryptionLevel
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateLevelAndEncryption(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int encryptionLevel,
    int encryption,
  ) {
    return _TWStoredKeyCreateLevelAndEncryption(
      name,
      password,
      encryptionLevel,
      encryption,
    );
  }

  late final _TWStoredKeyCreateLevelAndEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Int32,
              ffi.Int32)>>('TWStoredKeyCreateLevelAndEncryption');
  late final _TWStoredKeyCreateLevelAndEncryption =
      _TWStoredKeyCreateLevelAndEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int, int)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreate(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyCreate(
      name,
      password,
    );
  }

  late final _TWStoredKeyCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>)>>('TWStoredKeyCreate');
  late final _TWStoredKeyCreate = _TWStoredKeyCreatePtr.asFunction<
      ffi.Pointer<TWStoredKey> Function(
          ffi.Pointer<TWString>, ffi.Pointer<TWData>)>();

  /// Creates a new key.
  ///
  /// \deprecated use TWStoredKeyCreateLevel.
  /// \param name The name of the key to be stored
  /// \param password Non-null block of data, password of the stored key
  /// \param encryption cipher encryption mode
  /// \note Returned object needs to be deleted with \TWStoredKeyDelete
  /// \return The stored key as a non-null pointer
  ffi.Pointer<TWStoredKey> TWStoredKeyCreateEncryption(
    ffi.Pointer<TWString> name,
    ffi.Pointer<TWData> password,
    int encryption,
  ) {
    return _TWStoredKeyCreateEncryption(
      name,
      password,
      encryption,
    );
  }

  late final _TWStoredKeyCreateEncryptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWStoredKey> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.Int32)>>('TWStoredKeyCreateEncryption');
  late final _TWStoredKeyCreateEncryption =
      _TWStoredKeyCreateEncryptionPtr.asFunction<
          ffi.Pointer<TWStoredKey> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWData>, int)>();

  /// Delete a stored key
  ///
  /// \param key The key to be deleted
  void TWStoredKeyDelete(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyDelete(
      key,
    );
  }

  late final _TWStoredKeyDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyDelete');
  late final _TWStoredKeyDelete = _TWStoredKeyDeletePtr.asFunction<
      void Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key unique identifier.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key unique identifier if it's found, null pointer otherwise.
  ffi.Pointer<TWString> TWStoredKeyIdentifier(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIdentifier(
      key,
    );
  }

  late final _TWStoredKeyIdentifierPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyIdentifier');
  late final _TWStoredKeyIdentifier = _TWStoredKeyIdentifierPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();

  /// Stored key namer.
  ///
  /// \param key Non-null pointer to a stored key
  /// \note Returned object needs to be deleted with \TWStringDelete
  /// \return The stored key name as a non-null string pointer.
  ffi.Pointer<TWString> TWStoredKeyName(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyName(
      key,
    );
  }

  late final _TWStoredKeyNamePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyName');
  late final _TWStoredKeyName = _TWStoredKeyNamePtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();

  /// Whether this key is a mnemonic phrase for a HD wallet.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return true if the given stored key is a mnemonic, false otherwise
  bool TWStoredKeyIsMnemonic(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyIsMnemonic(
      key,
    );
  }

  late final _TWStoredKeyIsMnemonicPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyIsMnemonic');
  late final _TWStoredKeyIsMnemonic = _TWStoredKeyIsMnemonicPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>)>();

  /// The number of accounts.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return the number of accounts associated to the given stored key
  int TWStoredKeyAccountCount(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyAccountCount(
      key,
    );
  }

  late final _TWStoredKeyAccountCountPtr =
      _lookup<ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyAccountCount');
  late final _TWStoredKeyAccountCount = _TWStoredKeyAccountCountPtr.asFunction<
      int Function(ffi.Pointer<TWStoredKey>)>();

  /// Returns the account at a given index.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param index the account index to be retrieved
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccount(
    ffi.Pointer<TWStoredKey> key,
    int index,
  ) {
    return _TWStoredKeyAccount(
      key,
      index,
    );
  }

  late final _TWStoredKeyAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, ffi.Size)>>('TWStoredKeyAccount');
  late final _TWStoredKeyAccount = _TWStoredKeyAccountPtr.asFunction<
      ffi.Pointer<TWAccount> Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Returns the account for a specific coin, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param wallet The associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    int coin,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoin(
      key,
      coin,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(ffi.Pointer<TWStoredKey>, ffi.Int32,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoin');
  late final _TWStoredKeyAccountForCoin =
      _TWStoredKeyAccountForCoinPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWHDWallet>)>();

  /// Returns the account for a specific coin + derivation, creating it if necessary.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin The coin type
  /// \param derivation The derivation for the given coin
  /// \param wallet the associated HD wallet, can be null.
  /// \note Returned object needs to be deleted with \TWAccountDelete
  /// \return Null pointer if the associated account is not found/not created, pointer to the account otherwise.
  ffi.Pointer<TWAccount> TWStoredKeyAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    int coin,
    int derivation,
    ffi.Pointer<TWHDWallet> wallet,
  ) {
    return _TWStoredKeyAccountForCoinDerivation(
      key,
      coin,
      derivation,
      wallet,
    );
  }

  late final _TWStoredKeyAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<TWHDWallet>)>>('TWStoredKeyAccountForCoinDerivation');
  late final _TWStoredKeyAccountForCoinDerivation =
      _TWStoredKeyAccountForCoinDerivationPtr.asFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWStoredKey>, int, int, ffi.Pointer<TWHDWallet>)>();

  /// Adds a new account, using given derivation (usually TWDerivationDefault)
  /// and derivation path (usually matches path from derivation, but custom possible).
  ///
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivation derivation of the given coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccountDerivation(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> address,
    int coin,
    int derivation,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccountDerivation(
      key,
      address,
      coin,
      derivation,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWStoredKeyAddAccountDerivation');
  late final _TWStoredKeyAddAccountDerivation =
      _TWStoredKeyAddAccountDerivationPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              int,
              int,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Adds a new account, using given derivation path.
  ///
  /// \deprecated Use TWStoredKeyAddAccountDerivation (with TWDerivationDefault) instead.
  /// \param key Non-null pointer to a stored key
  /// \param address Non-null pointer to the address of the coin for this account
  /// \param coin coin type
  /// \param derivationPath HD bip44 derivation path of the given coin
  /// \param publicKey Non-null public key of the given coin/address
  /// \param extendedPublicKey Non-null extended public key of the given coin/address
  void TWStoredKeyAddAccount(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> address,
    int coin,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWStoredKeyAddAccount(
      key,
      address,
      coin,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWStoredKeyAddAccountPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(
              ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>,
              ffi.Int32,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWStoredKeyAddAccount');
  late final _TWStoredKeyAddAccount = _TWStoredKeyAddAccountPtr.asFunction<
      void Function(
          ffi.Pointer<TWStoredKey>,
          ffi.Pointer<TWString>,
          int,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>)>();

  /// Remove the account for a specific coin
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  void TWStoredKeyRemoveAccountForCoin(
    ffi.Pointer<TWStoredKey> key,
    int coin,
  ) {
    return _TWStoredKeyRemoveAccountForCoin(
      key,
      coin,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>,
              ffi.Int32)>>('TWStoredKeyRemoveAccountForCoin');
  late final _TWStoredKeyRemoveAccountForCoin =
      _TWStoredKeyRemoveAccountForCoinPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Remove the account for a specific coin with the given derivation.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivation The derivation of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivation(
    ffi.Pointer<TWStoredKey> key,
    int coin,
    int derivation,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivation(
      key,
      coin,
      derivation,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<TWStoredKey>, ffi.Int32,
              ffi.Int32)>>('TWStoredKeyRemoveAccountForCoinDerivation');
  late final _TWStoredKeyRemoveAccountForCoinDerivation =
      _TWStoredKeyRemoveAccountForCoinDerivationPtr.asFunction<
          void Function(ffi.Pointer<TWStoredKey>, int, int)>();

  /// Remove the account for a specific coin with the given derivation path.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be removed
  /// \param derivationPath The derivation path (bip44) of the given coin type
  void TWStoredKeyRemoveAccountForCoinDerivationPath(
    ffi.Pointer<TWStoredKey> key,
    int coin,
    ffi.Pointer<TWString> derivationPath,
  ) {
    return _TWStoredKeyRemoveAccountForCoinDerivationPath(
      key,
      coin,
      derivationPath,
    );
  }

  late final _TWStoredKeyRemoveAccountForCoinDerivationPathPtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Pointer<TWStoredKey>, ffi.Int32, ffi.Pointer<TWString>)>>(
      'TWStoredKeyRemoveAccountForCoinDerivationPath');
  late final _TWStoredKeyRemoveAccountForCoinDerivationPath =
      _TWStoredKeyRemoveAccountForCoinDerivationPathPtr.asFunction<
          void Function(
              ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWString>)>();

  /// Saves the key to a file.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param path Non-null string filepath where the key will be saved
  /// \return true if the key was successfully stored in the given filepath file, false otherwise
  bool TWStoredKeyStore(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWString> path,
  ) {
    return _TWStoredKeyStore(
      key,
      path,
    );
  }

  late final _TWStoredKeyStorePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWString>)>>('TWStoredKeyStore');
  late final _TWStoredKeyStore = _TWStoredKeyStorePtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWString>)>();

  /// Decrypts the private key.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Decrypted private key as a block of data if success, null pointer otherwise
  ffi.Pointer<TWData> TWStoredKeyDecryptPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyDecryptPrivateKey(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyDecryptPrivateKey');
  late final _TWStoredKeyDecryptPrivateKey =
      _TWStoredKeyDecryptPrivateKeyPtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Decrypts the encoded private key.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Decrypted encoded private key as a string if success, null pointer otherwise
  ffi.Pointer<TWString> TWStoredKeyDecryptPrivateKeyEncoded(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyDecryptPrivateKeyEncoded(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptPrivateKeyEncodedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyDecryptPrivateKeyEncoded');
  late final _TWStoredKeyDecryptPrivateKeyEncoded =
      _TWStoredKeyDecryptPrivateKeyEncodedPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Whether the private key is encoded.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return true if the private key is encoded, false otherwise
  bool TWStoredKeyHasPrivateKeyEncoded(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyHasPrivateKeyEncoded(
      key,
    );
  }

  late final _TWStoredKeyHasPrivateKeyEncodedPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWStoredKey>)>>(
          'TWStoredKeyHasPrivateKeyEncoded');
  late final _TWStoredKeyHasPrivateKeyEncoded =
      _TWStoredKeyHasPrivateKeyEncodedPtr.asFunction<
          bool Function(ffi.Pointer<TWStoredKey>)>();

  /// Decrypts the mnemonic phrase.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return Bip39 decrypted mnemonic if success, null pointer otherwise
  ffi.Pointer<TWString> TWStoredKeyDecryptMnemonic(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyDecryptMnemonic(
      key,
      password,
    );
  }

  late final _TWStoredKeyDecryptMnemonicPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyDecryptMnemonic');
  late final _TWStoredKeyDecryptMnemonic =
      _TWStoredKeyDecryptMnemonicPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Returns the private key for a specific coin.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account coin type to be queried
  /// \note Returned object needs to be deleted with \TWPrivateKeyDelete
  /// \return Null pointer on failure, pointer to the private key otherwise
  ffi.Pointer<TWPrivateKey> TWStoredKeyPrivateKey(
    ffi.Pointer<TWStoredKey> key,
    int coin,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyPrivateKey(
      key,
      coin,
      password,
    );
  }

  late final _TWStoredKeyPrivateKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWPrivateKey> Function(ffi.Pointer<TWStoredKey>,
              ffi.Int32, ffi.Pointer<TWData>)>>('TWStoredKeyPrivateKey');
  late final _TWStoredKeyPrivateKey = _TWStoredKeyPrivateKeyPtr.asFunction<
      ffi.Pointer<TWPrivateKey> Function(
          ffi.Pointer<TWStoredKey>, int, ffi.Pointer<TWData>)>();

  /// Decrypts and returns the HD Wallet for mnemonic phrase keys.  Returned object needs to be deleted.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \note Returned object needs to be deleted with \TWHDWalletDelete
  /// \return Null pointer on failure, pointer to the HDWallet otherwise
  ffi.Pointer<TWHDWallet> TWStoredKeyWallet(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyWallet(
      key,
      password,
    );
  }

  late final _TWStoredKeyWalletPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWHDWallet> Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyWallet');
  late final _TWStoredKeyWallet = _TWStoredKeyWalletPtr.asFunction<
      ffi.Pointer<TWHDWallet> Function(
          ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Exports the key as JSON
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, pointer to a block of data containing the json otherwise
  ffi.Pointer<TWData> TWStoredKeyExportJSON(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyExportJSON(
      key,
    );
  }

  late final _TWStoredKeyExportJSONPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyExportJSON');
  late final _TWStoredKeyExportJSON = _TWStoredKeyExportJSONPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWStoredKey>)>();

  /// Fills in empty and invalid addresses.
  /// This method needs the encryption password to re-derive addresses from private keys.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param password Non-null block of data, password of the stored key
  /// \return `false` if the password is incorrect, true otherwise.
  bool TWStoredKeyFixAddresses(
    ffi.Pointer<TWStoredKey> key,
    ffi.Pointer<TWData> password,
  ) {
    return _TWStoredKeyFixAddresses(
      key,
      password,
    );
  }

  late final _TWStoredKeyFixAddressesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Pointer<TWData>)>>('TWStoredKeyFixAddresses');
  late final _TWStoredKeyFixAddresses = _TWStoredKeyFixAddressesPtr.asFunction<
      bool Function(ffi.Pointer<TWStoredKey>, ffi.Pointer<TWData>)>();

  /// Re-derives address for the account(s) associated with the given coin.
  /// This method can be used if address format has been changed.
  /// In case of multiple accounts, all of them will be updated.
  ///
  /// \param key Non-null pointer to a stored key
  /// \param coin Account(s) coin type to be updated
  /// \return `false` if there are no accounts associated with the given coin, true otherwise
  bool TWStoredKeyUpdateAddress(
    ffi.Pointer<TWStoredKey> key,
    int coin,
  ) {
    return _TWStoredKeyUpdateAddress(
      key,
      coin,
    );
  }

  late final _TWStoredKeyUpdateAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWStoredKey>,
              ffi.Int32)>>('TWStoredKeyUpdateAddress');
  late final _TWStoredKeyUpdateAddress = _TWStoredKeyUpdateAddressPtr
      .asFunction<bool Function(ffi.Pointer<TWStoredKey>, int)>();

  /// Retrieve stored key encoding parameters, as JSON string.
  ///
  /// \param key Non-null pointer to a stored key
  /// \return Null pointer on failure, encoding parameter as a json string otherwise.
  ffi.Pointer<TWString> TWStoredKeyEncryptionParameters(
    ffi.Pointer<TWStoredKey> key,
  ) {
    return _TWStoredKeyEncryptionParameters(
      key,
    );
  }

  late final _TWStoredKeyEncryptionParametersPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWStoredKey>)>>('TWStoredKeyEncryptionParameters');
  late final _TWStoredKeyEncryptionParameters =
      _TWStoredKeyEncryptionParametersPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWStoredKey>)>();

  /// Creates an empty script.
  ///
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreate() {
    return _TWBitcoinScriptCreate();
  }

  late final _TWBitcoinScriptCreatePtr =
      _lookup<ffi.NativeFunction<ffi.Pointer<TWBitcoinScript> Function()>>(
          'TWBitcoinScriptCreate');
  late final _TWBitcoinScriptCreate = _TWBitcoinScriptCreatePtr.asFunction<
      ffi.Pointer<TWBitcoinScript> Function()>();

  /// Creates a script from a raw data representation.
  ///
  /// \param data The data buffer
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateWithData(
    ffi.Pointer<TWData> data,
  ) {
    return _TWBitcoinScriptCreateWithData(
      data,
    );
  }

  late final _TWBitcoinScriptCreateWithDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData>)>>('TWBitcoinScriptCreateWithData');
  late final _TWBitcoinScriptCreateWithData = _TWBitcoinScriptCreateWithDataPtr
      .asFunction<ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Creates a script from a raw bytes and size.
  ///
  /// \param bytes The buffer
  /// \param size The size of the buffer
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateWithBytes(
    ffi.Pointer<ffi.Uint8> bytes,
    int size,
  ) {
    return _TWBitcoinScriptCreateWithBytes(
      bytes,
      size,
    );
  }

  late final _TWBitcoinScriptCreateWithBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<ffi.Uint8>,
              ffi.Size)>>('TWBitcoinScriptCreateWithBytes');
  late final _TWBitcoinScriptCreateWithBytes =
      _TWBitcoinScriptCreateWithBytesPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<ffi.Uint8>, int)>();

  /// Creates a script by copying an existing script.
  ///
  /// \param script Non-null pointer to a script
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptCreateCopy(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptCreateCopy(
      script,
    );
  }

  late final _TWBitcoinScriptCreateCopyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptCreateCopy');
  late final _TWBitcoinScriptCreateCopy =
      _TWBitcoinScriptCreateCopyPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWBitcoinScript>)>();

  /// Delete/Deallocate a given script.
  ///
  /// \param script Non-null pointer to a script
  void TWBitcoinScriptDelete(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptDelete(
      script,
    );
  }

  late final _TWBitcoinScriptDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptDelete');
  late final _TWBitcoinScriptDelete = _TWBitcoinScriptDeletePtr.asFunction<
      void Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Get size of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return size of the script
  int TWBitcoinScriptSize(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptSize(
      script,
    );
  }

  late final _TWBitcoinScriptSizePtr = _lookup<
          ffi.NativeFunction<ffi.Size Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptSize');
  late final _TWBitcoinScriptSize = _TWBitcoinScriptSizePtr.asFunction<
      int Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Get data of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return data of the given script
  ffi.Pointer<TWData> TWBitcoinScriptData(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptData(
      script,
    );
  }

  late final _TWBitcoinScriptDataPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptData');
  late final _TWBitcoinScriptData = _TWBitcoinScriptDataPtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Return script hash of a script
  ///
  /// \param script Non-null pointer to a script
  /// \return script hash of the given script
  ffi.Pointer<TWData> TWBitcoinScriptScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptScriptHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptScriptHash');
  late final _TWBitcoinScriptScriptHash = _TWBitcoinScriptScriptHashPtr
      .asFunction<ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-script-hash (P2SH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-script-hash (P2SH) script, false otherwise
  bool TWBitcoinScriptIsPayToScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToScriptHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToScriptHash');
  late final _TWBitcoinScriptIsPayToScriptHash =
      _TWBitcoinScriptIsPayToScriptHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-witness-script-hash (P2WSH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-witness-script-hash (P2WSH) script, false otherwise
  bool TWBitcoinScriptIsPayToWitnessScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToWitnessScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToWitnessScriptHash');
  late final _TWBitcoinScriptIsPayToWitnessScriptHash =
      _TWBitcoinScriptIsPayToWitnessScriptHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a pay-to-witness-public-key-hash (P2WPKH) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a pay-to-witness-public-key-hash (P2WPKH) script, false otherwise
  bool TWBitcoinScriptIsPayToWitnessPublicKeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsPayToWitnessPublicKeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptIsPayToWitnessPublicKeyHashPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsPayToWitnessPublicKeyHash');
  late final _TWBitcoinScriptIsPayToWitnessPublicKeyHash =
      _TWBitcoinScriptIsPayToWitnessPublicKeyHashPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether this is a witness program script.
  ///
  /// \param script Non-null pointer to a script
  /// \return true if this is a witness program script, false otherwise
  bool TWBitcoinScriptIsWitnessProgram(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptIsWitnessProgram(
      script,
    );
  }

  late final _TWBitcoinScriptIsWitnessProgramPtr = _lookup<
          ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptIsWitnessProgram');
  late final _TWBitcoinScriptIsWitnessProgram =
      _TWBitcoinScriptIsWitnessProgramPtr.asFunction<
          bool Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Determines whether 2 scripts have the same content
  ///
  /// \param lhs Non-null pointer to the first script
  /// \param rhs Non-null pointer to the second script
  /// \return true if both script have the same content
  bool TWBitcoinScriptEqual(
    ffi.Pointer<TWBitcoinScript> lhs,
    ffi.Pointer<TWBitcoinScript> rhs,
  ) {
    return _TWBitcoinScriptEqual(
      lhs,
      rhs,
    );
  }

  late final _TWBitcoinScriptEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWBitcoinScript>,
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptEqual');
  late final _TWBitcoinScriptEqual = _TWBitcoinScriptEqualPtr.asFunction<
      bool Function(
          ffi.Pointer<TWBitcoinScript>, ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-public-key (P2PK) script.
  ///
  /// \param script Non-null pointer to a script
  /// \return The public key.
  ffi.Pointer<TWData> TWBitcoinScriptMatchPayToPubkey(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToPubkey(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToPubkeyPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToPubkey');
  late final _TWBitcoinScriptMatchPayToPubkey =
      _TWBitcoinScriptMatchPayToPubkeyPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-public-key-hash (P2PKH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the key hash.
  ffi.Pointer<TWData> TWBitcoinScriptMatchPayToPubkeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToPubkeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToPubkeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToPubkeyHash');
  late final _TWBitcoinScriptMatchPayToPubkeyHash =
      _TWBitcoinScriptMatchPayToPubkeyHashPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-script-hash (P2SH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the script hash.
  ffi.Pointer<TWData> TWBitcoinScriptMatchPayToScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToScriptHash');
  late final _TWBitcoinScriptMatchPayToScriptHash =
      _TWBitcoinScriptMatchPayToScriptHashPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-witness-public-key-hash (P2WPKH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the key hash.
  ffi.Pointer<TWData> TWBitcoinScriptMatchPayToWitnessPublicKeyHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToWitnessPublicKeyHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToWitnessPublicKeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToWitnessPublicKeyHash');
  late final _TWBitcoinScriptMatchPayToWitnessPublicKeyHash =
      _TWBitcoinScriptMatchPayToWitnessPublicKeyHashPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Matches the script to a pay-to-witness-script-hash (P2WSH).
  ///
  /// \param script Non-null pointer to a script
  /// \return the script hash, a SHA256 of the witness script..
  ffi.Pointer<TWData> TWBitcoinScriptMatchPayToWitnessScriptHash(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptMatchPayToWitnessScriptHash(
      script,
    );
  }

  late final _TWBitcoinScriptMatchPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>>(
      'TWBitcoinScriptMatchPayToWitnessScriptHash');
  late final _TWBitcoinScriptMatchPayToWitnessScriptHash =
      _TWBitcoinScriptMatchPayToWitnessScriptHashPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Encodes the script.
  ///
  /// \param script Non-null pointer to a script
  /// \return The encoded script
  ffi.Pointer<TWData> TWBitcoinScriptEncode(
    ffi.Pointer<TWBitcoinScript> script,
  ) {
    return _TWBitcoinScriptEncode(
      script,
    );
  }

  late final _TWBitcoinScriptEncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWBitcoinScript>)>>('TWBitcoinScriptEncode');
  late final _TWBitcoinScriptEncode = _TWBitcoinScriptEncodePtr.asFunction<
      ffi.Pointer<TWData> Function(ffi.Pointer<TWBitcoinScript>)>();

  /// Builds a standard 'pay to public key' script.
  ///
  /// \param pubkey Non-null pointer to a pubkey
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToPublicKey(
    ffi.Pointer<TWData> pubkey,
  ) {
    return _TWBitcoinScriptBuildPayToPublicKey(
      pubkey,
    );
  }

  late final _TWBitcoinScriptBuildPayToPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData>)>>('TWBitcoinScriptBuildPayToPublicKey');
  late final _TWBitcoinScriptBuildPayToPublicKey =
      _TWBitcoinScriptBuildPayToPublicKeyPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Builds a standard 'pay to public key hash' script.
  ///
  /// \param hash Non-null pointer to a PublicKey hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToPublicKeyHash(
    ffi.Pointer<TWData> hash,
  ) {
    return _TWBitcoinScriptBuildPayToPublicKeyHash(
      hash,
    );
  }

  late final _TWBitcoinScriptBuildPayToPublicKeyHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData>)>>('TWBitcoinScriptBuildPayToPublicKeyHash');
  late final _TWBitcoinScriptBuildPayToPublicKeyHash =
      _TWBitcoinScriptBuildPayToPublicKeyHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Builds a standard 'pay to script hash' script.
  ///
  /// \param scriptHash Non-null pointer to a script hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToScriptHash(
    ffi.Pointer<TWData> scriptHash,
  ) {
    return _TWBitcoinScriptBuildPayToScriptHash(
      scriptHash,
    );
  }

  late final _TWBitcoinScriptBuildPayToScriptHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWData>)>>('TWBitcoinScriptBuildPayToScriptHash');
  late final _TWBitcoinScriptBuildPayToScriptHash =
      _TWBitcoinScriptBuildPayToScriptHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Builds a pay-to-witness-public-key-hash (P2WPKH) script..
  ///
  /// \param hash Non-null pointer to a witness public key hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToWitnessPubkeyHash(
    ffi.Pointer<TWData> hash,
  ) {
    return _TWBitcoinScriptBuildPayToWitnessPubkeyHash(
      hash,
    );
  }

  late final _TWBitcoinScriptBuildPayToWitnessPubkeyHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>>(
      'TWBitcoinScriptBuildPayToWitnessPubkeyHash');
  late final _TWBitcoinScriptBuildPayToWitnessPubkeyHash =
      _TWBitcoinScriptBuildPayToWitnessPubkeyHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Builds a pay-to-witness-script-hash (P2WSH) script.
  ///
  /// \param scriptHash Non-null pointer to a script hash
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptBuildPayToWitnessScriptHash(
    ffi.Pointer<TWData> scriptHash,
  ) {
    return _TWBitcoinScriptBuildPayToWitnessScriptHash(
      scriptHash,
    );
  }

  late final _TWBitcoinScriptBuildPayToWitnessScriptHashPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>>(
      'TWBitcoinScriptBuildPayToWitnessScriptHash');
  late final _TWBitcoinScriptBuildPayToWitnessScriptHash =
      _TWBitcoinScriptBuildPayToWitnessScriptHashPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWData>)>();

  /// Builds a appropriate lock script for the given address..
  ///
  /// \param address Non-null pointer to an address
  /// \param coin coin type
  /// \note Must be deleted with \TWBitcoinScriptDelete
  /// \return A pointer to the built script
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptLockScriptForAddress(
    ffi.Pointer<TWString> address,
    int coin,
  ) {
    return _TWBitcoinScriptLockScriptForAddress(
      address,
      coin,
    );
  }

  late final _TWBitcoinScriptLockScriptForAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWString>,
              ffi.Int32)>>('TWBitcoinScriptLockScriptForAddress');
  late final _TWBitcoinScriptLockScriptForAddress =
      _TWBitcoinScriptLockScriptForAddressPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(ffi.Pointer<TWString>, int)>();

  /// Builds a appropriate lock script for the given address with replay.
  ffi.Pointer<TWBitcoinScript> TWBitcoinScriptLockScriptForAddressReplay(
    ffi.Pointer<TWString> address,
    int coin,
    ffi.Pointer<TWData> blockHash,
    int blockHeight,
  ) {
    return _TWBitcoinScriptLockScriptForAddressReplay(
      address,
      coin,
      blockHash,
      blockHeight,
    );
  }

  late final _TWBitcoinScriptLockScriptForAddressReplayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWString>,
              ffi.Int32,
              ffi.Pointer<TWData>,
              ffi.Int64)>>('TWBitcoinScriptLockScriptForAddressReplay');
  late final _TWBitcoinScriptLockScriptForAddressReplay =
      _TWBitcoinScriptLockScriptForAddressReplayPtr.asFunction<
          ffi.Pointer<TWBitcoinScript> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWData>, int)>();

  /// Return the default HashType for the given coin, such as TWBitcoinSigHashTypeAll.
  ///
  /// \param coinType coin type
  /// \return default HashType for the given coin
  int TWBitcoinScriptHashTypeForCoin(
    int coinType,
  ) {
    return _TWBitcoinScriptHashTypeForCoin(
      coinType,
    );
  }

  late final _TWBitcoinScriptHashTypeForCoinPtr =
      _lookup<ffi.NativeFunction<ffi.Uint32 Function(ffi.Int32)>>(
          'TWBitcoinScriptHashTypeForCoin');
  late final _TWBitcoinScriptHashTypeForCoin =
      _TWBitcoinScriptHashTypeForCoinPtr.asFunction<int Function(int)>();

  /// Create a FIO Account
  ///
  /// \param string Account name
  /// \note Must be deleted with \TWFIOAccountDelete
  /// \return Pointer to a nullable FIO Account
  ffi.Pointer<TWFIOAccount> TWFIOAccountCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWFIOAccountCreateWithString(
      string,
    );
  }

  late final _TWFIOAccountCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWFIOAccount> Function(
              ffi.Pointer<TWString>)>>('TWFIOAccountCreateWithString');
  late final _TWFIOAccountCreateWithString = _TWFIOAccountCreateWithStringPtr
      .asFunction<ffi.Pointer<TWFIOAccount> Function(ffi.Pointer<TWString>)>();

  /// Delete a FIO Account
  ///
  /// \param account Pointer to a non-null FIO Account
  void TWFIOAccountDelete(
    ffi.Pointer<TWFIOAccount> account,
  ) {
    return _TWFIOAccountDelete(
      account,
    );
  }

  late final _TWFIOAccountDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWFIOAccount>)>>(
          'TWFIOAccountDelete');
  late final _TWFIOAccountDelete = _TWFIOAccountDeletePtr.asFunction<
      void Function(ffi.Pointer<TWFIOAccount>)>();

  /// Returns the short account string representation.
  ///
  /// \param account Pointer to a non-null FIO Account
  /// \return Account non-null string representation
  ffi.Pointer<TWString> TWFIOAccountDescription(
    ffi.Pointer<TWFIOAccount> account,
  ) {
    return _TWFIOAccountDescription(
      account,
    );
  }

  late final _TWFIOAccountDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWFIOAccount>)>>('TWFIOAccountDescription');
  late final _TWFIOAccountDescription = _TWFIOAccountDescriptionPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWFIOAccount>)>();

  /// Compares two addresses for equality.
  ///
  /// \param lhs left Non-null GroestlCoin address to be compared
  /// \param rhs right Non-null GroestlCoin address to be compared
  /// \return true if both address are equal, false otherwise
  bool TWGroestlcoinAddressEqual(
    ffi.Pointer<TWGroestlcoinAddress> lhs,
    ffi.Pointer<TWGroestlcoinAddress> rhs,
  ) {
    return _TWGroestlcoinAddressEqual(
      lhs,
      rhs,
    );
  }

  late final _TWGroestlcoinAddressEqualPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWGroestlcoinAddress>,
              ffi.Pointer<TWGroestlcoinAddress>)>>('TWGroestlcoinAddressEqual');
  late final _TWGroestlcoinAddressEqual =
      _TWGroestlcoinAddressEqualPtr.asFunction<
          bool Function(ffi.Pointer<TWGroestlcoinAddress>,
              ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Determines if the string is a valid Groestlcoin address.
  ///
  /// \param string Non-null string.
  /// \return true if it's a valid address, false otherwise
  bool TWGroestlcoinAddressIsValidString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWGroestlcoinAddressIsValidString(
      string,
    );
  }

  late final _TWGroestlcoinAddressIsValidStringPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWGroestlcoinAddressIsValidString');
  late final _TWGroestlcoinAddressIsValidString =
      _TWGroestlcoinAddressIsValidStringPtr.asFunction<
          bool Function(ffi.Pointer<TWString>)>();

  /// Create an address from a base58 string representation.
  ///
  /// \param string Non-null string
  /// \note Must be deleted with \TWGroestlcoinAddressDelete
  /// \return Non-null GroestlcoinAddress
  ffi.Pointer<TWGroestlcoinAddress> TWGroestlcoinAddressCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWGroestlcoinAddressCreateWithString(
      string,
    );
  }

  late final _TWGroestlcoinAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(
              ffi.Pointer<TWString>)>>('TWGroestlcoinAddressCreateWithString');
  late final _TWGroestlcoinAddressCreateWithString =
      _TWGroestlcoinAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(ffi.Pointer<TWString>)>();

  /// Create an address from a public key and a prefix byte.
  ///
  /// \param publicKey Non-null public key
  /// \param prefix public key prefix
  /// \note Must be deleted with \TWGroestlcoinAddressDelete
  /// \return Non-null GroestlcoinAddress
  ffi.Pointer<TWGroestlcoinAddress> TWGroestlcoinAddressCreateWithPublicKey(
    ffi.Pointer<TWPublicKey> publicKey,
    int prefix,
  ) {
    return _TWGroestlcoinAddressCreateWithPublicKey(
      publicKey,
      prefix,
    );
  }

  late final _TWGroestlcoinAddressCreateWithPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(ffi.Pointer<TWPublicKey>,
              ffi.Uint8)>>('TWGroestlcoinAddressCreateWithPublicKey');
  late final _TWGroestlcoinAddressCreateWithPublicKey =
      _TWGroestlcoinAddressCreateWithPublicKeyPtr.asFunction<
          ffi.Pointer<TWGroestlcoinAddress> Function(
              ffi.Pointer<TWPublicKey>, int)>();

  /// Delete a Groestlcoin address
  ///
  /// \param address Non-null GroestlcoinAddress
  void TWGroestlcoinAddressDelete(
    ffi.Pointer<TWGroestlcoinAddress> address,
  ) {
    return _TWGroestlcoinAddressDelete(
      address,
    );
  }

  late final _TWGroestlcoinAddressDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWGroestlcoinAddress>)>>(
      'TWGroestlcoinAddressDelete');
  late final _TWGroestlcoinAddressDelete = _TWGroestlcoinAddressDeletePtr
      .asFunction<void Function(ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Returns the address base58 string representation.
  ///
  /// \param address Non-null GroestlcoinAddress
  /// \return Address description as a non-null string
  ffi.Pointer<TWString> TWGroestlcoinAddressDescription(
    ffi.Pointer<TWGroestlcoinAddress> address,
  ) {
    return _TWGroestlcoinAddressDescription(
      address,
    );
  }

  late final _TWGroestlcoinAddressDescriptionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWGroestlcoinAddress>)>>(
      'TWGroestlcoinAddressDescription');
  late final _TWGroestlcoinAddressDescription =
      _TWGroestlcoinAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWGroestlcoinAddress>)>();

  /// Encrypts message using `my_secret` and `other_pubkey`.
  /// The output will have a randomly generated nonce prepended to it.
  /// The output will be Overhead + 24 bytes longer than the original.
  ///
  /// \param mySecret *non-null* pointer to my secret key.
  /// \param otherPubkey *non-null* pointer to other's public key.
  /// \param message *non-null* pointer to the message to be encrypted.
  /// \return *nullable* pointer to the encrypted message with randomly generated nonce prepended to it.
  ffi.Pointer<TWData1> TWCryptoBoxEncryptEasy(
    ffi.Pointer<TWCryptoBoxSecretKey> mySecret,
    ffi.Pointer<TWCryptoBoxPublicKey> otherPubkey,
    ffi.Pointer<TWData1> message,
  ) {
    return _TWCryptoBoxEncryptEasy(
      mySecret,
      otherPubkey,
      message,
    );
  }

  late final _TWCryptoBoxEncryptEasyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>,
              ffi.Pointer<TWCryptoBoxPublicKey>,
              ffi.Pointer<TWData1>)>>('TWCryptoBoxEncryptEasy');
  late final _TWCryptoBoxEncryptEasy = _TWCryptoBoxEncryptEasyPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWCryptoBoxSecretKey>,
          ffi.Pointer<TWCryptoBoxPublicKey>, ffi.Pointer<TWData1>)>();

  /// Decrypts box produced by `TWCryptoBoxEncryptEasy`.
  /// We assume a 24-byte nonce is prepended to the encrypted text in box.
  ///
  /// \param mySecret *non-null* pointer to my secret key.
  /// \param otherPubkey *non-null* pointer to other's public key.
  /// \param encrypted *non-null* pointer to the encrypted message with nonce prepended to it.
  /// \return *nullable* pointer to the decrypted message.
  ffi.Pointer<TWData1> TWCryptoBoxDecryptEasy(
    ffi.Pointer<TWCryptoBoxSecretKey> mySecret,
    ffi.Pointer<TWCryptoBoxPublicKey> otherPubkey,
    ffi.Pointer<TWData1> encrypted,
  ) {
    return _TWCryptoBoxDecryptEasy(
      mySecret,
      otherPubkey,
      encrypted,
    );
  }

  late final _TWCryptoBoxDecryptEasyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWCryptoBoxSecretKey>,
              ffi.Pointer<TWCryptoBoxPublicKey>,
              ffi.Pointer<TWData1>)>>('TWCryptoBoxDecryptEasy');
  late final _TWCryptoBoxDecryptEasy = _TWCryptoBoxDecryptEasyPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWCryptoBoxSecretKey>,
          ffi.Pointer<TWCryptoBoxPublicKey>, ffi.Pointer<TWData1>)>();

  /// Determines whether a BIP39 English mnemonic phrase is valid.
  ///
  /// \param mnemonic Non-null BIP39 english mnemonic
  /// \return true if the mnemonic is valid, false otherwise
  bool TWMnemonicIsValid(
    ffi.Pointer<TWString> mnemonic,
  ) {
    return _TWMnemonicIsValid(
      mnemonic,
    );
  }

  late final _TWMnemonicIsValidPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWMnemonicIsValid');
  late final _TWMnemonicIsValid =
      _TWMnemonicIsValidPtr.asFunction<bool Function(ffi.Pointer<TWString>)>();

  /// Determines whether word is a valid BIP39 English mnemonic word.
  ///
  /// \param word Non-null BIP39 English mnemonic word
  /// \return true if the word is a valid BIP39 English mnemonic word, false otherwise
  bool TWMnemonicIsValidWord(
    ffi.Pointer<TWString> word,
  ) {
    return _TWMnemonicIsValidWord(
      word,
    );
  }

  late final _TWMnemonicIsValidWordPtr =
      _lookup<ffi.NativeFunction<ffi.Bool Function(ffi.Pointer<TWString>)>>(
          'TWMnemonicIsValidWord');
  late final _TWMnemonicIsValidWord = _TWMnemonicIsValidWordPtr.asFunction<
      bool Function(ffi.Pointer<TWString>)>();

  /// Return BIP39 English words that match the given prefix. A single string is returned, with space-separated list of words.
  ///
  /// \param prefix Non-null string prefix
  /// \return Single non-null string, space-separated list of words containing BIP39 words that match the given prefix.
  ffi.Pointer<TWString> TWMnemonicSuggest(
    ffi.Pointer<TWString> prefix,
  ) {
    return _TWMnemonicSuggest(
      prefix,
    );
  }

  late final _TWMnemonicSuggestPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWMnemonicSuggest');
  late final _TWMnemonicSuggest = _TWMnemonicSuggestPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Creates a function object, with the given name and empty parameter list.  It must be deleted at the end.
  ///
  /// \param name function name
  /// \return Non-null Ethereum abi function
  ffi.Pointer<TWEthereumAbiFunction> TWEthereumAbiFunctionCreateWithString(
    ffi.Pointer<TWString1> name,
  ) {
    return _TWEthereumAbiFunctionCreateWithString(
      name,
    );
  }

  late final _TWEthereumAbiFunctionCreateWithStringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWEthereumAbiFunction> Function(
                  ffi.Pointer<TWString1>)>>(
      'TWEthereumAbiFunctionCreateWithString');
  late final _TWEthereumAbiFunctionCreateWithString =
      _TWEthereumAbiFunctionCreateWithStringPtr.asFunction<
          ffi.Pointer<TWEthereumAbiFunction> Function(
              ffi.Pointer<TWString1>)>();

  /// Deletes a function object created with a 'TWEthereumAbiFunctionCreateWithString' method.
  ///
  /// \param fn Non-null Ethereum abi function
  void TWEthereumAbiFunctionDelete(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiFunctionDelete(
      fn,
    );
  }

  late final _TWEthereumAbiFunctionDeletePtr = _lookup<
          ffi.NativeFunction<
              ffi.Void Function(ffi.Pointer<TWEthereumAbiFunction>)>>(
      'TWEthereumAbiFunctionDelete');
  late final _TWEthereumAbiFunctionDelete = _TWEthereumAbiFunctionDeletePtr
      .asFunction<void Function(ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Return the function type signature, of the form "baz(int32,uint256)"
  ///
  /// \param fn A Non-null eth abi function
  /// \return function type signature as a Non-null string.
  ffi.Pointer<TWString1> TWEthereumAbiFunctionGetType(
    ffi.Pointer<TWEthereumAbiFunction> fn,
  ) {
    return _TWEthereumAbiFunctionGetType(
      fn,
    );
  }

  late final _TWEthereumAbiFunctionGetTypePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString1> Function(
                  ffi.Pointer<TWEthereumAbiFunction>)>>(
      'TWEthereumAbiFunctionGetType');
  late final _TWEthereumAbiFunctionGetType =
      _TWEthereumAbiFunctionGetTypePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWEthereumAbiFunction>)>();

  /// Add a uint8 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt8(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint8,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt8');
  late final _TWEthereumAbiFunctionAddParamUInt8 =
      _TWEthereumAbiFunctionAddParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint16 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt16(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint16,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt16');
  late final _TWEthereumAbiFunctionAddParamUInt16 =
      _TWEthereumAbiFunctionAddParamUInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint32 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt32(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint32,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt32');
  late final _TWEthereumAbiFunctionAddParamUInt32 =
      _TWEthereumAbiFunctionAddParamUInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint64 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt64(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Uint64,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt64');
  late final _TWEthereumAbiFunctionAddParamUInt64 =
      _TWEthereumAbiFunctionAddParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a uint256 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUInt256(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUInt256');
  late final _TWEthereumAbiFunctionAddParamUInt256 =
      _TWEthereumAbiFunctionAddParamUInt256Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData1>,
              bool)>();

  /// Add a uint(bits) type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamUIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int bits,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamUIntN(
      fn,
      bits,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamUIntNPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamUIntN');
  late final _TWEthereumAbiFunctionAddParamUIntN =
      _TWEthereumAbiFunctionAddParamUIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData1>, bool)>();

  /// Add a int8 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt8(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int8,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt8');
  late final _TWEthereumAbiFunctionAddParamInt8 =
      _TWEthereumAbiFunctionAddParamInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int16 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt16(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int16,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt16');
  late final _TWEthereumAbiFunctionAddParamInt16 =
      _TWEthereumAbiFunctionAddParamInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int32 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt32(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int32,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt32');
  late final _TWEthereumAbiFunctionAddParamInt32 =
      _TWEthereumAbiFunctionAddParamInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int64 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt64(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int64,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt64');
  late final _TWEthereumAbiFunctionAddParamInt64 =
      _TWEthereumAbiFunctionAddParamInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Add a int256 type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified (stored in a block of data)
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamInt256(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamInt256');
  late final _TWEthereumAbiFunctionAddParamInt256 =
      _TWEthereumAbiFunctionAddParamInt256Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData1>,
              bool)>();

  /// Add a int(bits) type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int bits,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamIntN(
      fn,
      bits,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamIntNPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamIntN');
  late final _TWEthereumAbiFunctionAddParamIntN =
      _TWEthereumAbiFunctionAddParamIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData1>, bool)>();

  /// Add a bool type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    bool val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBool(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Bool,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBool');
  late final _TWEthereumAbiFunctionAddParamBool =
      _TWEthereumAbiFunctionAddParamBoolPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, bool, bool)>();

  /// Add a string type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWString1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamString(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWString1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamString');
  late final _TWEthereumAbiFunctionAddParamString =
      _TWEthereumAbiFunctionAddParamStringPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWString1>, bool)>();

  /// Add an address type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamAddress(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamAddress');
  late final _TWEthereumAbiFunctionAddParamAddress =
      _TWEthereumAbiFunctionAddParamAddressPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData1>,
              bool)>();

  /// Add a bytes type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBytes(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBytes(
      fn,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBytesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBytes');
  late final _TWEthereumAbiFunctionAddParamBytes =
      _TWEthereumAbiFunctionAddParamBytesPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Pointer<TWData1>,
              bool)>();

  /// Add a bytes[N] type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param size fixed size of the bytes array parameter (val).
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamBytesFix(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int size,
    ffi.Pointer<TWData1> val,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamBytesFix(
      fn,
      size,
      val,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamBytesFixPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(
              ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Size,
              ffi.Pointer<TWData1>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamBytesFix');
  late final _TWEthereumAbiFunctionAddParamBytesFix =
      _TWEthereumAbiFunctionAddParamBytesFixPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWData1>, bool)>();

  /// Add a type[] type parameter
  ///
  /// \param fn A Non-null eth abi function
  /// \param val for output parameters, value has to be specified
  /// \param isOutput determines if the parameter is an input or output
  /// \return the index of the parameter (0-based).
  int TWEthereumAbiFunctionAddParamArray(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionAddParamArray(
      fn,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionAddParamArrayPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Bool)>>('TWEthereumAbiFunctionAddParamArray');
  late final _TWEthereumAbiFunctionAddParamArray =
      _TWEthereumAbiFunctionAddParamArrayPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, bool)>();

  /// Get a uint8 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  int TWEthereumAbiFunctionGetParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt8(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint8 Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt8');
  late final _TWEthereumAbiFunctionGetParamUInt8 =
      _TWEthereumAbiFunctionGetParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a uint64 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  int TWEthereumAbiFunctionGetParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt64(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Uint64 Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt64');
  late final _TWEthereumAbiFunctionGetParamUInt64 =
      _TWEthereumAbiFunctionGetParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a uint256 type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter stored in a block of data.
  ffi.Pointer<TWData1> TWEthereumAbiFunctionGetParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamUInt256(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamUInt256Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamUInt256');
  late final _TWEthereumAbiFunctionGetParamUInt256 =
      _TWEthereumAbiFunctionGetParamUInt256Ptr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a bool type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  bool TWEthereumAbiFunctionGetParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamBool(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionGetParamBool');
  late final _TWEthereumAbiFunctionGetParamBool =
      _TWEthereumAbiFunctionGetParamBoolPtr.asFunction<
          bool Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get a string type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  ffi.Pointer<TWString1> TWEthereumAbiFunctionGetParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamString(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamString');
  late final _TWEthereumAbiFunctionGetParamString =
      _TWEthereumAbiFunctionGetParamStringPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Get an address type parameter at the given index
  ///
  /// \param fn A Non-null eth abi function
  /// \param idx index for the parameter (0-based).
  /// \param isOutput determines if the parameter is an input or output
  /// \return the value of the parameter.
  ffi.Pointer<TWData1> TWEthereumAbiFunctionGetParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int idx,
    bool isOutput,
  ) {
    return _TWEthereumAbiFunctionGetParamAddress(
      fn,
      idx,
      isOutput,
    );
  }

  late final _TWEthereumAbiFunctionGetParamAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWEthereumAbiFunction>,
              ffi.Int, ffi.Bool)>>('TWEthereumAbiFunctionGetParamAddress');
  late final _TWEthereumAbiFunctionGetParamAddress =
      _TWEthereumAbiFunctionGetParamAddressPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Adding a uint8 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt8(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint8)>>('TWEthereumAbiFunctionAddInArrayParamUInt8');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt8 =
      _TWEthereumAbiFunctionAddInArrayParamUInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint16 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt16(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint16)>>('TWEthereumAbiFunctionAddInArrayParamUInt16');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt16 =
      _TWEthereumAbiFunctionAddInArrayParamUInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint32 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt32(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint32)>>('TWEthereumAbiFunctionAddInArrayParamUInt32');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt32 =
      _TWEthereumAbiFunctionAddInArrayParamUInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt64(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Uint64)>>('TWEthereumAbiFunctionAddInArrayParamUInt64');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt64 =
      _TWEthereumAbiFunctionAddInArrayParamUInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a uint256 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUInt256(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUInt256Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamUInt256');
  late final _TWEthereumAbiFunctionAddInArrayParamUInt256 =
      _TWEthereumAbiFunctionAddInArrayParamUInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData1>)>();

  /// Adding a uint[N] type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamUIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int bits,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamUIntN(
      fn,
      arrayIdx,
      bits,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamUIntNPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Int, ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamUIntN');
  late final _TWEthereumAbiFunctionAddInArrayParamUIntN =
      _TWEthereumAbiFunctionAddInArrayParamUIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData1>)>();

  /// Adding a int8 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt8(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt8(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt8Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int8)>>('TWEthereumAbiFunctionAddInArrayParamInt8');
  late final _TWEthereumAbiFunctionAddInArrayParamInt8 =
      _TWEthereumAbiFunctionAddInArrayParamInt8Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int16 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt16(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt16(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt16Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int16)>>('TWEthereumAbiFunctionAddInArrayParamInt16');
  late final _TWEthereumAbiFunctionAddInArrayParamInt16 =
      _TWEthereumAbiFunctionAddInArrayParamInt16Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int32 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt32(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt32(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt32Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int32)>>('TWEthereumAbiFunctionAddInArrayParamInt32');
  late final _TWEthereumAbiFunctionAddInArrayParamInt32 =
      _TWEthereumAbiFunctionAddInArrayParamInt32Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt64(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt64(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt64Ptr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Int64)>>('TWEthereumAbiFunctionAddInArrayParamInt64');
  late final _TWEthereumAbiFunctionAddInArrayParamInt64 =
      _TWEthereumAbiFunctionAddInArrayParamInt64Ptr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int)>();

  /// Adding a int256 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamInt256(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamInt256(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamInt256Ptr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamInt256');
  late final _TWEthereumAbiFunctionAddInArrayParamInt256 =
      _TWEthereumAbiFunctionAddInArrayParamInt256Ptr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData1>)>();

  /// Adding a int[N] type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param bits Number of bits of the integer parameter
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter stored in a block of data
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamIntN(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int bits,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamIntN(
      fn,
      arrayIdx,
      bits,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamIntNPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Int, ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamIntN');
  late final _TWEthereumAbiFunctionAddInArrayParamIntN =
      _TWEthereumAbiFunctionAddInArrayParamIntNPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData1>)>();

  /// Adding a bool type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBool(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    bool val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBool(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBoolPtr = _lookup<
      ffi.NativeFunction<
          ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
              ffi.Bool)>>('TWEthereumAbiFunctionAddInArrayParamBool');
  late final _TWEthereumAbiFunctionAddInArrayParamBool =
      _TWEthereumAbiFunctionAddInArrayParamBoolPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, bool)>();

  /// Adding a string type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamString(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWString1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamString(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamStringPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWString1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamString');
  late final _TWEthereumAbiFunctionAddInArrayParamString =
      _TWEthereumAbiFunctionAddInArrayParamStringPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int,
              ffi.Pointer<TWString1>)>();

  /// Adding an address type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamAddress(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamAddress(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamAddressPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamAddress');
  late final _TWEthereumAbiFunctionAddInArrayParamAddress =
      _TWEthereumAbiFunctionAddInArrayParamAddressPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData1>)>();

  /// Adding a bytes type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBytes(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBytes(
      fn,
      arrayIdx,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBytesPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamBytes');
  late final _TWEthereumAbiFunctionAddInArrayParamBytes =
      _TWEthereumAbiFunctionAddInArrayParamBytesPtr.asFunction<
          int Function(
              ffi.Pointer<TWEthereumAbiFunction>, int, ffi.Pointer<TWData1>)>();

  /// Adding a int64 type parameter of to the top-level input parameter array
  ///
  /// \param fn A Non-null eth abi function
  /// \param arrayIdx array index for the abi function (0-based).
  /// \param size fixed size of the bytes array parameter (val).
  /// \param val the value of the parameter
  /// \return the index of the added parameter (0-based).
  int TWEthereumAbiFunctionAddInArrayParamBytesFix(
    ffi.Pointer<TWEthereumAbiFunction> fn,
    int arrayIdx,
    int size,
    ffi.Pointer<TWData1> val,
  ) {
    return _TWEthereumAbiFunctionAddInArrayParamBytesFix(
      fn,
      arrayIdx,
      size,
      val,
    );
  }

  late final _TWEthereumAbiFunctionAddInArrayParamBytesFixPtr = _lookup<
          ffi.NativeFunction<
              ffi.Int Function(ffi.Pointer<TWEthereumAbiFunction>, ffi.Int,
                  ffi.Size, ffi.Pointer<TWData1>)>>(
      'TWEthereumAbiFunctionAddInArrayParamBytesFix');
  late final _TWEthereumAbiFunctionAddInArrayParamBytesFix =
      _TWEthereumAbiFunctionAddInArrayParamBytesFixPtr.asFunction<
          int Function(ffi.Pointer<TWEthereumAbiFunction>, int, int,
              ffi.Pointer<TWData1>)>();

  /// Returns the checksummed address.
  ///
  /// \param address *non-null* string.
  /// \return the checksummed address.
  ffi.Pointer<TWString> TWEthereumAddressChecksummed(
    ffi.Pointer<TWString> address,
  ) {
    return _TWEthereumAddressChecksummed(
      address,
    );
  }

  late final _TWEthereumAddressChecksummedPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>)>>('TWEthereumAddressChecksummed');
  late final _TWEthereumAddressChecksummed = _TWEthereumAddressChecksummedPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Returns the account path from address.
  ///
  /// \param eth_address *non-null* string.
  /// \param layer *non-null* string.
  /// \param application *non-null* string.
  /// \param index *non-null* string.
  /// \return the account path.
  ffi.Pointer<TWString> TWEthereumEip2645GetPath(
    ffi.Pointer<TWString> ethAddress,
    ffi.Pointer<TWString> layer,
    ffi.Pointer<TWString> application,
    ffi.Pointer<TWString> index,
  ) {
    return _TWEthereumEip2645GetPath(
      ethAddress,
      layer,
      application,
      index,
    );
  }

  late final _TWEthereumEip2645GetPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWEthereumEip2645GetPath');
  late final _TWEthereumEip2645GetPath =
      _TWEthereumEip2645GetPathPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Returns EIP-1014 Create2 address
  ///
  /// \param from *non-null* string.
  /// \param salt *non-null* data.
  /// \param init_code_hash *non-null* data.
  /// \return the EIP-1014 Create2 address.
  ffi.Pointer<TWString> TWEthereumEip1014Create2Address(
    ffi.Pointer<TWString> from,
    ffi.Pointer<TWData> salt,
    ffi.Pointer<TWData> initCodeHash,
  ) {
    return _TWEthereumEip1014Create2Address(
      from,
      salt,
      initCodeHash,
    );
  }

  late final _TWEthereumEip1014Create2AddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>,
              ffi.Pointer<TWData>,
              ffi.Pointer<TWData>)>>('TWEthereumEip1014Create2Address');
  late final _TWEthereumEip1014Create2Address =
      _TWEthereumEip1014Create2AddressPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>, ffi.Pointer<TWData>)>();

  /// Returns EIP-1967 proxy init code
  ///
  /// \param logic_address *non-null* string.
  /// \param data *non-null* data.
  /// \return the EIP-1967 proxy init code.
  ffi.Pointer<TWData> TWEthereumEip1967ProxyInitCode(
    ffi.Pointer<TWString> logicAddress,
    ffi.Pointer<TWData> data,
  ) {
    return _TWEthereumEip1967ProxyInitCode(
      logicAddress,
      data,
    );
  }

  late final _TWEthereumEip1967ProxyInitCodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWData>)>>('TWEthereumEip1967ProxyInitCode');
  late final _TWEthereumEip1967ProxyInitCode =
      _TWEthereumEip1967ProxyInitCodePtr.asFunction<
          ffi.Pointer<TWData> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWData>)>();

  /// Encrypts a block of Data using AES in Cipher Block Chaining (CBC) mode.
  ///
  /// \param key encryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to encrypt.
  /// \param iv initialization vector.
  /// \param mode padding mode.
  /// \return encrypted Data.
  ffi.Pointer<TWData1> TWAESEncryptCBC(
    ffi.Pointer<TWData1> key,
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWData1> iv,
    int mode,
  ) {
    return _TWAESEncryptCBC(
      key,
      data,
      iv,
      mode,
    );
  }

  late final _TWAESEncryptCBCPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Int32)>>('TWAESEncryptCBC');
  late final _TWAESEncryptCBC = _TWAESEncryptCBCPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>, int)>();

  /// Decrypts a block of data using AES in Cipher Block Chaining (CBC) mode.
  ///
  /// \param key decryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to decrypt.
  /// \param iv initialization vector Data.
  /// \param mode padding mode.
  /// \return decrypted Data.
  ffi.Pointer<TWData1> TWAESDecryptCBC(
    ffi.Pointer<TWData1> key,
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWData1> iv,
    int mode,
  ) {
    return _TWAESDecryptCBC(
      key,
      data,
      iv,
      mode,
    );
  }

  late final _TWAESDecryptCBCPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Int32)>>('TWAESDecryptCBC');
  late final _TWAESDecryptCBC = _TWAESDecryptCBCPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>, ffi.Pointer<TWData1>,
          ffi.Pointer<TWData1>, int)>();

  /// Encrypts a block of data using AES in Counter (CTR) mode.
  ///
  /// \param key encryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to encrypt.
  /// \param iv initialization vector Data.
  /// \return encrypted Data.
  ffi.Pointer<TWData1> TWAESEncryptCTR(
    ffi.Pointer<TWData1> key,
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWData1> iv,
  ) {
    return _TWAESEncryptCTR(
      key,
      data,
      iv,
    );
  }

  late final _TWAESEncryptCTRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>>('TWAESEncryptCTR');
  late final _TWAESEncryptCTR = _TWAESEncryptCTRPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>();

  /// Decrypts a block of data using AES in Counter (CTR) mode.
  ///
  /// \param key decryption key Data, must be 16, 24, or 32 bytes long.
  /// \param data Data to decrypt.
  /// \param iv initialization vector Data.
  /// \return decrypted Data.
  ffi.Pointer<TWData1> TWAESDecryptCTR(
    ffi.Pointer<TWData1> key,
    ffi.Pointer<TWData1> data,
    ffi.Pointer<TWData1> iv,
  ) {
    return _TWAESDecryptCTR(
      key,
      data,
      iv,
    );
  }

  late final _TWAESDecryptCTRPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>>('TWAESDecryptCTR');
  late final _TWAESDecryptCTR = _TWAESDecryptCTRPtr.asFunction<
      ffi.Pointer<TWData1> Function(
          ffi.Pointer<TWData1>, ffi.Pointer<TWData1>, ffi.Pointer<TWData1>)>();

  /// Signs an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702)
  ///
  /// \param chain_id The chain ID of the user.
  /// \param contract_address The address of the smart contract wallet.
  /// \param nonce The nonce of the user.
  /// \param private_key The private key of the user.
  /// \return The signed authorization.
  ffi.Pointer<TWString1> TWEip7702SignAuthorization(
    ffi.Pointer<TWData1> chainId,
    ffi.Pointer<TWString1> contractAddress,
    ffi.Pointer<TWData1> nonce,
    ffi.Pointer<TWString1> privateKey,
  ) {
    return _TWEip7702SignAuthorization(
      chainId,
      contractAddress,
      nonce,
      privateKey,
    );
  }

  late final _TWEip7702SignAuthorizationPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWEip7702SignAuthorization');
  late final _TWEip7702SignAuthorization =
      _TWEip7702SignAuthorizationPtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>();

  /// Computes an Authorization hash in [EIP-7702 format](https://eips.ethereum.org/EIPS/eip-7702)
  /// `keccak256('0x05' || rlp([chain_id, address, nonce]))`.
  ///
  /// \param chain_id The chain ID of the user.
  /// \param contract_address The address of the smart contract wallet.
  /// \param nonce The nonce of the user.
  /// \return The authorization hash.
  ffi.Pointer<TWData1> TWEip7702GetAuthorizationHash(
    ffi.Pointer<TWData1> chainId,
    ffi.Pointer<TWString1> contractAddress,
    ffi.Pointer<TWData1> nonce,
  ) {
    return _TWEip7702GetAuthorizationHash(
      chainId,
      contractAddress,
      nonce,
    );
  }

  late final _TWEip7702GetAuthorizationHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>)>>('TWEip7702GetAuthorizationHash');
  late final _TWEip7702GetAuthorizationHash =
      _TWEip7702GetAuthorizationHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>)>();

  /// Decode Solana transaction, update the recent blockhash and re-sign the transaction.
  ///
  /// # Warning
  ///
  /// This is a temporary solution. It will be removed when `Solana.proto` supports
  /// direct transaction signing.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \param recent_blockhash base58 encoded recent blockhash.
  /// \param private_keys list of private keys that should be used to re-sign the transaction.
  /// \return serialized `Solana::Proto::SigningOutput`.
  ffi.Pointer<TWData> TWSolanaTransactionUpdateBlockhashAndSign(
    ffi.Pointer<TWString> encodedTx,
    ffi.Pointer<TWString> recentBlockhash,
    ffi.Pointer<TWDataVector> privateKeys,
  ) {
    return _TWSolanaTransactionUpdateBlockhashAndSign(
      encodedTx,
      recentBlockhash,
      privateKeys,
    );
  }

  late final _TWSolanaTransactionUpdateBlockhashAndSignPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
                  ffi.Pointer<TWString>, ffi.Pointer<TWDataVector>)>>(
      'TWSolanaTransactionUpdateBlockhashAndSign');
  late final _TWSolanaTransactionUpdateBlockhashAndSign =
      _TWSolanaTransactionUpdateBlockhashAndSignPtr.asFunction<
          ffi.Pointer<TWData> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>, ffi.Pointer<TWDataVector>)>();

  /// Try to find a `ComputeBudgetInstruction::SetComputeUnitPrice` instruction in the given transaction,
  /// and returns the specified Unit Price.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \return nullable Unit Price as a decimal string. Null if no instruction found.
  ffi.Pointer<TWString> TWSolanaTransactionGetComputeUnitPrice(
    ffi.Pointer<TWString> encodedTx,
  ) {
    return _TWSolanaTransactionGetComputeUnitPrice(
      encodedTx,
    );
  }

  late final _TWSolanaTransactionGetComputeUnitPricePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>>(
      'TWSolanaTransactionGetComputeUnitPrice');
  late final _TWSolanaTransactionGetComputeUnitPrice =
      _TWSolanaTransactionGetComputeUnitPricePtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Try to find a `ComputeBudgetInstruction::SetComputeUnitLimit` instruction in the given transaction,
  /// and returns the specified Unit Limit.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \return nullable Unit Limit as a decimal string. Null if no instruction found.
  ffi.Pointer<TWString> TWSolanaTransactionGetComputeUnitLimit(
    ffi.Pointer<TWString> encodedTx,
  ) {
    return _TWSolanaTransactionGetComputeUnitLimit(
      encodedTx,
    );
  }

  late final _TWSolanaTransactionGetComputeUnitLimitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>>(
      'TWSolanaTransactionGetComputeUnitLimit');
  late final _TWSolanaTransactionGetComputeUnitLimit =
      _TWSolanaTransactionGetComputeUnitLimitPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>)>();

  /// Adds or updates a `ComputeBudgetInstruction::SetComputeUnitPrice` instruction of the given transaction,
  /// and returns the updated transaction.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \price Unit Price as a decimal string.
  /// \return base64 encoded Solana transaction. Null if an error occurred.
  ffi.Pointer<TWString> TWSolanaTransactionSetComputeUnitPrice(
    ffi.Pointer<TWString> encodedTx,
    ffi.Pointer<TWString> price,
  ) {
    return _TWSolanaTransactionSetComputeUnitPrice(
      encodedTx,
      price,
    );
  }

  late final _TWSolanaTransactionSetComputeUnitPricePtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWString>, ffi.Pointer<TWString>)>>(
      'TWSolanaTransactionSetComputeUnitPrice');
  late final _TWSolanaTransactionSetComputeUnitPrice =
      _TWSolanaTransactionSetComputeUnitPricePtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Adds or updates a `ComputeBudgetInstruction::SetComputeUnitLimit` instruction of the given transaction,
  /// and returns the updated transaction.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \limit Unit Limit as a decimal string.
  /// \return base64 encoded Solana transaction. Null if an error occurred.
  ffi.Pointer<TWString> TWSolanaTransactionSetComputeUnitLimit(
    ffi.Pointer<TWString> encodedTx,
    ffi.Pointer<TWString> limit,
  ) {
    return _TWSolanaTransactionSetComputeUnitLimit(
      encodedTx,
      limit,
    );
  }

  late final _TWSolanaTransactionSetComputeUnitLimitPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWString>, ffi.Pointer<TWString>)>>(
      'TWSolanaTransactionSetComputeUnitLimit');
  late final _TWSolanaTransactionSetComputeUnitLimit =
      _TWSolanaTransactionSetComputeUnitLimitPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Adds fee payer to the given transaction, and returns the updated transaction.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \param fee_payer fee payer account address. Must be a base58 encoded public key. It must NOT be in the account list yet.
  /// \return base64 encoded Solana transaction. Null if an error occurred.
  ffi.Pointer<TWString> TWSolanaTransactionSetFeePayer(
    ffi.Pointer<TWString> encodedTx,
    ffi.Pointer<TWString> feePayer,
  ) {
    return _TWSolanaTransactionSetFeePayer(
      encodedTx,
      feePayer,
    );
  }

  late final _TWSolanaTransactionSetFeePayerPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWSolanaTransactionSetFeePayer');
  late final _TWSolanaTransactionSetFeePayer =
      _TWSolanaTransactionSetFeePayerPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>, ffi.Pointer<TWString>)>();

  /// Inserts an instruction to the given transaction at the specified position, returning the updated transaction.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \param insert_at index where the instruction should be inserted. If you don't care about the position, use -1.
  /// \param instruction json encoded instruction. Here is an example: {"programId":"11111111111111111111111111111111","accounts":[{"pubkey":"YUz1AupPEy1vttBeDS7sXYZFhQJppcXMzjDiDx18Srf","isSigner":true,"isWritable":true},{"pubkey":"d8DiHEeHKdXkM2ZupT86mrvavhmJwUZjHPCzMiB5Lqb","isSigner":false,"isWritable":true}],"data":"3Bxs4Z6oyhaczjLK"}
  /// \return base64 encoded Solana transaction. Null if an error occurred.
  ffi.Pointer<TWString> TWSolanaTransactionInsertInstruction(
    ffi.Pointer<TWString> encodedTx,
    int insertAt,
    ffi.Pointer<TWString> instruction,
  ) {
    return _TWSolanaTransactionInsertInstruction(
      encodedTx,
      insertAt,
      instruction,
    );
  }

  late final _TWSolanaTransactionInsertInstructionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWString>, ffi.Int32,
              ffi.Pointer<TWString>)>>('TWSolanaTransactionInsertInstruction');
  late final _TWSolanaTransactionInsertInstruction =
      _TWSolanaTransactionInsertInstructionPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>, int, ffi.Pointer<TWString>)>();

  /// Inserts a SOL transfer instruction to the given transaction at the specified position, returning the updated transaction.
  /// Please note that compute price and limit instructions should always be the first instructions if they are present in the transaction.
  ///
  /// \param encoded_tx base64 encoded Solana transaction.
  /// \param insert_at index where the instruction should be inserted. If you don't care about the position, use -1.
  /// \param from sender account from which the lamports will be debited.
  /// \param to receiver account to which the lamports will be transferred.
  /// \param lamports amount of lamports to transfer, as a decimal string.
  /// \return base64 encoded Solana transaction. Null if an error occurred.
  ffi.Pointer<TWString> TWSolanaTransactionInsertTransferInstruction(
    ffi.Pointer<TWString> encodedTx,
    int insertAt,
    ffi.Pointer<TWString> from,
    ffi.Pointer<TWString> to,
    ffi.Pointer<TWString> lamports,
  ) {
    return _TWSolanaTransactionInsertTransferInstruction(
      encodedTx,
      insertAt,
      from,
      to,
      lamports,
    );
  }

  late final _TWSolanaTransactionInsertTransferInstructionPtr = _lookup<
          ffi.NativeFunction<
              ffi.Pointer<TWString> Function(
                  ffi.Pointer<TWString>,
                  ffi.Int32,
                  ffi.Pointer<TWString>,
                  ffi.Pointer<TWString>,
                  ffi.Pointer<TWString>)>>(
      'TWSolanaTransactionInsertTransferInstruction');
  late final _TWSolanaTransactionInsertTransferInstruction =
      _TWSolanaTransactionInsertTransferInstructionPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWString>,
              int,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>();

  /// Create a NEAR Account
  ///
  /// \param string Account name
  /// \note Account should be deleted by calling \TWNEARAccountDelete
  /// \return Pointer to a nullable NEAR Account.
  ffi.Pointer<TWNEARAccount> TWNEARAccountCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWNEARAccountCreateWithString(
      string,
    );
  }

  late final _TWNEARAccountCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWNEARAccount> Function(
              ffi.Pointer<TWString>)>>('TWNEARAccountCreateWithString');
  late final _TWNEARAccountCreateWithString = _TWNEARAccountCreateWithStringPtr
      .asFunction<ffi.Pointer<TWNEARAccount> Function(ffi.Pointer<TWString>)>();

  /// Delete the given Near Account
  ///
  /// \param account Pointer to a non-null NEAR Account
  void TWNEARAccountDelete(
    ffi.Pointer<TWNEARAccount> account,
  ) {
    return _TWNEARAccountDelete(
      account,
    );
  }

  late final _TWNEARAccountDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWNEARAccount>)>>(
      'TWNEARAccountDelete');
  late final _TWNEARAccountDelete = _TWNEARAccountDeletePtr.asFunction<
      void Function(ffi.Pointer<TWNEARAccount>)>();

  /// Returns the user friendly string representation.
  ///
  /// \param account Pointer to a non-null NEAR Account
  /// \return Non-null string account description
  ffi.Pointer<TWString> TWNEARAccountDescription(
    ffi.Pointer<TWNEARAccount> account,
  ) {
    return _TWNEARAccountDescription(
      account,
    );
  }

  late final _TWNEARAccountDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWNEARAccount>)>>('TWNEARAccountDescription');
  late final _TWNEARAccountDescription = _TWNEARAccountDescriptionPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWNEARAccount>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param address: the address that matches the privateKey, must be a legacy address (P2PKH)
  /// \param message: A custom message which is input to the signing.
  /// \note Address is derived assuming compressed public key format.
  /// \returns the signature, Base64-encoded.  On invalid input empty string is returned. Returned object needs to be deleteed after use.
  ffi.Pointer<TWString1> TWBitcoinMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> address,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWBitcoinMessageSignerSignMessage(
      privateKey,
      address,
      message,
    );
  }

  late final _TWBitcoinMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWBitcoinMessageSignerSignMessage');
  late final _TWBitcoinMessageSignerSignMessage =
      _TWBitcoinMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>, ffi.Pointer<TWString1>)>();

  /// Verify signature for a message.
  ///
  /// \param address: address to use, only legacy is supported
  /// \param message: the message signed (without prefix)
  /// \param signature: in Base64-encoded form.
  /// \returns false on any invalid input (does not throw).
  bool TWBitcoinMessageSignerVerifyMessage(
    ffi.Pointer<TWString1> address,
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWBitcoinMessageSignerVerifyMessage(
      address,
      message,
      signature,
    );
  }

  late final _TWBitcoinMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWString1>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWBitcoinMessageSignerVerifyMessage');
  late final _TWBitcoinMessageSignerVerifyMessage =
      _TWBitcoinMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWString1>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Creates a new Account with an address, a coin type, derivation enum, derivationPath, publicKey,
  /// and extendedPublicKey. Must be deleted with TWAccountDelete after use.
  ///
  /// \param address The address of the Account.
  /// \param coin The coin type of the Account.
  /// \param derivation The derivation of the Account.
  /// \param derivationPath The derivation path of the Account.
  /// \param publicKey hex encoded public key.
  /// \param extendedPublicKey Base58 encoded extended public key.
  /// \return A new Account.
  ffi.Pointer<TWAccount> TWAccountCreate(
    ffi.Pointer<TWString> address,
    int coin,
    int derivation,
    ffi.Pointer<TWString> derivationPath,
    ffi.Pointer<TWString> publicKey,
    ffi.Pointer<TWString> extendedPublicKey,
  ) {
    return _TWAccountCreate(
      address,
      coin,
      derivation,
      derivationPath,
      publicKey,
      extendedPublicKey,
    );
  }

  late final _TWAccountCreatePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWAccount> Function(
              ffi.Pointer<TWString>,
              ffi.Int32,
              ffi.Int32,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>,
              ffi.Pointer<TWString>)>>('TWAccountCreate');
  late final _TWAccountCreate = _TWAccountCreatePtr.asFunction<
      ffi.Pointer<TWAccount> Function(
          ffi.Pointer<TWString>,
          int,
          int,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>,
          ffi.Pointer<TWString>)>();

  /// Deletes an account.
  ///
  /// \param account Account to delete.
  void TWAccountDelete(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDelete(
      account,
    );
  }

  late final _TWAccountDeletePtr =
      _lookup<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWAccount>)>>(
          'TWAccountDelete');
  late final _TWAccountDelete =
      _TWAccountDeletePtr.asFunction<void Function(ffi.Pointer<TWAccount>)>();

  /// Returns the address of an account.
  ///
  /// \param account Account to get the address of.
  ffi.Pointer<TWString> TWAccountAddress(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountAddress(
      account,
    );
  }

  late final _TWAccountAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountAddress');
  late final _TWAccountAddress = _TWAccountAddressPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Return CoinType enum of an account.
  ///
  /// \param account Account to get the coin type of.
  int TWAccountCoin(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountCoin(
      account,
    );
  }

  late final _TWAccountCoinPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<TWAccount>)>>(
          'TWAccountCoin');
  late final _TWAccountCoin =
      _TWAccountCoinPtr.asFunction<int Function(ffi.Pointer<TWAccount>)>();

  /// Returns the derivation enum of an account.
  ///
  /// \param account Account to get the derivation enum of.
  int TWAccountDerivation(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDerivation(
      account,
    );
  }

  late final _TWAccountDerivationPtr =
      _lookup<ffi.NativeFunction<ffi.Int32 Function(ffi.Pointer<TWAccount>)>>(
          'TWAccountDerivation');
  late final _TWAccountDerivation = _TWAccountDerivationPtr.asFunction<
      int Function(ffi.Pointer<TWAccount>)>();

  /// Returns derivationPath of an account.
  ///
  /// \param account Account to get the derivation path of.
  ffi.Pointer<TWString> TWAccountDerivationPath(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountDerivationPath(
      account,
    );
  }

  late final _TWAccountDerivationPathPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountDerivationPath');
  late final _TWAccountDerivationPath = _TWAccountDerivationPathPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Returns hex encoded publicKey of an account.
  ///
  /// \param account Account to get the public key of.
  ffi.Pointer<TWString> TWAccountPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountPublicKey(
      account,
    );
  }

  late final _TWAccountPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountPublicKey');
  late final _TWAccountPublicKey = _TWAccountPublicKeyPtr.asFunction<
      ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Returns Base58 encoded extendedPublicKey of an account.
  ///
  /// \param account Account to get the extended public key of.
  ffi.Pointer<TWString> TWAccountExtendedPublicKey(
    ffi.Pointer<TWAccount> account,
  ) {
    return _TWAccountExtendedPublicKey(
      account,
    );
  }

  late final _TWAccountExtendedPublicKeyPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWAccount>)>>('TWAccountExtendedPublicKey');
  late final _TWAccountExtendedPublicKey = _TWAccountExtendedPublicKeyPtr
      .asFunction<ffi.Pointer<TWString> Function(ffi.Pointer<TWAccount>)>();

  /// Signs an arbitrary message to prove ownership of an address for off-chain services.
  ///
  /// \param coin The given coin type to sign the message for.
  /// \param input The serialized data of a signing input (e.g. TW.Ethereum.Proto.MessageSigningInput).
  /// \return The serialized data of a `SigningOutput` proto object. (e.g. TW.Ethereum.Proto.MessageSigningOutput).
  ffi.Pointer<TWData> TWMessageSignerSign(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWMessageSignerSign(
      coin,
      input,
    );
  }

  late final _TWMessageSignerSignPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(
              ffi.Int32, ffi.Pointer<TWData>)>>('TWMessageSignerSign');
  late final _TWMessageSignerSign = _TWMessageSignerSignPtr.asFunction<
      ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Verifies a signature for a message.
  ///
  /// \param coin The given coin type to sign the message for.
  /// \param input The serialized data of a verifying input (e.g. TW.Ethereum.Proto.MessageVerifyingInput).
  /// \return whether the signature is valid.
  bool TWMessageSignerVerify(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWMessageSignerVerify(
      coin,
      input,
    );
  }

  late final _TWMessageSignerVerifyPtr = _lookup<
          ffi
          .NativeFunction<ffi.Bool Function(ffi.Int32, ffi.Pointer<TWData>)>>(
      'TWMessageSignerVerify');
  late final _TWMessageSignerVerify = _TWMessageSignerVerifyPtr.asFunction<
      bool Function(int, ffi.Pointer<TWData>)>();

  /// Computes preimage hashes of a message.
  ///
  /// \param coin The given coin type to sign the message for.
  /// \param input The serialized data of a signing input (e.g. TW.Ethereum.Proto.MessageSigningInput).
  /// \return The serialized data of TW.TxCompiler.PreSigningOutput.
  ffi.Pointer<TWData> TWMessageSignerPreImageHashes(
    int coin,
    ffi.Pointer<TWData> input,
  ) {
    return _TWMessageSignerPreImageHashes(
      coin,
      input,
    );
  }

  late final _TWMessageSignerPreImageHashesPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData> Function(ffi.Int32,
              ffi.Pointer<TWData>)>>('TWMessageSignerPreImageHashes');
  late final _TWMessageSignerPreImageHashes = _TWMessageSignerPreImageHashesPtr
      .asFunction<ffi.Pointer<TWData> Function(int, ffi.Pointer<TWData>)>();

  /// Sign a message.
  ///
  /// \param privateKey: the private key used for signing
  /// \param message: A custom hex message which is input to the signing.
  /// \returns the signature, Hex-encoded. On invalid input empty string is returned. Returned object needs to be deleted after use.
  ffi.Pointer<TWString1> TWStarkExMessageSignerSignMessage(
    ffi.Pointer<TWPrivateKey> privateKey,
    ffi.Pointer<TWString1> message,
  ) {
    return _TWStarkExMessageSignerSignMessage(
      privateKey,
      message,
    );
  }

  late final _TWStarkExMessageSignerSignMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWPrivateKey>,
              ffi.Pointer<TWString1>)>>('TWStarkExMessageSignerSignMessage');
  late final _TWStarkExMessageSignerSignMessage =
      _TWStarkExMessageSignerSignMessagePtr.asFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWPrivateKey>, ffi.Pointer<TWString1>)>();

  /// Verify signature for a message.
  ///
  /// \param pubKey: pubKey that will verify and recover the message from the signature
  /// \param message: the message signed (without prefix) in hex
  /// \param signature: in Hex-encoded form.
  /// \returns false on any invalid input (does not throw), true if the message can be recovered from the signature
  bool TWStarkExMessageSignerVerifyMessage(
    ffi.Pointer<TWPublicKey> pubKey,
    ffi.Pointer<TWString1> message,
    ffi.Pointer<TWString1> signature,
  ) {
    return _TWStarkExMessageSignerVerifyMessage(
      pubKey,
      message,
      signature,
    );
  }

  late final _TWStarkExMessageSignerVerifyMessagePtr = _lookup<
      ffi.NativeFunction<
          ffi.Bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>>('TWStarkExMessageSignerVerifyMessage');
  late final _TWStarkExMessageSignerVerifyMessage =
      _TWStarkExMessageSignerVerifyMessagePtr.asFunction<
          bool Function(ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>,
              ffi.Pointer<TWString1>)>();

  /// Creates an address from a string representation.
  ///
  /// \param string Non-null pointer to a solana address string
  /// \note Should be deleted with \TWSolanaAddressDelete
  /// \return Non-null pointer to a Solana address data structure
  ffi.Pointer<TWSolanaAddress> TWSolanaAddressCreateWithString(
    ffi.Pointer<TWString> string,
  ) {
    return _TWSolanaAddressCreateWithString(
      string,
    );
  }

  late final _TWSolanaAddressCreateWithStringPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWSolanaAddress> Function(
              ffi.Pointer<TWString>)>>('TWSolanaAddressCreateWithString');
  late final _TWSolanaAddressCreateWithString =
      _TWSolanaAddressCreateWithStringPtr.asFunction<
          ffi.Pointer<TWSolanaAddress> Function(ffi.Pointer<TWString>)>();

  /// Delete the given Solana address
  ///
  /// \param address Non-null pointer to a Solana Address
  void TWSolanaAddressDelete(
    ffi.Pointer<TWSolanaAddress> address,
  ) {
    return _TWSolanaAddressDelete(
      address,
    );
  }

  late final _TWSolanaAddressDeletePtr = _lookup<
          ffi.NativeFunction<ffi.Void Function(ffi.Pointer<TWSolanaAddress>)>>(
      'TWSolanaAddressDelete');
  late final _TWSolanaAddressDelete = _TWSolanaAddressDeletePtr.asFunction<
      void Function(ffi.Pointer<TWSolanaAddress>)>();

  /// Derive default token address for token
  ///
  /// \param address Non-null pointer to a Solana Address
  /// \param tokenMintAddress Non-null pointer to a token mint address as a string
  /// \return Null pointer if the Default token address for a token is not found, valid pointer otherwise
  ffi.Pointer<TWString> TWSolanaAddressDefaultTokenAddress(
    ffi.Pointer<TWSolanaAddress> address,
    ffi.Pointer<TWString> tokenMintAddress,
  ) {
    return _TWSolanaAddressDefaultTokenAddress(
      address,
      tokenMintAddress,
    );
  }

  late final _TWSolanaAddressDefaultTokenAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWSolanaAddress>,
              ffi.Pointer<TWString>)>>('TWSolanaAddressDefaultTokenAddress');
  late final _TWSolanaAddressDefaultTokenAddress =
      _TWSolanaAddressDefaultTokenAddressPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWSolanaAddress>, ffi.Pointer<TWString>)>();

  /// Derive token 2022 address for token
  ///
  /// \param address Non-null pointer to a Solana Address
  /// \param tokenMintAddress Non-null pointer to a token mint address as a string
  /// \return Null pointer if the token 2022 address for a token is not found, valid pointer otherwise
  ffi.Pointer<TWString> TWSolanaAddressToken2022Address(
    ffi.Pointer<TWSolanaAddress> address,
    ffi.Pointer<TWString> tokenMintAddress,
  ) {
    return _TWSolanaAddressToken2022Address(
      address,
      tokenMintAddress,
    );
  }

  late final _TWSolanaAddressToken2022AddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWSolanaAddress>,
              ffi.Pointer<TWString>)>>('TWSolanaAddressToken2022Address');
  late final _TWSolanaAddressToken2022Address =
      _TWSolanaAddressToken2022AddressPtr.asFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWSolanaAddress>, ffi.Pointer<TWString>)>();

  /// Returns the address string representation.
  ///
  /// \param address Non-null pointer to a Solana Address
  /// \return Non-null pointer to the Solana address string representation
  ffi.Pointer<TWString> TWSolanaAddressDescription(
    ffi.Pointer<TWSolanaAddress> address,
  ) {
    return _TWSolanaAddressDescription(
      address,
    );
  }

  late final _TWSolanaAddressDescriptionPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString> Function(
              ffi.Pointer<TWSolanaAddress>)>>('TWSolanaAddressDescription');
  late final _TWSolanaAddressDescription =
      _TWSolanaAddressDescriptionPtr.asFunction<
          ffi.Pointer<TWString> Function(ffi.Pointer<TWSolanaAddress>)>();

  /// Encodes data as a Bech32 string.
  ///
  /// \param hrp The human-readable part.
  /// \param data The data part.
  /// \return the encoded Bech32 string.
  ffi.Pointer<TWString1> TWBech32Encode(
    ffi.Pointer<TWString1> hrp,
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBech32Encode(
      hrp,
      data,
    );
  }

  late final _TWBech32EncodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWString1>, ffi.Pointer<TWData1>)>>('TWBech32Encode');
  late final _TWBech32Encode = _TWBech32EncodePtr.asFunction<
      ffi.Pointer<TWString1> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWData1>)>();

  /// Decodes a Bech32 string. Returns null if the string is not a valid Bech32 string.
  ///
  /// \param string The Bech32 string to decode.
  /// \return the decoded data, null if the string is not a valid Bech32 string. Note that the human-readable part is not returned.
  ffi.Pointer<TWData1> TWBech32Decode(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBech32Decode(
      string,
    );
  }

  late final _TWBech32DecodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBech32Decode');
  late final _TWBech32Decode = _TWBech32DecodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Encodes data as a Bech32m string.
  ///
  /// \param hrp The human-readable part.
  /// \param data The data part.
  /// \return the encoded Bech32m string.
  ffi.Pointer<TWString1> TWBech32EncodeM(
    ffi.Pointer<TWString1> hrp,
    ffi.Pointer<TWData1> data,
  ) {
    return _TWBech32EncodeM(
      hrp,
      data,
    );
  }

  late final _TWBech32EncodeMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWString1>,
              ffi.Pointer<TWData1>)>>('TWBech32EncodeM');
  late final _TWBech32EncodeM = _TWBech32EncodeMPtr.asFunction<
      ffi.Pointer<TWString1> Function(
          ffi.Pointer<TWString1>, ffi.Pointer<TWData1>)>();

  /// Decodes a Bech32m string. Returns null if the string is not a valid Bech32m string.
  ///
  /// \param string The Bech32m string to decode.
  /// \return the decoded data, null if the string is not a valid Bech32m string. Note that the human-readable part is not returned.
  ffi.Pointer<TWData1> TWBech32DecodeM(
    ffi.Pointer<TWString1> string,
  ) {
    return _TWBech32DecodeM(
      string,
    );
  }

  late final _TWBech32DecodeMPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>)>>('TWBech32DecodeM');
  late final _TWBech32DecodeM = _TWBech32DecodeMPtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>)>();

  /// Calculate a counterfactual address for the smart contract wallet
  ///
  /// \param input The serialized data of ContractAddressInput.
  /// \return The address.
  ffi.Pointer<TWString1> TWBarzGetCounterfactualAddress(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWBarzGetCounterfactualAddress(
      input,
    );
  }

  late final _TWBarzGetCounterfactualAddressPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWString1> Function(
              ffi.Pointer<TWData1>)>>('TWBarzGetCounterfactualAddress');
  late final _TWBarzGetCounterfactualAddress =
      _TWBarzGetCounterfactualAddressPtr.asFunction<
          ffi.Pointer<TWString1> Function(ffi.Pointer<TWData1>)>();

  /// Returns the final hash to be signed by Barz for signing messages & typed data
  ///
  /// \param msg_hash Original msgHash
  /// \param barzAddress The address of Barz wallet signing the message
  /// \param chainId The chainId of the network the verification will happen; Must be non-negative
  /// \return The final hash to be signed.
  ffi.Pointer<TWData1> TWBarzGetPrefixedMsgHash(
    ffi.Pointer<TWData1> msgHash,
    ffi.Pointer<TWString1> barzAddress,
    int chainId,
  ) {
    return _TWBarzGetPrefixedMsgHash(
      msgHash,
      barzAddress,
      chainId,
    );
  }

  late final _TWBarzGetPrefixedMsgHashPtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>, ffi.Int32)>>('TWBarzGetPrefixedMsgHash');
  late final _TWBarzGetPrefixedMsgHash =
      _TWBarzGetPrefixedMsgHashPtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>, ffi.Pointer<TWString1>, int)>();

  /// Returns the init code parameter of ERC-4337 User Operation
  ///
  /// \param factory The address of the factory contract
  /// \param public_key Public key for the verification facet
  /// \param verification_facet The address of the verification facet
  /// \param salt The salt of the init code; Must be non-negative
  /// \return The init code.
  ffi.Pointer<TWData1> TWBarzGetInitCode(
    ffi.Pointer<TWString1> factory1,
    ffi.Pointer<TWPublicKey> publicKey,
    ffi.Pointer<TWString1> verificationFacet,
    int salt,
  ) {
    return _TWBarzGetInitCode(
      factory1,
      publicKey,
      verificationFacet,
      salt,
    );
  }

  late final _TWBarzGetInitCodePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWString1>,
              ffi.Pointer<TWPublicKey>,
              ffi.Pointer<TWString1>,
              ffi.Int32)>>('TWBarzGetInitCode');
  late final _TWBarzGetInitCode = _TWBarzGetInitCodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWString1>,
          ffi.Pointer<TWPublicKey>, ffi.Pointer<TWString1>, int)>();

  /// Converts the original ASN-encoded signature from webauthn to the format accepted by Barz
  ///
  /// \param signature Original signature
  /// \param challenge The original challenge that was signed
  /// \param authenticator_data Returned from Webauthn API
  /// \param client_data_json Returned from Webauthn API
  /// \return Bytes of the formatted signature
  ffi.Pointer<TWData1> TWBarzGetFormattedSignature(
    ffi.Pointer<TWData1> signature,
    ffi.Pointer<TWData1> challenge,
    ffi.Pointer<TWData1> authenticatorData,
    ffi.Pointer<TWString1> clientDataJson,
  ) {
    return _TWBarzGetFormattedSignature(
      signature,
      challenge,
      authenticatorData,
      clientDataJson,
    );
  }

  late final _TWBarzGetFormattedSignaturePtr = _lookup<
      ffi.NativeFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>>('TWBarzGetFormattedSignature');
  late final _TWBarzGetFormattedSignature =
      _TWBarzGetFormattedSignaturePtr.asFunction<
          ffi.Pointer<TWData1> Function(
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWData1>,
              ffi.Pointer<TWString1>)>();

  /// Returns the encoded diamondCut function call for Barz contract upgrades
  ///
  /// \param input The serialized data of DiamondCutInput.
  /// \return The diamond cut code.
  ffi.Pointer<TWData1> TWBarzGetDiamondCutCode(
    ffi.Pointer<TWData1> input,
  ) {
    return _TWBarzGetDiamondCutCode(
      input,
    );
  }

  late final _TWBarzGetDiamondCutCodePtr = _lookup<
          ffi
          .NativeFunction<ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>>(
      'TWBarzGetDiamondCutCode');
  late final _TWBarzGetDiamondCutCode = _TWBarzGetDiamondCutCodePtr.asFunction<
      ffi.Pointer<TWData1> Function(ffi.Pointer<TWData1>)>();
}

final class __mbstate_t extends ffi.Union {
  @ffi.Array.multi([128])
  external ffi.Array<ffi.Char> __mbstate8;

  @ffi.LongLong()
  external int _mbstateL;
}

final class __darwin_pthread_handler_rec extends ffi.Struct {
  external ffi
      .Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Pointer<ffi.Void>)>>
      __routine;

  external ffi.Pointer<ffi.Void> __arg;

  external ffi.Pointer<__darwin_pthread_handler_rec> __next;
}

final class _opaque_pthread_attr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_cond_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([40])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_condattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutex_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([56])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_mutexattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_once_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([8])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlock_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([192])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_rwlockattr_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  @ffi.Array.multi([16])
  external ffi.Array<ffi.Char> __opaque;
}

final class _opaque_pthread_t extends ffi.Struct {
  @ffi.Long()
  external int __sig;

  external ffi.Pointer<__darwin_pthread_handler_rec> __cleanup_stack;

  @ffi.Array.multi([8176])
  external ffi.Array<ffi.Char> __opaque;
}

abstract class idtype_t {
  static const int P_ALL = 0;
  static const int P_PID = 1;
  static const int P_PGID = 2;
}

final class __darwin_arm_exception_state extends ffi.Struct {
  @__uint32_t()
  external int __exception;

  @__uint32_t()
  external int __fsr;

  @__uint32_t()
  external int __far;
}

typedef __uint32_t = ffi.UnsignedInt;
typedef Dart__uint32_t = int;

final class __darwin_arm_exception_state64 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint32_t()
  external int __esr;

  @__uint32_t()
  external int __exception;
}

typedef __uint64_t = ffi.UnsignedLongLong;
typedef Dart__uint64_t = int;

final class __darwin_arm_exception_state64_v2 extends ffi.Struct {
  @__uint64_t()
  external int __far;

  @__uint64_t()
  external int __esr;
}

final class __darwin_arm_thread_state extends ffi.Struct {
  @ffi.Array.multi([13])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __sp;

  @__uint32_t()
  external int __lr;

  @__uint32_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;
}

final class __darwin_arm_thread_state64 extends ffi.Struct {
  @ffi.Array.multi([29])
  external ffi.Array<__uint64_t> __x;

  @__uint64_t()
  external int __fp;

  @__uint64_t()
  external int __lr;

  @__uint64_t()
  external int __sp;

  @__uint64_t()
  external int __pc;

  @__uint32_t()
  external int __cpsr;

  @__uint32_t()
  external int __pad;
}

final class __darwin_arm_vfp_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<__uint32_t> __r;

  @__uint32_t()
  external int __fpscr;
}

final class __darwin_arm_neon_state64 extends ffi.Opaque {}

final class __darwin_arm_neon_state extends ffi.Opaque {}

final class __arm_pagein_state extends ffi.Struct {
  @ffi.Int()
  external int __pagein_error;
}

final class __darwin_arm_sme_state extends ffi.Struct {
  @__uint64_t()
  external int __svcr;

  @__uint64_t()
  external int __tpidr2_el0;

  @__uint16_t()
  external int __svl_b;
}

typedef __uint16_t = ffi.UnsignedShort;
typedef Dart__uint16_t = int;

final class __darwin_arm_sve_z_state extends ffi.Struct {
  @ffi.Array.multi([16, 256])
  external ffi.Array<ffi.Array<ffi.Char>> __z;
}

final class __darwin_arm_sve_p_state extends ffi.Struct {
  @ffi.Array.multi([16, 32])
  external ffi.Array<ffi.Array<ffi.Char>> __p;
}

final class __darwin_arm_sme_za_state extends ffi.Struct {
  @ffi.Array.multi([4096])
  external ffi.Array<ffi.Char> __za;
}

final class __darwin_arm_sme2_state extends ffi.Struct {
  @ffi.Array.multi([64])
  external ffi.Array<ffi.Char> __zt0;
}

final class __arm_legacy_debug_state extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;
}

final class __darwin_arm_debug_state32 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint32_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_debug_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __bcr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wvr;

  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __wcr;

  @__uint64_t()
  external int __mdscr_el1;
}

final class __darwin_arm_cpmu_state64 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<__uint64_t> __ctrs;
}

final class __darwin_mcontext32 extends ffi.Struct {
  external __darwin_arm_exception_state __es;

  external __darwin_arm_thread_state __ss;

  external __darwin_arm_vfp_state __fs;
}

final class __darwin_mcontext64 extends ffi.Opaque {}

final class __darwin_sigaltstack extends ffi.Struct {
  external ffi.Pointer<ffi.Void> ss_sp;

  @__darwin_size_t()
  external int ss_size;

  @ffi.Int()
  external int ss_flags;
}

typedef __darwin_size_t = ffi.UnsignedLong;
typedef Dart__darwin_size_t = int;

final class __darwin_ucontext extends ffi.Struct {
  @ffi.Int()
  external int uc_onstack;

  @__darwin_sigset_t()
  external int uc_sigmask;

  external __darwin_sigaltstack uc_stack;

  external ffi.Pointer<__darwin_ucontext> uc_link;

  @__darwin_size_t()
  external int uc_mcsize;

  external ffi.Pointer<__darwin_mcontext64> uc_mcontext;
}

typedef __darwin_sigset_t = __uint32_t;

final class sigval extends ffi.Union {
  @ffi.Int()
  external int sival_int;

  external ffi.Pointer<ffi.Void> sival_ptr;
}

final class sigevent extends ffi.Struct {
  @ffi.Int()
  external int sigev_notify;

  @ffi.Int()
  external int sigev_signo;

  external sigval sigev_value;

  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(sigval)>>
      sigev_notify_function;

  external ffi.Pointer<pthread_attr_t> sigev_notify_attributes;
}

typedef pthread_attr_t = __darwin_pthread_attr_t;
typedef __darwin_pthread_attr_t = _opaque_pthread_attr_t;

final class __siginfo extends ffi.Struct {
  @ffi.Int()
  external int si_signo;

  @ffi.Int()
  external int si_errno;

  @ffi.Int()
  external int si_code;

  @pid_t()
  external int si_pid;

  @uid_t()
  external int si_uid;

  @ffi.Int()
  external int si_status;

  external ffi.Pointer<ffi.Void> si_addr;

  external sigval si_value;

  @ffi.Long()
  external int si_band;

  @ffi.Array.multi([7])
  external ffi.Array<ffi.UnsignedLong> __pad;
}

typedef pid_t = __darwin_pid_t;
typedef __darwin_pid_t = __int32_t;
typedef __int32_t = ffi.Int;
typedef Dart__int32_t = int;
typedef uid_t = __darwin_uid_t;
typedef __darwin_uid_t = __uint32_t;

final class __sigaction_u extends ffi.Union {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      __sa_handler;

  external ffi.Pointer<
          ffi.NativeFunction<
              ffi.Void Function(
                  ffi.Int, ffi.Pointer<__siginfo>, ffi.Pointer<ffi.Void>)>>
      __sa_sigaction;
}

final class __sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  external ffi.Pointer<
      ffi.NativeFunction<
          ffi.Void Function(ffi.Pointer<ffi.Void>, ffi.Int, ffi.Int,
              ffi.Pointer<siginfo_t>, ffi.Pointer<ffi.Void>)>> sa_tramp;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

typedef siginfo_t = __siginfo;
typedef sigset_t = __darwin_sigset_t;

final class sigaction extends ffi.Struct {
  external __sigaction_u __sigaction_u1;

  @sigset_t()
  external int sa_mask;

  @ffi.Int()
  external int sa_flags;
}

final class sigvec extends ffi.Struct {
  external ffi.Pointer<ffi.NativeFunction<ffi.Void Function(ffi.Int)>>
      sv_handler;

  @ffi.Int()
  external int sv_mask;

  @ffi.Int()
  external int sv_flags;
}

final class sigstack extends ffi.Struct {
  external ffi.Pointer<ffi.Char> ss_sp;

  @ffi.Int()
  external int ss_onstack;
}

final class timeval extends ffi.Struct {
  @__darwin_time_t()
  external int tv_sec;

  @__darwin_suseconds_t()
  external int tv_usec;
}

typedef __darwin_time_t = ffi.Long;
typedef Dart__darwin_time_t = int;
typedef __darwin_suseconds_t = __int32_t;

final class rusage extends ffi.Struct {
  external timeval ru_utime;

  external timeval ru_stime;

  @ffi.Long()
  external int ru_maxrss;

  @ffi.Long()
  external int ru_ixrss;

  @ffi.Long()
  external int ru_idrss;

  @ffi.Long()
  external int ru_isrss;

  @ffi.Long()
  external int ru_minflt;

  @ffi.Long()
  external int ru_majflt;

  @ffi.Long()
  external int ru_nswap;

  @ffi.Long()
  external int ru_inblock;

  @ffi.Long()
  external int ru_oublock;

  @ffi.Long()
  external int ru_msgsnd;

  @ffi.Long()
  external int ru_msgrcv;

  @ffi.Long()
  external int ru_nsignals;

  @ffi.Long()
  external int ru_nvcsw;

  @ffi.Long()
  external int ru_nivcsw;
}

final class rusage_info_v0 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;
}

final class rusage_info_v1 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;
}

final class rusage_info_v2 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;
}

final class rusage_info_v3 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;
}

final class rusage_info_v4 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;
}

final class rusage_info_v5 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;
}

final class rusage_info_v6 extends ffi.Struct {
  @ffi.Array.multi([16])
  external ffi.Array<ffi.Uint8> ri_uuid;

  @ffi.Uint64()
  external int ri_user_time;

  @ffi.Uint64()
  external int ri_system_time;

  @ffi.Uint64()
  external int ri_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_interrupt_wkups;

  @ffi.Uint64()
  external int ri_pageins;

  @ffi.Uint64()
  external int ri_wired_size;

  @ffi.Uint64()
  external int ri_resident_size;

  @ffi.Uint64()
  external int ri_phys_footprint;

  @ffi.Uint64()
  external int ri_proc_start_abstime;

  @ffi.Uint64()
  external int ri_proc_exit_abstime;

  @ffi.Uint64()
  external int ri_child_user_time;

  @ffi.Uint64()
  external int ri_child_system_time;

  @ffi.Uint64()
  external int ri_child_pkg_idle_wkups;

  @ffi.Uint64()
  external int ri_child_interrupt_wkups;

  @ffi.Uint64()
  external int ri_child_pageins;

  @ffi.Uint64()
  external int ri_child_elapsed_abstime;

  @ffi.Uint64()
  external int ri_diskio_bytesread;

  @ffi.Uint64()
  external int ri_diskio_byteswritten;

  @ffi.Uint64()
  external int ri_cpu_time_qos_default;

  @ffi.Uint64()
  external int ri_cpu_time_qos_maintenance;

  @ffi.Uint64()
  external int ri_cpu_time_qos_background;

  @ffi.Uint64()
  external int ri_cpu_time_qos_utility;

  @ffi.Uint64()
  external int ri_cpu_time_qos_legacy;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_initiated;

  @ffi.Uint64()
  external int ri_cpu_time_qos_user_interactive;

  @ffi.Uint64()
  external int ri_billed_system_time;

  @ffi.Uint64()
  external int ri_serviced_system_time;

  @ffi.Uint64()
  external int ri_logical_writes;

  @ffi.Uint64()
  external int ri_lifetime_max_phys_footprint;

  @ffi.Uint64()
  external int ri_instructions;

  @ffi.Uint64()
  external int ri_cycles;

  @ffi.Uint64()
  external int ri_billed_energy;

  @ffi.Uint64()
  external int ri_serviced_energy;

  @ffi.Uint64()
  external int ri_interval_max_phys_footprint;

  @ffi.Uint64()
  external int ri_runnable_time;

  @ffi.Uint64()
  external int ri_flags;

  @ffi.Uint64()
  external int ri_user_ptime;

  @ffi.Uint64()
  external int ri_system_ptime;

  @ffi.Uint64()
  external int ri_pinstructions;

  @ffi.Uint64()
  external int ri_pcycles;

  @ffi.Uint64()
  external int ri_energy_nj;

  @ffi.Uint64()
  external int ri_penergy_nj;

  @ffi.Uint64()
  external int ri_secure_time_in_system;

  @ffi.Uint64()
  external int ri_secure_ptime_in_system;

  @ffi.Uint64()
  external int ri_neural_footprint;

  @ffi.Uint64()
  external int ri_lifetime_max_neural_footprint;

  @ffi.Uint64()
  external int ri_interval_max_neural_footprint;

  @ffi.Array.multi([9])
  external ffi.Array<ffi.Uint64> ri_reserved;
}

final class rlimit extends ffi.Struct {
  @rlim_t()
  external int rlim_cur;

  @rlim_t()
  external int rlim_max;
}

typedef rlim_t = __uint64_t;

final class proc_rlimit_control_wakeupmon extends ffi.Struct {
  @ffi.Uint32()
  external int wm_flags;

  @ffi.Int32()
  external int wm_rate;
}

typedef id_t = __darwin_id_t;
typedef __darwin_id_t = __uint32_t;

final class wait extends ffi.Opaque {}

final class div_t extends ffi.Struct {
  @ffi.Int()
  external int quot;

  @ffi.Int()
  external int rem;
}

final class ldiv_t extends ffi.Struct {
  @ffi.Long()
  external int quot;

  @ffi.Long()
  external int rem;
}

final class lldiv_t extends ffi.Struct {
  @ffi.LongLong()
  external int quot;

  @ffi.LongLong()
  external int rem;
}

typedef malloc_type_id_t = ffi.UnsignedLongLong;
typedef Dartmalloc_type_id_t = int;

final class _malloc_zone_t extends ffi.Opaque {}

typedef malloc_zone_t = _malloc_zone_t;
typedef dev_t = __darwin_dev_t;
typedef __darwin_dev_t = __int32_t;
typedef mode_t = __darwin_mode_t;
typedef __darwin_mode_t = __uint16_t;

/// HD wallet purpose
///
/// \see https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki
/// \see https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki
abstract class TWPurpose {
  static const int TWPurposeBIP44 = 44;
  static const int TWPurposeBIP49 = 49;
  static const int TWPurposeBIP84 = 84;
  static const int TWPurposeBIP86 = 86;
  static const int TWPurposeBIP1852 = 1852;
}

/// Filecoin address type.
abstract class TWFilecoinAddressType {
  static const int TWFilecoinAddressTypeDefault = 0;
  static const int TWFilecoinAddressTypeDelegated = 1;
}

/// Blockchain enum type
abstract class TWBlockchain {
  static const int TWBlockchainBitcoin = 0;
  static const int TWBlockchainEthereum = 1;
  static const int TWBlockchainVechain = 3;
  static const int TWBlockchainTron = 4;
  static const int TWBlockchainIcon = 5;
  static const int TWBlockchainBinance = 6;
  static const int TWBlockchainRipple = 7;
  static const int TWBlockchainTezos = 8;
  static const int TWBlockchainNimiq = 9;
  static const int TWBlockchainStellar = 10;
  static const int TWBlockchainAion = 11;
  static const int TWBlockchainCosmos = 12;
  static const int TWBlockchainTheta = 13;
  static const int TWBlockchainOntology = 14;
  static const int TWBlockchainZilliqa = 15;
  static const int TWBlockchainIoTeX = 16;
  static const int TWBlockchainEOS = 17;
  static const int TWBlockchainNano = 18;
  static const int TWBlockchainNULS = 19;
  static const int TWBlockchainWaves = 20;
  static const int TWBlockchainAeternity = 21;
  static const int TWBlockchainNebulas = 22;
  static const int TWBlockchainFIO = 23;
  static const int TWBlockchainSolana = 24;
  static const int TWBlockchainHarmony = 25;
  static const int TWBlockchainNEAR = 26;
  static const int TWBlockchainAlgorand = 27;
  static const int TWBlockchainIOST = 28;
  static const int TWBlockchainPolkadot = 29;
  static const int TWBlockchainCardano = 30;
  static const int TWBlockchainNEO = 31;
  static const int TWBlockchainFilecoin = 32;
  static const int TWBlockchainMultiversX = 33;
  static const int TWBlockchainOasisNetwork = 34;
  static const int TWBlockchainDecred = 35;
  static const int TWBlockchainZcash = 36;
  static const int TWBlockchainGroestlcoin = 37;
  static const int TWBlockchainThorchain = 38;
  static const int TWBlockchainRonin = 39;
  static const int TWBlockchainKusama = 40;
  static const int TWBlockchainZen = 41;
  static const int TWBlockchainBitcoinDiamond = 42;
  static const int TWBlockchainVerge = 43;
  static const int TWBlockchainNervos = 44;
  static const int TWBlockchainEverscale = 45;
  static const int TWBlockchainAptos = 46;
  static const int TWBlockchainNebl = 47;
  static const int TWBlockchainHedera = 48;
  static const int TWBlockchainTheOpenNetwork = 49;
  static const int TWBlockchainSui = 50;
  static const int TWBlockchainGreenfield = 51;
  static const int TWBlockchainInternetComputer = 52;
  static const int TWBlockchainNativeEvmos = 53;
  static const int TWBlockchainNativeInjective = 54;
  static const int TWBlockchainBitcoinCash = 55;
  static const int TWBlockchainPactus = 56;
  static const int TWBlockchainKomodo = 57;
  static const int TWBlockchainPolymesh = 58;
}

/// Elliptic cruves
abstract class TWCurve {
  static const int TWCurveSECP256k1 = 0;
  static const int TWCurveED25519 = 1;
  static const int TWCurveED25519Blake2bNano = 2;
  static const int TWCurveCurve25519 = 3;
  static const int TWCurveNIST256p1 = 4;
  static const int TWCurveED25519ExtendedCardano = 5;
  static const int TWCurveStarkex = 6;
  static const int TWCurveNone = 7;
}

/// Non-default coin address derivation names (default, unnamed derivations are not included).
/// Note the enum variant must be sync with `TWDerivation` enum in Rust:
/// https://github.com/trustwallet/wallet-core/blob/master/rust/tw_coin_registry/src/tw_derivation.rs
abstract class TWDerivation {
  static const int TWDerivationDefault = 0;
  static const int TWDerivationCustom = 1;
  static const int TWDerivationBitcoinSegwit = 2;
  static const int TWDerivationBitcoinLegacy = 3;
  static const int TWDerivationBitcoinTestnet = 4;
  static const int TWDerivationLitecoinLegacy = 5;
  static const int TWDerivationSolanaSolana = 6;
  static const int TWDerivationStratisSegwit = 7;
  static const int TWDerivationBitcoinTaproot = 8;
  static const int TWDerivationPactusMainnet = 9;
  static const int TWDerivationPactusTestnet = 10;
}

/// Registered HD version bytes
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0132.md
abstract class TWHDVersion {
  static const int TWHDVersionNone = 0;
  static const int TWHDVersionXPUB = 76067358;
  static const int TWHDVersionXPRV = 76066276;
  static const int TWHDVersionYPUB = 77429938;
  static const int TWHDVersionYPRV = 77428856;
  static const int TWHDVersionZPUB = 78792518;
  static const int TWHDVersionZPRV = 78791436;
  static const int TWHDVersionVPUB = 73342198;
  static const int TWHDVersionVPRV = 73341116;
  static const int TWHDVersionTPUB = 70617039;
  static const int TWHDVersionTPRV = 70615956;
  static const int TWHDVersionLTUB = 27108450;
  static const int TWHDVersionLTPV = 27106558;
  static const int TWHDVersionMTUB = 28471030;
  static const int TWHDVersionMTPV = 28469138;
  static const int TWHDVersionTTUB = 70711009;
  static const int TWHDVersionTTPV = 70709117;
  static const int TWHDVersionDPUB = 50178342;
  static const int TWHDVersionDPRV = 50177256;
  static const int TWHDVersionDGUB = 49990397;
  static const int TWHDVersionDGPV = 49988504;
}

/// Registered human-readable parts for BIP-0173
///
/// - SeeAlso: https://github.com/satoshilabs/slips/blob/master/slip-0173.md
abstract class TWHRP {
  static const int TWHRPUnknown = 0;
  static const int TWHRPBitcoin = 1;
  static const int TWHRPLitecoin = 2;
  static const int TWHRPViacoin = 3;
  static const int TWHRPGroestlcoin = 4;
  static const int TWHRPDigiByte = 5;
  static const int TWHRPMonacoin = 6;
  static const int TWHRPSyscoin = 7;
  static const int TWHRPVerge = 8;
  static const int TWHRPCosmos = 9;
  static const int TWHRPZcash = 10;
  static const int TWHRPBitcoinCash = 11;
  static const int TWHRPBitcoinGold = 12;
  static const int TWHRPIoTeX = 13;
  static const int TWHRPNervos = 14;
  static const int TWHRPZilliqa = 15;
  static const int TWHRPTerra = 16;
  static const int TWHRPCryptoOrg = 17;
  static const int TWHRPKava = 18;
  static const int TWHRPOasis = 19;
  static const int TWHRPBluzelle = 20;
  static const int TWHRPBandChain = 21;
  static const int TWHRPMultiversX = 22;
  static const int TWHRPSecret = 23;
  static const int TWHRPAgoric = 24;
  static const int TWHRPBinance = 25;
  static const int TWHRPECash = 26;
  static const int TWHRPTHORChain = 27;
  static const int TWHRPBitcoinDiamond = 28;
  static const int TWHRPHarmony = 29;
  static const int TWHRPCardano = 30;
  static const int TWHRPQtum = 31;
  static const int TWHRPPactus = 32;
  static const int TWHRPStratis = 33;
  static const int TWHRPNativeInjective = 34;
  static const int TWHRPOsmosis = 35;
  static const int TWHRPTerraV2 = 36;
  static const int TWHRPCoreum = 37;
  static const int TWHRPNativeZetaChain = 38;
  static const int TWHRPNativeCanto = 39;
  static const int TWHRPSommelier = 40;
  static const int TWHRPFetchAI = 41;
  static const int TWHRPMars = 42;
  static const int TWHRPUmee = 43;
  static const int TWHRPQuasar = 44;
  static const int TWHRPPersistence = 45;
  static const int TWHRPAkash = 46;
  static const int TWHRPNoble = 47;
  static const int TWHRPSei = 48;
  static const int TWHRPStargaze = 49;
  static const int TWHRPNativeEvmos = 50;
  static const int TWHRPTia = 51;
  static const int TWHRPDydx = 52;
  static const int TWHRPJuno = 53;
  static const int TWHRPTBinance = 54;
  static const int TWHRPStride = 55;
  static const int TWHRPAxelar = 56;
  static const int TWHRPCrescent = 57;
  static const int TWHRPKujira = 58;
  static const int TWHRPComdex = 59;
  static const int TWHRPNeutron = 60;
}

/// Defines a resizable string.
///
/// The implementantion of these methods should be language-specific to minimize translation
/// overhead. For instance it should be a `jstring` for Java and an `NSString` for Swift. Create
/// allocates memory, the delete call should be called at the end to release memory.
typedef TWString = ffi.Void;
typedef DartTWString = void;
typedef TWData = ffi.Void;
typedef DartTWData = void;

/// Public key types
abstract class TWPublicKeyType {
  static const int TWPublicKeyTypeSECP256k1 = 0;
  static const int TWPublicKeyTypeSECP256k1Extended = 1;
  static const int TWPublicKeyTypeNIST256p1 = 2;
  static const int TWPublicKeyTypeNIST256p1Extended = 3;
  static const int TWPublicKeyTypeED25519 = 4;
  static const int TWPublicKeyTypeED25519Blake2b = 5;
  static const int TWPublicKeyTypeCURVE25519 = 6;
  static const int TWPublicKeyTypeED25519Cardano = 7;
  static const int TWPublicKeyTypeStarkex = 8;
}

/// Represents a private key.
final class TWPrivateKey extends ffi.Opaque {}

/// Represents a public key.
final class TWPublicKey extends ffi.Opaque {}

/// Coin type for Level 2 of BIP44.
///
/// \see https://github.com/satoshilabs/slips/blob/master/slip-0044.md
abstract class TWCoinType {
  static const int TWCoinTypeAeternity = 457;
  static const int TWCoinTypeAion = 425;
  static const int TWCoinTypeBinance = 714;
  static const int TWCoinTypeBitcoin = 0;
  static const int TWCoinTypeBitcoinCash = 145;
  static const int TWCoinTypeBitcoinGold = 156;
  static const int TWCoinTypeCallisto = 820;
  static const int TWCoinTypeCardano = 1815;
  static const int TWCoinTypeCosmos = 118;
  static const int TWCoinTypePivx = 119;
  static const int TWCoinTypeDash = 5;
  static const int TWCoinTypeDecred = 42;
  static const int TWCoinTypeDigiByte = 20;
  static const int TWCoinTypeDogecoin = 3;
  static const int TWCoinTypeEOS = 194;
  static const int TWCoinTypeWAX = 14001;
  static const int TWCoinTypeEthereum = 60;
  static const int TWCoinTypeEthereumClassic = 61;
  static const int TWCoinTypeFIO = 235;
  static const int TWCoinTypeGoChain = 6060;
  static const int TWCoinTypeGroestlcoin = 17;
  static const int TWCoinTypeICON = 74;
  static const int TWCoinTypeIoTeX = 304;
  static const int TWCoinTypeKava = 459;
  static const int TWCoinTypeKin = 2017;
  static const int TWCoinTypeLitecoin = 2;
  static const int TWCoinTypeMonacoin = 22;
  static const int TWCoinTypeNebulas = 2718;
  static const int TWCoinTypeNULS = 8964;
  static const int TWCoinTypeNano = 165;
  static const int TWCoinTypeNEAR = 397;
  static const int TWCoinTypeNimiq = 242;
  static const int TWCoinTypeOntology = 1024;
  static const int TWCoinTypePOANetwork = 178;
  static const int TWCoinTypeQtum = 2301;
  static const int TWCoinTypeXRP = 144;
  static const int TWCoinTypeSolana = 501;
  static const int TWCoinTypeStellar = 148;
  static const int TWCoinTypeTezos = 1729;
  static const int TWCoinTypeTheta = 500;
  static const int TWCoinTypeThunderCore = 1001;
  static const int TWCoinTypeNEO = 888;
  static const int TWCoinTypeViction = 889;
  static const int TWCoinTypeTron = 195;
  static const int TWCoinTypeVeChain = 818;
  static const int TWCoinTypeViacoin = 14;
  static const int TWCoinTypeWanchain = 5718350;
  static const int TWCoinTypeZcash = 133;
  static const int TWCoinTypeFiro = 136;
  static const int TWCoinTypeZilliqa = 313;
  static const int TWCoinTypeZelcash = 19167;
  static const int TWCoinTypeRavencoin = 175;
  static const int TWCoinTypeWaves = 5741564;
  static const int TWCoinTypeTerra = 330;
  static const int TWCoinTypeTerraV2 = 10000330;
  static const int TWCoinTypeHarmony = 1023;
  static const int TWCoinTypeAlgorand = 283;
  static const int TWCoinTypeKusama = 434;
  static const int TWCoinTypePolkadot = 354;
  static const int TWCoinTypeFilecoin = 461;
  static const int TWCoinTypeMultiversX = 508;
  static const int TWCoinTypeBandChain = 494;
  static const int TWCoinTypeSmartChainLegacy = 10000714;
  static const int TWCoinTypeSmartChain = 20000714;
  static const int TWCoinTypeTBinance = 30000714;
  static const int TWCoinTypeOasis = 474;
  static const int TWCoinTypePolygon = 966;
  static const int TWCoinTypeTHORChain = 931;
  static const int TWCoinTypeBluzelle = 483;
  static const int TWCoinTypeOptimism = 10000070;
  static const int TWCoinTypeZksync = 10000324;
  static const int TWCoinTypeArbitrum = 10042221;
  static const int TWCoinTypeECOChain = 10000553;
  static const int TWCoinTypeAvalancheCChain = 10009000;
  static const int TWCoinTypeXDai = 10000100;
  static const int TWCoinTypeFantom = 10000250;
  static const int TWCoinTypeCryptoOrg = 394;
  static const int TWCoinTypeCelo = 52752;
  static const int TWCoinTypeRonin = 10002020;
  static const int TWCoinTypeOsmosis = 10000118;
  static const int TWCoinTypeECash = 899;
  static const int TWCoinTypeIOST = 291;
  static const int TWCoinTypeCronosChain = 10000025;
  static const int TWCoinTypeSmartBitcoinCash = 10000145;
  static const int TWCoinTypeKuCoinCommunityChain = 10000321;
  static const int TWCoinTypeBitcoinDiamond = 999;
  static const int TWCoinTypeBoba = 10000288;
  static const int TWCoinTypeSyscoin = 57;
  static const int TWCoinTypeVerge = 77;
  static const int TWCoinTypeZen = 121;
  static const int TWCoinTypeMetis = 10001088;
  static const int TWCoinTypeAurora = 1323161554;
  static const int TWCoinTypeEvmos = 10009001;
  static const int TWCoinTypeNativeEvmos = 20009001;
  static const int TWCoinTypeMoonriver = 10001285;
  static const int TWCoinTypeMoonbeam = 10001284;
  static const int TWCoinTypeKavaEvm = 10002222;
  static const int TWCoinTypeKaia = 10008217;
  static const int TWCoinTypeMeter = 18000;
  static const int TWCoinTypeOKXChain = 996;
  static const int TWCoinTypeStratis = 105105;
  static const int TWCoinTypeKomodo = 141;
  static const int TWCoinTypeNervos = 309;
  static const int TWCoinTypeEverscale = 396;
  static const int TWCoinTypeAptos = 637;
  static const int TWCoinTypeNebl = 146;
  static const int TWCoinTypeHedera = 3030;
  static const int TWCoinTypeSecret = 529;
  static const int TWCoinTypeNativeInjective = 10000060;
  static const int TWCoinTypeAgoric = 564;
  static const int TWCoinTypeTON = 607;
  static const int TWCoinTypeSui = 784;
  static const int TWCoinTypeStargaze = 20000118;
  static const int TWCoinTypePolygonzkEVM = 10001101;
  static const int TWCoinTypeJuno = 30000118;
  static const int TWCoinTypeStride = 40000118;
  static const int TWCoinTypeAxelar = 50000118;
  static const int TWCoinTypeCrescent = 60000118;
  static const int TWCoinTypeKujira = 70000118;
  static const int TWCoinTypeIoTeXEVM = 10004689;
  static const int TWCoinTypeNativeCanto = 10007700;
  static const int TWCoinTypeComdex = 80000118;
  static const int TWCoinTypeNeutron = 90000118;
  static const int TWCoinTypeSommelier = 11000118;
  static const int TWCoinTypeFetchAI = 12000118;
  static const int TWCoinTypeMars = 13000118;
  static const int TWCoinTypeUmee = 14000118;
  static const int TWCoinTypeCoreum = 10000990;
  static const int TWCoinTypeQuasar = 15000118;
  static const int TWCoinTypePersistence = 16000118;
  static const int TWCoinTypeAkash = 17000118;
  static const int TWCoinTypeNoble = 18000118;
  static const int TWCoinTypeScroll = 534352;
  static const int TWCoinTypeRootstock = 137;
  static const int TWCoinTypeThetaFuel = 361;
  static const int TWCoinTypeConfluxeSpace = 1030;
  static const int TWCoinTypeAcala = 787;
  static const int TWCoinTypeAcalaEVM = 10000787;
  static const int TWCoinTypeOpBNB = 204;
  static const int TWCoinTypeNeon = 245022934;
  static const int TWCoinTypeBase = 8453;
  static const int TWCoinTypeSei = 19000118;
  static const int TWCoinTypeArbitrumNova = 10042170;
  static const int TWCoinTypeLinea = 59144;
  static const int TWCoinTypeGreenfield = 5600;
  static const int TWCoinTypeMantle = 5000;
  static const int TWCoinTypeZenEON = 7332;
  static const int TWCoinTypeInternetComputer = 223;
  static const int TWCoinTypeTia = 21000118;
  static const int TWCoinTypeMantaPacific = 169;
  static const int TWCoinTypeNativeZetaChain = 10007000;
  static const int TWCoinTypeZetaEVM = 20007000;
  static const int TWCoinTypeDydx = 22000118;
  static const int TWCoinTypeMerlin = 4200;
  static const int TWCoinTypeLightlink = 1890;
  static const int TWCoinTypeBlast = 81457;
  static const int TWCoinTypeBounceBit = 6001;
  static const int TWCoinTypeZkLinkNova = 810180;
  static const int TWCoinTypePactus = 21888;
  static const int TWCoinTypeSonic = 10000146;
  static const int TWCoinTypePolymesh = 595;
  static const int TWCoinTypePlasma = 9745;
}

/// CoinTypeConfiguration functions
final class TWCoinTypeConfiguration extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

/// Represents a BIP44 DerivationPath in C++.
final class TWDerivationPath extends ffi.Opaque {}

final class TWDerivationPathIndex extends ffi.Opaque {}

/// Hierarchical Deterministic (HD) Wallet
final class TWHDWallet extends ffi.Opaque {}

final class TWTransactionUtil extends ffi.Opaque {}

final class TWEthereumRlp extends ffi.Opaque {}

/// A vector of TWData byte arrays
final class TWDataVector extends ffi.Opaque {}

/// Non-core transaction utility methods, like building a transaction using an external signature.
final class TWTransactionCompiler extends ffi.Opaque {}

final class TWBiz extends ffi.Opaque {}

/// Defines a resizable block of data.
///
/// The implementantion of these methods should be language-specific to minimize translation overhead. For instance it
/// should be a `jbyteArray` for Java and an `NSData` for Swift.
typedef TWData1 = ffi.Void;
typedef DartTWData1 = void;

/// Defines a resizable string.
///
/// The implementantion of these methods should be language-specific to minimize translation
/// overhead. For instance it should be a `jstring` for Java and an `NSString` for Swift. Create
/// allocates memory, the delete call should be called at the end to release memory.
typedef TWString1 = ffi.Void;
typedef DartTWString1 = void;

final class TWStarkWare extends ffi.Opaque {}

/// Bitcoin SIGHASH type.
abstract class TWBitcoinSigHashType {
  static const int TWBitcoinSigHashTypeAll = 1;
  static const int TWBitcoinSigHashTypeNone = 2;
  static const int TWBitcoinSigHashTypeSingle = 3;
  static const int TWBitcoinSigHashTypeFork = 64;
  static const int TWBitcoinSigHashTypeForkBTG = 20288;
  static const int TWBitcoinSigHashTypeAnyoneCanPay = 128;
}

/// Represents Ethereum ABI value
final class TWEthereumAbiValue extends ffi.Opaque {}

/// Represents a signer to sign transactions for any blockchain.
final class TWAnySigner extends ffi.Opaque {}

/// Represents a Nervos address.
final class TWNervosAddress extends ffi.Opaque {}

/// Preset encryption kind
abstract class TWStoredKeyEncryption {
  static const int TWStoredKeyEncryptionAes128Ctr = 0;
  static const int TWStoredKeyEncryptionAes128Cbc = 1;
  static const int TWStoredKeyEncryptionAes192Ctr = 2;
  static const int TWStoredKeyEncryptionAes256Ctr = 3;
}

/// Base64 encode / decode functions
final class TWBase64 extends ffi.Opaque {}

/// Represents a BIP 0173 address.
final class TWSegwitAddress extends ffi.Opaque {}

final class TWTONWallet extends ffi.Opaque {}

/// Ethereum message signing and verification.
///
/// Ethereum and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWEthereumMessageSigner extends ffi.Opaque {}

/// Stellar memo type.
abstract class TWStellarMemoType {
  static const int TWStellarMemoTypeNone = 0;
  static const int TWStellarMemoTypeText = 1;
  static const int TWStellarMemoTypeId = 2;
  static const int TWStellarMemoTypeHash = 3;
  static const int TWStellarMemoTypeReturn = 4;
}

final class TWTransactionDecoder extends ffi.Opaque {}

/// Represents a legacy Bitcoin address in C++.
final class TWBitcoinAddress extends ffi.Opaque {}

/// Firo address type.
abstract class TWFiroAddressType {
  static const int TWFiroAddressTypeDefault = 0;
  static const int TWFiroAddressTypeExchange = 1;
}

/// Represents an address in C++ for almost any blockchain.
final class TWAnyAddress extends ffi.Opaque {}

/// Represents an ASN.1 DER parser.
final class TWAsnParser extends ffi.Opaque {}

/// THORChain swap functions
final class TWTHORChainSwap extends ffi.Opaque {}

/// Base58 encode / decode functions
final class TWBase58 extends ffi.Opaque {}

final class TWTONMessageSigner extends ffi.Opaque {}

/// Cardano helper functions
final class TWCardano extends ffi.Opaque {}

final class TWWebAuthnSolidity extends ffi.Opaque {}

/// THORChain swap functions
final class TWLiquidStaking extends ffi.Opaque {}

final class TWTONAddressConverter extends ffi.Opaque {}

final class TWWalletConnectRequest extends ffi.Opaque {}

/// Tron message signing and verification.
///
/// Tron and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWTronMessageSigner extends ffi.Opaque {}

final class TWWebAuthn extends ffi.Opaque {}

/// Password-Based Key Derivation Function 2
final class TWPBKDF2 extends ffi.Opaque {}

/// Filecoin-Ethereum address converter.
final class TWFilecoinAddressConverter extends ffi.Opaque {}

final class TWCryptoBoxPublicKey extends ffi.Opaque {}

final class TWCryptoBoxSecretKey extends ffi.Opaque {}

/// Base32 encode / decode functions
final class TWBase32 extends ffi.Opaque {}

/// Wrapper class for Ethereum ABI encoding & decoding.
final class TWEthereumAbiFunction extends ffi.Opaque {}

final class TWEthereumAbi extends ffi.Opaque {}

/// Tezos message signing, verification and utilities.
final class TWTezosMessageSigner extends ffi.Opaque {}

/// Stellar network passphrase string.
abstract class TWStellarPassphrase {
  static const int TWStellarPassphraseStellar = 0;
  static const int TWStellarPassphraseKin = 1;
}

/// Hash functions
final class TWHash extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

/// Preset encryption parameter with different security strength, for key store
abstract class TWStoredKeyEncryptionLevel {
  /// Default, which is one of the below values, determined by the implementation.
  static const int TWStoredKeyEncryptionLevelDefault = 0;

  /// Minimal sufficient level of encryption strength (scrypt 4096)
  static const int TWStoredKeyEncryptionLevelMinimal = 1;

  /// Weak encryption strength (scrypt 16k)
  static const int TWStoredKeyEncryptionLevelWeak = 2;

  /// Standard level of encryption strength (scrypt 262k)
  static const int TWStoredKeyEncryptionLevelStandard = 3;
}

/// Represents a key stored as an encrypted file.
final class TWStoredKey extends ffi.Opaque {}

final class TWAccount extends ffi.Opaque {}

/// Private key types, the vast majority of chains use the default, 32-byte key.
abstract class TWPrivateKeyType {
  static const int TWPrivateKeyTypeDefault = 0;
  static const int TWPrivateKeyTypeCardano = 1;
}

/// Bitcoin script manipulating functions
final class TWBitcoinScript extends ffi.Opaque {}

/// Represents a FIO Account name
final class TWFIOAccount extends ffi.Opaque {}

/// Represents a legacy Groestlcoin address.
final class TWGroestlcoinAddress extends ffi.Opaque {}

/// `crypto_box` encryption algorithms.
final class TWCryptoBox extends ffi.Opaque {}

/// Mnemonic validate / lookup functions
final class TWMnemonic extends ffi.Opaque {}

/// Stellar address version byte.
abstract class TWStellarVersionByte {
  static const int TWStellarVersionByteAccountID = 48;
  static const int TWStellarVersionByteSeed = 192;
  static const int TWStellarVersionBytePreAuthTX = 200;
  static const int TWStellarVersionByteSHA256Hash = 280;
}

final class TWEthereum extends ffi.Opaque {}

/// Padding mode used in AES encryption.
abstract class TWAESPaddingMode {
  static const int TWAESPaddingModeZero = 0;
  static const int TWAESPaddingModePKCS7 = 1;
}

/// AES encryption/decryption methods.
final class TWAES extends ffi.Struct {
  @ffi.Uint8()
  external int unused;
}

final class TWEip7702 extends ffi.Opaque {}

final class TWSolanaTransaction extends ffi.Opaque {}

/// Represents a NEAR Account name
final class TWNEARAccount extends ffi.Opaque {}

/// Bitcoin message signing and verification.
///
/// Bitcoin Core and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
/// This feature currently works on old legacy addresses only.
final class TWBitcoinMessageSigner extends ffi.Opaque {}

final class TWMessageSigner extends ffi.Opaque {}

/// StarkEx message signing and verification.
///
/// StarkEx and some other wallets support a message signing & verification format, to create a proof (a signature)
/// that someone has access to the private keys of a specific address.
final class TWStarkExMessageSigner extends ffi.Opaque {}

/// Chain identifiers for Ethereum-based blockchains, for convenience. Recommended to use the dynamic CoinType.ChainId() instead.
/// See also TWChainId.
abstract class TWEthereumChainID {
  static const int TWEthereumChainIDEthereum = 1;
  static const int TWEthereumChainIDClassic = 61;
  static const int TWEthereumChainIDRootstock = 30;
  static const int TWEthereumChainIDManta = 169;
  static const int TWEthereumChainIDPoa = 99;
  static const int TWEthereumChainIDOpbnb = 204;
  static const int TWEthereumChainIDTfuelevm = 361;
  static const int TWEthereumChainIDVechain = 74;
  static const int TWEthereumChainIDCallisto = 820;
  static const int TWEthereumChainIDViction = 88;
  static const int TWEthereumChainIDPolygon = 137;
  static const int TWEthereumChainIDOkc = 66;
  static const int TWEthereumChainIDThundertoken = 108;
  static const int TWEthereumChainIDCfxevm = 1030;
  static const int TWEthereumChainIDLightlink = 1890;
  static const int TWEthereumChainIDMerlin = 4200;
  static const int TWEthereumChainIDMantle = 5000;
  static const int TWEthereumChainIDBouncebit = 6001;
  static const int TWEthereumChainIDGochain = 60;
  static const int TWEthereumChainIDZeneon = 7332;
  static const int TWEthereumChainIDBase = 8453;
  static const int TWEthereumChainIDPlasma = 9745;
  static const int TWEthereumChainIDMeter = 82;
  static const int TWEthereumChainIDCelo = 42220;
  static const int TWEthereumChainIDLinea = 59144;
  static const int TWEthereumChainIDBlast = 81457;
  static const int TWEthereumChainIDScroll = 534352;
  static const int TWEthereumChainIDZklinknova = 810180;
  static const int TWEthereumChainIDWanchain = 888;
  static const int TWEthereumChainIDCronos = 25;
  static const int TWEthereumChainIDOptimism = 10;
  static const int TWEthereumChainIDXdai = 100;
  static const int TWEthereumChainIDSmartbch = 10000;
  static const int TWEthereumChainIDSonic = 146;
  static const int TWEthereumChainIDFantom = 250;
  static const int TWEthereumChainIDBoba = 288;
  static const int TWEthereumChainIDKcc = 321;
  static const int TWEthereumChainIDZksync = 324;
  static const int TWEthereumChainIDHeco = 128;
  static const int TWEthereumChainIDAcalaevm = 787;
  static const int TWEthereumChainIDMetis = 1088;
  static const int TWEthereumChainIDPolygonzkevm = 1101;
  static const int TWEthereumChainIDMoonbeam = 1284;
  static const int TWEthereumChainIDMoonriver = 1285;
  static const int TWEthereumChainIDRonin = 2020;
  static const int TWEthereumChainIDKavaevm = 2222;
  static const int TWEthereumChainIDIotexevm = 4689;
  static const int TWEthereumChainIDKaia = 8217;
  static const int TWEthereumChainIDAvalanchec = 43114;
  static const int TWEthereumChainIDEvmos = 9001;
  static const int TWEthereumChainIDArbitrumnova = 42170;
  static const int TWEthereumChainIDArbitrum = 42161;
  static const int TWEthereumChainIDSmartchain = 56;
  static const int TWEthereumChainIDZetaevm = 7000;
  static const int TWEthereumChainIDNeon = 245022934;
  static const int TWEthereumChainIDAurora = 1313161554;
}

/// Solana address helper functions
final class TWSolanaAddress extends ffi.Opaque {}

/// Bech32 encode / decode functions
final class TWBech32 extends ffi.Opaque {}

final class TWBarz extends ffi.Opaque {}

const int __bool_true_false_are_defined = 1;

const int true1 = 1;

const int false1 = 0;

const int __has_safe_buffers = 1;

const int __DARWIN_ONLY_64_BIT_INO_T = 1;

const int __DARWIN_ONLY_UNIX_CONFORMANCE = 1;

const int __DARWIN_ONLY_VERS_1050 = 1;

const int __DARWIN_UNIX03 = 1;

const int __DARWIN_64_BIT_INO_T = 1;

const int __DARWIN_VERS_1050 = 1;

const int __DARWIN_NON_CANCELABLE = 0;

const String __DARWIN_SUF_EXTSN = '\$DARWIN_EXTSN';

const int __DARWIN_C_ANSI = 4096;

const int __DARWIN_C_FULL = 900000;

const int __DARWIN_C_LEVEL = 900000;

const int __STDC_WANT_LIB_EXT1__ = 1;

const int __DARWIN_NO_LONG_LONG = 0;

const int _DARWIN_FEATURE_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_64_BIT_INODE = 1;

const int _DARWIN_FEATURE_ONLY_VERS_1050 = 1;

const int _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE = 1;

const int _DARWIN_FEATURE_UNIX_CONFORMANCE = 3;

const int __has_ptrcheck = 0;

const int __has_bounds_safety_attributes = 0;

const int __DARWIN_NULL = 0;

const int __PTHREAD_SIZE__ = 8176;

const int __PTHREAD_ATTR_SIZE__ = 56;

const int __PTHREAD_MUTEXATTR_SIZE__ = 8;

const int __PTHREAD_MUTEX_SIZE__ = 56;

const int __PTHREAD_CONDATTR_SIZE__ = 8;

const int __PTHREAD_COND_SIZE__ = 40;

const int __PTHREAD_ONCE_SIZE__ = 8;

const int __PTHREAD_RWLOCK_SIZE__ = 192;

const int __PTHREAD_RWLOCKATTR_SIZE__ = 16;

const int __DARWIN_WCHAR_MAX = 2147483647;

const int __DARWIN_WCHAR_MIN = -2147483648;

const int __DARWIN_WEOF = -1;

const int _FORTIFY_SOURCE = 2;

const int NULL = 0;

const int USER_ADDR_NULL = 0;

const int __WORDSIZE = 64;

const int INT8_MAX = 127;

const int INT16_MAX = 32767;

const int INT32_MAX = 2147483647;

const int INT64_MAX = 9223372036854775807;

const int INT8_MIN = -128;

const int INT16_MIN = -32768;

const int INT32_MIN = -2147483648;

const int INT64_MIN = -9223372036854775808;

const int UINT8_MAX = 255;

const int UINT16_MAX = 65535;

const int UINT32_MAX = 4294967295;

const int UINT64_MAX = -1;

const int INT_LEAST8_MIN = -128;

const int INT_LEAST16_MIN = -32768;

const int INT_LEAST32_MIN = -2147483648;

const int INT_LEAST64_MIN = -9223372036854775808;

const int INT_LEAST8_MAX = 127;

const int INT_LEAST16_MAX = 32767;

const int INT_LEAST32_MAX = 2147483647;

const int INT_LEAST64_MAX = 9223372036854775807;

const int UINT_LEAST8_MAX = 255;

const int UINT_LEAST16_MAX = 65535;

const int UINT_LEAST32_MAX = 4294967295;

const int UINT_LEAST64_MAX = -1;

const int INT_FAST8_MIN = -128;

const int INT_FAST16_MIN = -32768;

const int INT_FAST32_MIN = -2147483648;

const int INT_FAST64_MIN = -9223372036854775808;

const int INT_FAST8_MAX = 127;

const int INT_FAST16_MAX = 32767;

const int INT_FAST32_MAX = 2147483647;

const int INT_FAST64_MAX = 9223372036854775807;

const int UINT_FAST8_MAX = 255;

const int UINT_FAST16_MAX = 65535;

const int UINT_FAST32_MAX = 4294967295;

const int UINT_FAST64_MAX = -1;

const int INTPTR_MAX = 9223372036854775807;

const int INTPTR_MIN = -9223372036854775808;

const int UINTPTR_MAX = -1;

const int INTMAX_MAX = 9223372036854775807;

const int UINTMAX_MAX = -1;

const int INTMAX_MIN = -9223372036854775808;

const int PTRDIFF_MIN = -9223372036854775808;

const int PTRDIFF_MAX = 9223372036854775807;

const int SIZE_MAX = -1;

const int RSIZE_MAX = 9223372036854775807;

const int WCHAR_MAX = 2147483647;

const int WCHAR_MIN = -2147483648;

const int WINT_MIN = -2147483648;

const int WINT_MAX = 2147483647;

const int SIG_ATOMIC_MIN = -2147483648;

const int SIG_ATOMIC_MAX = 2147483647;

const int __API_TO_BE_DEPRECATED = 100000;

const int __API_TO_BE_DEPRECATED_MACOS = 100000;

const int __API_TO_BE_DEPRECATED_MACOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_IOS = 100000;

const int __API_TO_BE_DEPRECATED_IOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYST = 100000;

const int __API_TO_BE_DEPRECATED_MACCATALYSTAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOS = 100000;

const int __API_TO_BE_DEPRECATED_WATCHOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_TVOS = 100000;

const int __API_TO_BE_DEPRECATED_TVOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_DRIVERKIT = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOS = 100000;

const int __API_TO_BE_DEPRECATED_VISIONOSAPPLICATIONEXTENSION = 100000;

const int __API_TO_BE_DEPRECATED_KERNELKIT = 100000;

const int __MAC_10_0 = 1000;

const int __MAC_10_1 = 1010;

const int __MAC_10_2 = 1020;

const int __MAC_10_3 = 1030;

const int __MAC_10_4 = 1040;

const int __MAC_10_5 = 1050;

const int __MAC_10_6 = 1060;

const int __MAC_10_7 = 1070;

const int __MAC_10_8 = 1080;

const int __MAC_10_9 = 1090;

const int __MAC_10_10 = 101000;

const int __MAC_10_10_2 = 101002;

const int __MAC_10_10_3 = 101003;

const int __MAC_10_11 = 101100;

const int __MAC_10_11_2 = 101102;

const int __MAC_10_11_3 = 101103;

const int __MAC_10_11_4 = 101104;

const int __MAC_10_12 = 101200;

const int __MAC_10_12_1 = 101201;

const int __MAC_10_12_2 = 101202;

const int __MAC_10_12_4 = 101204;

const int __MAC_10_13 = 101300;

const int __MAC_10_13_1 = 101301;

const int __MAC_10_13_2 = 101302;

const int __MAC_10_13_4 = 101304;

const int __MAC_10_14 = 101400;

const int __MAC_10_14_1 = 101401;

const int __MAC_10_14_4 = 101404;

const int __MAC_10_14_5 = 101405;

const int __MAC_10_14_6 = 101406;

const int __MAC_10_15 = 101500;

const int __MAC_10_15_1 = 101501;

const int __MAC_10_15_4 = 101504;

const int __MAC_10_16 = 101600;

const int __MAC_11_0 = 110000;

const int __MAC_11_1 = 110100;

const int __MAC_11_3 = 110300;

const int __MAC_11_4 = 110400;

const int __MAC_11_5 = 110500;

const int __MAC_11_6 = 110600;

const int __MAC_12_0 = 120000;

const int __MAC_12_1 = 120100;

const int __MAC_12_2 = 120200;

const int __MAC_12_3 = 120300;

const int __MAC_12_4 = 120400;

const int __MAC_12_5 = 120500;

const int __MAC_12_6 = 120600;

const int __MAC_12_7 = 120700;

const int __MAC_13_0 = 130000;

const int __MAC_13_1 = 130100;

const int __MAC_13_2 = 130200;

const int __MAC_13_3 = 130300;

const int __MAC_13_4 = 130400;

const int __MAC_13_5 = 130500;

const int __MAC_13_6 = 130600;

const int __MAC_13_7 = 130700;

const int __MAC_14_0 = 140000;

const int __MAC_14_1 = 140100;

const int __MAC_14_2 = 140200;

const int __MAC_14_3 = 140300;

const int __MAC_14_4 = 140400;

const int __MAC_14_5 = 140500;

const int __MAC_14_6 = 140600;

const int __MAC_14_7 = 140700;

const int __MAC_15_0 = 150000;

const int __MAC_15_1 = 150100;

const int __MAC_15_2 = 150200;

const int __MAC_15_3 = 150300;

const int __MAC_15_4 = 150400;

const int __MAC_15_5 = 150500;

const int __MAC_15_6 = 150600;

const int __MAC_16_0 = 160000;

const int __MAC_26_0 = 260000;

const int __IPHONE_2_0 = 20000;

const int __IPHONE_2_1 = 20100;

const int __IPHONE_2_2 = 20200;

const int __IPHONE_3_0 = 30000;

const int __IPHONE_3_1 = 30100;

const int __IPHONE_3_2 = 30200;

const int __IPHONE_4_0 = 40000;

const int __IPHONE_4_1 = 40100;

const int __IPHONE_4_2 = 40200;

const int __IPHONE_4_3 = 40300;

const int __IPHONE_5_0 = 50000;

const int __IPHONE_5_1 = 50100;

const int __IPHONE_6_0 = 60000;

const int __IPHONE_6_1 = 60100;

const int __IPHONE_7_0 = 70000;

const int __IPHONE_7_1 = 70100;

const int __IPHONE_8_0 = 80000;

const int __IPHONE_8_1 = 80100;

const int __IPHONE_8_2 = 80200;

const int __IPHONE_8_3 = 80300;

const int __IPHONE_8_4 = 80400;

const int __IPHONE_9_0 = 90000;

const int __IPHONE_9_1 = 90100;

const int __IPHONE_9_2 = 90200;

const int __IPHONE_9_3 = 90300;

const int __IPHONE_10_0 = 100000;

const int __IPHONE_10_1 = 100100;

const int __IPHONE_10_2 = 100200;

const int __IPHONE_10_3 = 100300;

const int __IPHONE_11_0 = 110000;

const int __IPHONE_11_1 = 110100;

const int __IPHONE_11_2 = 110200;

const int __IPHONE_11_3 = 110300;

const int __IPHONE_11_4 = 110400;

const int __IPHONE_12_0 = 120000;

const int __IPHONE_12_1 = 120100;

const int __IPHONE_12_2 = 120200;

const int __IPHONE_12_3 = 120300;

const int __IPHONE_12_4 = 120400;

const int __IPHONE_13_0 = 130000;

const int __IPHONE_13_1 = 130100;

const int __IPHONE_13_2 = 130200;

const int __IPHONE_13_3 = 130300;

const int __IPHONE_13_4 = 130400;

const int __IPHONE_13_5 = 130500;

const int __IPHONE_13_6 = 130600;

const int __IPHONE_13_7 = 130700;

const int __IPHONE_14_0 = 140000;

const int __IPHONE_14_1 = 140100;

const int __IPHONE_14_2 = 140200;

const int __IPHONE_14_3 = 140300;

const int __IPHONE_14_5 = 140500;

const int __IPHONE_14_6 = 140600;

const int __IPHONE_14_7 = 140700;

const int __IPHONE_14_8 = 140800;

const int __IPHONE_15_0 = 150000;

const int __IPHONE_15_1 = 150100;

const int __IPHONE_15_2 = 150200;

const int __IPHONE_15_3 = 150300;

const int __IPHONE_15_4 = 150400;

const int __IPHONE_15_5 = 150500;

const int __IPHONE_15_6 = 150600;

const int __IPHONE_15_7 = 150700;

const int __IPHONE_15_8 = 150800;

const int __IPHONE_16_0 = 160000;

const int __IPHONE_16_1 = 160100;

const int __IPHONE_16_2 = 160200;

const int __IPHONE_16_3 = 160300;

const int __IPHONE_16_4 = 160400;

const int __IPHONE_16_5 = 160500;

const int __IPHONE_16_6 = 160600;

const int __IPHONE_16_7 = 160700;

const int __IPHONE_17_0 = 170000;

const int __IPHONE_17_1 = 170100;

const int __IPHONE_17_2 = 170200;

const int __IPHONE_17_3 = 170300;

const int __IPHONE_17_4 = 170400;

const int __IPHONE_17_5 = 170500;

const int __IPHONE_17_6 = 170600;

const int __IPHONE_17_7 = 170700;

const int __IPHONE_18_0 = 180000;

const int __IPHONE_18_1 = 180100;

const int __IPHONE_18_2 = 180200;

const int __IPHONE_18_3 = 180300;

const int __IPHONE_18_4 = 180400;

const int __IPHONE_18_5 = 180500;

const int __IPHONE_18_6 = 180600;

const int __IPHONE_19_0 = 190000;

const int __IPHONE_26_0 = 260000;

const int __WATCHOS_1_0 = 10000;

const int __WATCHOS_2_0 = 20000;

const int __WATCHOS_2_1 = 20100;

const int __WATCHOS_2_2 = 20200;

const int __WATCHOS_3_0 = 30000;

const int __WATCHOS_3_1 = 30100;

const int __WATCHOS_3_1_1 = 30101;

const int __WATCHOS_3_2 = 30200;

const int __WATCHOS_4_0 = 40000;

const int __WATCHOS_4_1 = 40100;

const int __WATCHOS_4_2 = 40200;

const int __WATCHOS_4_3 = 40300;

const int __WATCHOS_5_0 = 50000;

const int __WATCHOS_5_1 = 50100;

const int __WATCHOS_5_2 = 50200;

const int __WATCHOS_5_3 = 50300;

const int __WATCHOS_6_0 = 60000;

const int __WATCHOS_6_1 = 60100;

const int __WATCHOS_6_2 = 60200;

const int __WATCHOS_7_0 = 70000;

const int __WATCHOS_7_1 = 70100;

const int __WATCHOS_7_2 = 70200;

const int __WATCHOS_7_3 = 70300;

const int __WATCHOS_7_4 = 70400;

const int __WATCHOS_7_5 = 70500;

const int __WATCHOS_7_6 = 70600;

const int __WATCHOS_8_0 = 80000;

const int __WATCHOS_8_1 = 80100;

const int __WATCHOS_8_3 = 80300;

const int __WATCHOS_8_4 = 80400;

const int __WATCHOS_8_5 = 80500;

const int __WATCHOS_8_6 = 80600;

const int __WATCHOS_8_7 = 80700;

const int __WATCHOS_8_8 = 80800;

const int __WATCHOS_9_0 = 90000;

const int __WATCHOS_9_1 = 90100;

const int __WATCHOS_9_2 = 90200;

const int __WATCHOS_9_3 = 90300;

const int __WATCHOS_9_4 = 90400;

const int __WATCHOS_9_5 = 90500;

const int __WATCHOS_9_6 = 90600;

const int __WATCHOS_10_0 = 100000;

const int __WATCHOS_10_1 = 100100;

const int __WATCHOS_10_2 = 100200;

const int __WATCHOS_10_3 = 100300;

const int __WATCHOS_10_4 = 100400;

const int __WATCHOS_10_5 = 100500;

const int __WATCHOS_10_6 = 100600;

const int __WATCHOS_10_7 = 100700;

const int __WATCHOS_11_0 = 110000;

const int __WATCHOS_11_1 = 110100;

const int __WATCHOS_11_2 = 110200;

const int __WATCHOS_11_3 = 110300;

const int __WATCHOS_11_4 = 110400;

const int __WATCHOS_11_5 = 110500;

const int __WATCHOS_11_6 = 110600;

const int __WATCHOS_12_0 = 120000;

const int __WATCHOS_26_0 = 260000;

const int __TVOS_9_0 = 90000;

const int __TVOS_9_1 = 90100;

const int __TVOS_9_2 = 90200;

const int __TVOS_10_0 = 100000;

const int __TVOS_10_0_1 = 100001;

const int __TVOS_10_1 = 100100;

const int __TVOS_10_2 = 100200;

const int __TVOS_11_0 = 110000;

const int __TVOS_11_1 = 110100;

const int __TVOS_11_2 = 110200;

const int __TVOS_11_3 = 110300;

const int __TVOS_11_4 = 110400;

const int __TVOS_12_0 = 120000;

const int __TVOS_12_1 = 120100;

const int __TVOS_12_2 = 120200;

const int __TVOS_12_3 = 120300;

const int __TVOS_12_4 = 120400;

const int __TVOS_13_0 = 130000;

const int __TVOS_13_2 = 130200;

const int __TVOS_13_3 = 130300;

const int __TVOS_13_4 = 130400;

const int __TVOS_14_0 = 140000;

const int __TVOS_14_1 = 140100;

const int __TVOS_14_2 = 140200;

const int __TVOS_14_3 = 140300;

const int __TVOS_14_5 = 140500;

const int __TVOS_14_6 = 140600;

const int __TVOS_14_7 = 140700;

const int __TVOS_15_0 = 150000;

const int __TVOS_15_1 = 150100;

const int __TVOS_15_2 = 150200;

const int __TVOS_15_3 = 150300;

const int __TVOS_15_4 = 150400;

const int __TVOS_15_5 = 150500;

const int __TVOS_15_6 = 150600;

const int __TVOS_16_0 = 160000;

const int __TVOS_16_1 = 160100;

const int __TVOS_16_2 = 160200;

const int __TVOS_16_3 = 160300;

const int __TVOS_16_4 = 160400;

const int __TVOS_16_5 = 160500;

const int __TVOS_16_6 = 160600;

const int __TVOS_17_0 = 170000;

const int __TVOS_17_1 = 170100;

const int __TVOS_17_2 = 170200;

const int __TVOS_17_3 = 170300;

const int __TVOS_17_4 = 170400;

const int __TVOS_17_5 = 170500;

const int __TVOS_17_6 = 170600;

const int __TVOS_18_0 = 180000;

const int __TVOS_18_1 = 180100;

const int __TVOS_18_2 = 180200;

const int __TVOS_18_3 = 180300;

const int __TVOS_18_4 = 180400;

const int __TVOS_18_5 = 180500;

const int __TVOS_18_6 = 180600;

const int __TVOS_19_0 = 190000;

const int __TVOS_26_0 = 260000;

const int __BRIDGEOS_2_0 = 20000;

const int __BRIDGEOS_3_0 = 30000;

const int __BRIDGEOS_3_1 = 30100;

const int __BRIDGEOS_3_4 = 30400;

const int __BRIDGEOS_4_0 = 40000;

const int __BRIDGEOS_4_1 = 40100;

const int __BRIDGEOS_5_0 = 50000;

const int __BRIDGEOS_5_1 = 50100;

const int __BRIDGEOS_5_3 = 50300;

const int __BRIDGEOS_6_0 = 60000;

const int __BRIDGEOS_6_2 = 60200;

const int __BRIDGEOS_6_4 = 60400;

const int __BRIDGEOS_6_5 = 60500;

const int __BRIDGEOS_6_6 = 60600;

const int __BRIDGEOS_7_0 = 70000;

const int __BRIDGEOS_7_1 = 70100;

const int __BRIDGEOS_7_2 = 70200;

const int __BRIDGEOS_7_3 = 70300;

const int __BRIDGEOS_7_4 = 70400;

const int __BRIDGEOS_7_6 = 70600;

const int __BRIDGEOS_8_0 = 80000;

const int __BRIDGEOS_8_1 = 80100;

const int __BRIDGEOS_8_2 = 80200;

const int __BRIDGEOS_8_3 = 80300;

const int __BRIDGEOS_8_4 = 80400;

const int __BRIDGEOS_8_5 = 80500;

const int __BRIDGEOS_8_6 = 80600;

const int __BRIDGEOS_9_0 = 90000;

const int __BRIDGEOS_9_1 = 90100;

const int __BRIDGEOS_9_2 = 90200;

const int __BRIDGEOS_9_3 = 90300;

const int __BRIDGEOS_9_4 = 90400;

const int __BRIDGEOS_9_5 = 90500;

const int __BRIDGEOS_9_6 = 90600;

const int __BRIDGEOS_10_0 = 100000;

const int __DRIVERKIT_19_0 = 190000;

const int __DRIVERKIT_20_0 = 200000;

const int __DRIVERKIT_21_0 = 210000;

const int __DRIVERKIT_22_0 = 220000;

const int __DRIVERKIT_22_4 = 220400;

const int __DRIVERKIT_22_5 = 220500;

const int __DRIVERKIT_22_6 = 220600;

const int __DRIVERKIT_23_0 = 230000;

const int __DRIVERKIT_23_1 = 230100;

const int __DRIVERKIT_23_2 = 230200;

const int __DRIVERKIT_23_3 = 230300;

const int __DRIVERKIT_23_4 = 230400;

const int __DRIVERKIT_23_5 = 230500;

const int __DRIVERKIT_23_6 = 230600;

const int __DRIVERKIT_24_0 = 240000;

const int __DRIVERKIT_24_1 = 240100;

const int __DRIVERKIT_24_2 = 240200;

const int __DRIVERKIT_24_3 = 240300;

const int __DRIVERKIT_24_4 = 240400;

const int __DRIVERKIT_24_5 = 240500;

const int __DRIVERKIT_24_6 = 240600;

const int __DRIVERKIT_25_0 = 250000;

const int __VISIONOS_1_0 = 10000;

const int __VISIONOS_1_1 = 10100;

const int __VISIONOS_1_2 = 10200;

const int __VISIONOS_1_3 = 10300;

const int __VISIONOS_2_0 = 20000;

const int __VISIONOS_2_1 = 20100;

const int __VISIONOS_2_2 = 20200;

const int __VISIONOS_2_3 = 20300;

const int __VISIONOS_2_4 = 20400;

const int __VISIONOS_2_5 = 20500;

const int __VISIONOS_2_6 = 20600;

const int __VISIONOS_3_0 = 30000;

const int __VISIONOS_26_0 = 260000;

const int MAC_OS_X_VERSION_10_0 = 1000;

const int MAC_OS_X_VERSION_10_1 = 1010;

const int MAC_OS_X_VERSION_10_2 = 1020;

const int MAC_OS_X_VERSION_10_3 = 1030;

const int MAC_OS_X_VERSION_10_4 = 1040;

const int MAC_OS_X_VERSION_10_5 = 1050;

const int MAC_OS_X_VERSION_10_6 = 1060;

const int MAC_OS_X_VERSION_10_7 = 1070;

const int MAC_OS_X_VERSION_10_8 = 1080;

const int MAC_OS_X_VERSION_10_9 = 1090;

const int MAC_OS_X_VERSION_10_10 = 101000;

const int MAC_OS_X_VERSION_10_10_2 = 101002;

const int MAC_OS_X_VERSION_10_10_3 = 101003;

const int MAC_OS_X_VERSION_10_11 = 101100;

const int MAC_OS_X_VERSION_10_11_2 = 101102;

const int MAC_OS_X_VERSION_10_11_3 = 101103;

const int MAC_OS_X_VERSION_10_11_4 = 101104;

const int MAC_OS_X_VERSION_10_12 = 101200;

const int MAC_OS_X_VERSION_10_12_1 = 101201;

const int MAC_OS_X_VERSION_10_12_2 = 101202;

const int MAC_OS_X_VERSION_10_12_4 = 101204;

const int MAC_OS_X_VERSION_10_13 = 101300;

const int MAC_OS_X_VERSION_10_13_1 = 101301;

const int MAC_OS_X_VERSION_10_13_2 = 101302;

const int MAC_OS_X_VERSION_10_13_4 = 101304;

const int MAC_OS_X_VERSION_10_14 = 101400;

const int MAC_OS_X_VERSION_10_14_1 = 101401;

const int MAC_OS_X_VERSION_10_14_4 = 101404;

const int MAC_OS_X_VERSION_10_14_5 = 101405;

const int MAC_OS_X_VERSION_10_14_6 = 101406;

const int MAC_OS_X_VERSION_10_15 = 101500;

const int MAC_OS_X_VERSION_10_15_1 = 101501;

const int MAC_OS_X_VERSION_10_15_4 = 101504;

const int MAC_OS_X_VERSION_10_16 = 101600;

const int MAC_OS_VERSION_11_0 = 110000;

const int MAC_OS_VERSION_11_1 = 110100;

const int MAC_OS_VERSION_11_3 = 110300;

const int MAC_OS_VERSION_11_4 = 110400;

const int MAC_OS_VERSION_11_5 = 110500;

const int MAC_OS_VERSION_11_6 = 110600;

const int MAC_OS_VERSION_12_0 = 120000;

const int MAC_OS_VERSION_12_1 = 120100;

const int MAC_OS_VERSION_12_2 = 120200;

const int MAC_OS_VERSION_12_3 = 120300;

const int MAC_OS_VERSION_12_4 = 120400;

const int MAC_OS_VERSION_12_5 = 120500;

const int MAC_OS_VERSION_12_6 = 120600;

const int MAC_OS_VERSION_12_7 = 120700;

const int MAC_OS_VERSION_13_0 = 130000;

const int MAC_OS_VERSION_13_1 = 130100;

const int MAC_OS_VERSION_13_2 = 130200;

const int MAC_OS_VERSION_13_3 = 130300;

const int MAC_OS_VERSION_13_4 = 130400;

const int MAC_OS_VERSION_13_5 = 130500;

const int MAC_OS_VERSION_13_6 = 130600;

const int MAC_OS_VERSION_13_7 = 130700;

const int MAC_OS_VERSION_14_0 = 140000;

const int MAC_OS_VERSION_14_1 = 140100;

const int MAC_OS_VERSION_14_2 = 140200;

const int MAC_OS_VERSION_14_3 = 140300;

const int MAC_OS_VERSION_14_4 = 140400;

const int MAC_OS_VERSION_14_5 = 140500;

const int MAC_OS_VERSION_14_6 = 140600;

const int MAC_OS_VERSION_14_7 = 140700;

const int MAC_OS_VERSION_15_0 = 150000;

const int MAC_OS_VERSION_15_1 = 150100;

const int MAC_OS_VERSION_15_2 = 150200;

const int MAC_OS_VERSION_15_3 = 150300;

const int MAC_OS_VERSION_15_4 = 150400;

const int MAC_OS_VERSION_15_5 = 150500;

const int MAC_OS_VERSION_15_6 = 150600;

const int MAC_OS_VERSION_16_0 = 160000;

const int MAC_OS_VERSION_26_0 = 260000;

const int __AVAILABILITY_VERSIONS_VERSION_HASH = 93585900;

const String __AVAILABILITY_VERSIONS_VERSION_STRING = 'Local';

const String __AVAILABILITY_FILE = 'AvailabilityVersions.h';

const int __MAC_OS_X_VERSION_MIN_REQUIRED = 260000;

const int __MAC_OS_X_VERSION_MAX_ALLOWED = 260000;

const int __ENABLE_LEGACY_MAC_AVAILABILITY = 1;

const int __DARWIN_NSIG = 32;

const int NSIG = 32;

const int _ARM_SIGNAL_ = 1;

const int SIGHUP = 1;

const int SIGINT = 2;

const int SIGQUIT = 3;

const int SIGILL = 4;

const int SIGTRAP = 5;

const int SIGABRT = 6;

const int SIGIOT = 6;

const int SIGEMT = 7;

const int SIGFPE = 8;

const int SIGKILL = 9;

const int SIGBUS = 10;

const int SIGSEGV = 11;

const int SIGSYS = 12;

const int SIGPIPE = 13;

const int SIGALRM = 14;

const int SIGTERM = 15;

const int SIGURG = 16;

const int SIGSTOP = 17;

const int SIGTSTP = 18;

const int SIGCONT = 19;

const int SIGCHLD = 20;

const int SIGTTIN = 21;

const int SIGTTOU = 22;

const int SIGIO = 23;

const int SIGXCPU = 24;

const int SIGXFSZ = 25;

const int SIGVTALRM = 26;

const int SIGPROF = 27;

const int SIGWINCH = 28;

const int SIGINFO = 29;

const int SIGUSR1 = 30;

const int SIGUSR2 = 31;

const int __DARWIN_OPAQUE_ARM_THREAD_STATE64 = 0;

const int SIGEV_NONE = 0;

const int SIGEV_SIGNAL = 1;

const int SIGEV_THREAD = 3;

const int SIGEV_KEVENT = 4;

const int ILL_NOOP = 0;

const int ILL_ILLOPC = 1;

const int ILL_ILLTRP = 2;

const int ILL_PRVOPC = 3;

const int ILL_ILLOPN = 4;

const int ILL_ILLADR = 5;

const int ILL_PRVREG = 6;

const int ILL_COPROC = 7;

const int ILL_BADSTK = 8;

const int FPE_NOOP = 0;

const int FPE_FLTDIV = 1;

const int FPE_FLTOVF = 2;

const int FPE_FLTUND = 3;

const int FPE_FLTRES = 4;

const int FPE_FLTINV = 5;

const int FPE_FLTSUB = 6;

const int FPE_INTDIV = 7;

const int FPE_INTOVF = 8;

const int SEGV_NOOP = 0;

const int SEGV_MAPERR = 1;

const int SEGV_ACCERR = 2;

const int BUS_NOOP = 0;

const int BUS_ADRALN = 1;

const int BUS_ADRERR = 2;

const int BUS_OBJERR = 3;

const int TRAP_BRKPT = 1;

const int TRAP_TRACE = 2;

const int CLD_NOOP = 0;

const int CLD_EXITED = 1;

const int CLD_KILLED = 2;

const int CLD_DUMPED = 3;

const int CLD_TRAPPED = 4;

const int CLD_STOPPED = 5;

const int CLD_CONTINUED = 6;

const int POLL_IN = 1;

const int POLL_OUT = 2;

const int POLL_MSG = 3;

const int POLL_ERR = 4;

const int POLL_PRI = 5;

const int POLL_HUP = 6;

const int SA_ONSTACK = 1;

const int SA_RESTART = 2;

const int SA_RESETHAND = 4;

const int SA_NOCLDSTOP = 8;

const int SA_NODEFER = 16;

const int SA_NOCLDWAIT = 32;

const int SA_SIGINFO = 64;

const int SA_USERTRAMP = 256;

const int SA_64REGSET = 512;

const int SA_USERSPACE_MASK = 127;

const int SIG_BLOCK = 1;

const int SIG_UNBLOCK = 2;

const int SIG_SETMASK = 3;

const int SI_USER = 65537;

const int SI_QUEUE = 65538;

const int SI_TIMER = 65539;

const int SI_ASYNCIO = 65540;

const int SI_MESGQ = 65541;

const int SS_ONSTACK = 1;

const int SS_DISABLE = 4;

const int MINSIGSTKSZ = 32768;

const int SIGSTKSZ = 131072;

const int SV_ONSTACK = 1;

const int SV_INTERRUPT = 2;

const int SV_RESETHAND = 4;

const int SV_NODEFER = 16;

const int SV_NOCLDSTOP = 8;

const int SV_SIGINFO = 64;

const int PRIO_PROCESS = 0;

const int PRIO_PGRP = 1;

const int PRIO_USER = 2;

const int PRIO_DARWIN_THREAD = 3;

const int PRIO_DARWIN_PROCESS = 4;

const int PRIO_MIN = -20;

const int PRIO_MAX = 20;

const int PRIO_DARWIN_BG = 4096;

const int PRIO_DARWIN_NONUI = 4097;

const int RUSAGE_SELF = 0;

const int RUSAGE_CHILDREN = -1;

const int RUSAGE_INFO_V0 = 0;

const int RUSAGE_INFO_V1 = 1;

const int RUSAGE_INFO_V2 = 2;

const int RUSAGE_INFO_V3 = 3;

const int RUSAGE_INFO_V4 = 4;

const int RUSAGE_INFO_V5 = 5;

const int RUSAGE_INFO_V6 = 6;

const int RUSAGE_INFO_CURRENT = 6;

const int RU_PROC_RUNS_RESLIDE = 1;

const int RLIM_INFINITY = 9223372036854775807;

const int RLIM_SAVED_MAX = 9223372036854775807;

const int RLIM_SAVED_CUR = 9223372036854775807;

const int RLIMIT_CPU = 0;

const int RLIMIT_FSIZE = 1;

const int RLIMIT_DATA = 2;

const int RLIMIT_STACK = 3;

const int RLIMIT_CORE = 4;

const int RLIMIT_AS = 5;

const int RLIMIT_RSS = 5;

const int RLIMIT_MEMLOCK = 6;

const int RLIMIT_NPROC = 7;

const int RLIMIT_NOFILE = 8;

const int RLIM_NLIMITS = 9;

const int _RLIMIT_POSIX_FLAG = 4096;

const int RLIMIT_WAKEUPS_MONITOR = 1;

const int RLIMIT_CPU_USAGE_MONITOR = 2;

const int RLIMIT_THREAD_CPULIMITS = 3;

const int RLIMIT_FOOTPRINT_INTERVAL = 4;

const int WAKEMON_ENABLE = 1;

const int WAKEMON_DISABLE = 2;

const int WAKEMON_GET_PARAMS = 4;

const int WAKEMON_SET_DEFAULTS = 8;

const int WAKEMON_MAKE_FATAL = 16;

const int CPUMON_MAKE_FATAL = 4096;

const int FOOTPRINT_INTERVAL_RESET = 1;

const int IOPOL_TYPE_DISK = 0;

const int IOPOL_TYPE_VFS_ATIME_UPDATES = 2;

const int IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES = 3;

const int IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME = 4;

const int IOPOL_TYPE_VFS_TRIGGER_RESOLVE = 5;

const int IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION = 6;

const int IOPOL_TYPE_VFS_IGNORE_PERMISSIONS = 7;

const int IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE = 8;

const int IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES = 9;

const int IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY = 10;

const int IOPOL_TYPE_VFS_ENTITLED_RESERVE_ACCESS = 14;

const int IOPOL_SCOPE_PROCESS = 0;

const int IOPOL_SCOPE_THREAD = 1;

const int IOPOL_SCOPE_DARWIN_BG = 2;

const int IOPOL_DEFAULT = 0;

const int IOPOL_IMPORTANT = 1;

const int IOPOL_PASSIVE = 2;

const int IOPOL_THROTTLE = 3;

const int IOPOL_UTILITY = 4;

const int IOPOL_STANDARD = 5;

const int IOPOL_APPLICATION = 5;

const int IOPOL_NORMAL = 1;

const int IOPOL_ATIME_UPDATES_DEFAULT = 0;

const int IOPOL_ATIME_UPDATES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT = 0;

const int IOPOL_MATERIALIZE_DATALESS_FILES_OFF = 1;

const int IOPOL_MATERIALIZE_DATALESS_FILES_ON = 2;

const int IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT = 0;

const int IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME = 1;

const int IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT = 0;

const int IOPOL_VFS_TRIGGER_RESOLVE_OFF = 1;

const int IOPOL_VFS_CONTENT_PROTECTION_DEFAULT = 0;

const int IOPOL_VFS_CONTENT_PROTECTION_IGNORE = 1;

const int IOPOL_VFS_IGNORE_PERMISSIONS_OFF = 0;

const int IOPOL_VFS_IGNORE_PERMISSIONS_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_OFF = 0;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_ON = 1;

const int IOPOL_VFS_SKIP_MTIME_UPDATE_IGNORE = 2;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF = 0;

const int IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON = 1;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT = 0;

const int IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON = 1;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT = 0;

const int IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON = 1;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_OFF = 0;

const int IOPOL_VFS_ENTITLED_RESERVE_ACCESS_ON = 1;

const int WNOHANG = 1;

const int WUNTRACED = 2;

const int WCOREFLAG = 128;

const int _WSTOPPED = 127;

const int WEXITED = 4;

const int WSTOPPED = 8;

const int WCONTINUED = 16;

const int WNOWAIT = 32;

const int WAIT_ANY = -1;

const int WAIT_MYPGRP = 0;

const int _QUAD_HIGHWORD = 1;

const int _QUAD_LOWWORD = 0;

const int __DARWIN_LITTLE_ENDIAN = 1234;

const int __DARWIN_BIG_ENDIAN = 4321;

const int __DARWIN_PDP_ENDIAN = 3412;

const int LITTLE_ENDIAN = 1234;

const int BIG_ENDIAN = 4321;

const int PDP_ENDIAN = 3412;

const int __DARWIN_BYTE_ORDER = 1234;

const int BYTE_ORDER = 1234;

const int EXIT_FAILURE = 1;

const int EXIT_SUCCESS = 0;

const int RAND_MAX = 2147483647;

const int _MALLOC_TYPE_MALLOC_BACKDEPLOY_PUBLIC = 1;
